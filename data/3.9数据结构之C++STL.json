[
  {
    "id": "1806",
    "category": "3.9数据结构之C++STL",
    "title": "1806:词典",
    "description": "<p>你旅游到了一个国外的城市。那里的人们说的外国语言你不能理解。不过幸运的是，你有一本词典可以帮助你。</p>",
    "img": "",
    "inputTip": "首先输入一个词典，词典中包含不超过100000个词条，每个词条占据一行。每一个词条包括一个英文单词和一个外语单词，两个单词之间用一个空格隔开。而且在词典中不会有某个外语单词出现超过两次。词典之后是一个空行，然后给出一个由外语单词组成的文档，文档不超过100000行，而且每行只包括一个外语单词。输入中出现单词只包括小写字母，而且长度不会超过10。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "在输出中，你需要把输入文档翻译成英文，每行输出一个英文单词。如果某个外语单词不在词典中，就把这个单词翻译成“eh”。",
    "inputExample": "<pre>dog ogday\ncat atcay\npig igpay\nfroot ootfray\nloops oopslay\n\natcay\nittenkay\noopslay\n</pre>",
    "outputExample": "<pre>cat\neh\nloops\n</pre>",
    "tip": "输入比较大，推荐使用C语言的I / O函数。",
    "timeLimited": "3000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2395",
    "category": "3.9数据结构之C++STL",
    "title": "2395:身份确认",
    "description": "    截至2008年5月23日12时，汶川大地震已经造成了55740人遇难，并且仍有数万人被掩埋在废墟之下。随着时间的推移，被埋和失踪者生还的希望越来越渺茫，而越来越多的遇难者的遗体开始成为卫生防疫工作最大的敌人。俗话说，大灾之后必有大疫，所以，如何防止疫情传播，尽量提高生还者的生存率，成了当前最重要的任务。于是，抗震救灾指挥部发布命令，对于发现的遇难者遗体，不再留存等待家属辨认，而是记录其体貌特征并留存DNA样本后，就地消毒深埋或火化。<br><br>    北京大学生命科学学院青年志愿者小分队是赶赴灾区负责DNA样本提取及识别的队伍之一，而你，则是队伍中的特派程序员。随着提取到的DNA样本量的增加以及心急如焚的家属们的辨认请求数的增加，如何快速进行匹配检验成了当前最大的难题。<br><br>    每个遇难者的DNA特征都可以用一个30位二进制整数来描述，为了方便存储，通常将其转化为10进制来记录。根据专家的研究结果，两个人有亲属关系，当且仅当他们的DNA特征对应的二进制整数按位异或得到的二进制整数中，有且仅有两个数位上为1。<br><br>    现在，你的任务是写一个程序，输入遇难者DNA数据库以及请求辨认的家属的DNA数据库，询问它们两个数据库之间有多少对亲属关系。<br>",
    "img": "",
    "inputTip": "第一行包含两个整数N, M，分别代表遇难者和家属的数量。接下来的N行，每行一个整数Vi，表示遇难者的DNA特征对应的整数。接下来的M行，每行一个整数Fi，表示家属的DNA特征对应的整数。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "仅包含一个整数，表示亲属关系的数量。",
    "inputExample": "<pre>2 1\n9\n7\n5\n</pre>",
    "outputExample": "<pre>1\n</pre>",
    "tip": "2 ≤ N, M ≤ 100000, 0 ≤ Vi，Fi < 230",
    "timeLimited": "15000ms",
    "spaceLimited": "5000ms"
  },
  {
    "id": "3339",
    "category": "3.9数据结构之C++STL",
    "title": "3339:List",
    "description": "<p>写一个程序完成以下命令：<br>new id ——新建一个指定编号为id的序列(id<10000)<br>add id num——向编号为id的序列加入整数num<br>merge id1 id2——合并序列id1和id2中的数，并将id2清空<br>unique id——去掉序列id中重复的元素<br>out id ——从小到大输出编号为id的序列中的元素，以空格隔开</p>",
    "img": "",
    "inputTip": "第一行一个数n，表示有多少个命令( n＜＝２０００００)。以后n行每行一个命令。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "按题目要求输出。",
    "inputExample": "<pre>16\nnew 1\nnew 2\nadd 1 1\nadd 1 2\nadd 1 3\nadd 2 1\nadd 2 2\nadd 2 3\nadd 2 4\nout 1\nout 2\nmerge 1 2\nout 1\nout 2\nunique 1\nout 1</pre>",
    "outputExample": "<pre>1 2 3 \n1 2 3 4\n1 1 2 2 3 3 4\n\n1 2 3 4</pre>",
    "tip": "",
    "timeLimited": "4000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "3341",
    "category": "3.9数据结构之C++STL",
    "title": "3341:Set",
    "description": "现有一整数集（允许有重复元素），初始为空。我们定义如下操作：<br>add x 把x加入集合<br>del x 把集合中所有与x相等的元素删除<br>ask x 对集合中元素x的情况询问<br>对每种操作，我们要求进行如下输出。<br>add 输出操作后集合中x的个数<br>del 输出操作前集合中x的个数<br>ask 先输出0或1表示x是否曾被加入集合（0表示不曾加入），再输出当前集合中x的个数，中间用空格格开。",
    "img": "",
    "inputTip": "第一行是一个整数n，表示命令数。0<=n<=100000。后面n行命令，如Description中所述。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "共n行，每行按要求输出。",
    "inputExample": "<pre>7\nadd 1\nadd 1\nask 1\nask 2\ndel 2\ndel 1\nask 1</pre>",
    "outputExample": "<pre>1\n2\n1 2\n0 0\n0\n2\n1 0</pre>",
    "tip": "Please use STL’s set and multiset to finish the task",
    "timeLimited": "5000ms",
    "spaceLimited": "100000kB"
  },
  {
    "id": "3342",
    "category": "3.9数据结构之C++STL",
    "title": "3342:字符串操作",
    "description": "<p>给定n个字符串（从1开始编号），每个字符串中的字符位置从0开始编号，长度为1-500，现有如下若干操作：</p><ul><li>copy N X L：取出第N个字符串第X个字符开始的长度为L的字符串。</li><li>add S1 S2：判断S1，S2是否为0-99999之间的整数，若是则将其转化为整数做加法，若不是，则作字符串加法，返回的值为一字符串。</li><li>find S N：在第N个字符串中从左开始找寻S字符串，返回其第一次出现的位置，若没有找到，返回字符串的长度。</li><li>rfind S N：在第N个字符串中从右开始找寻S字符串，返回其第一次出现的位置，若没有找到，返回字符串的长度。</li><li>insert S N X：在第N个字符串的第X个字符位置中插入S字符串。</li><li>reset S N：将第N个字符串变为S。</li><li>print N：打印输出第N个字符串。</li><li>printall：打印输出所有字符串。</li><li>over：结束操作。</li></ul><p>其中N，X，L可由find与rfind操作表达式构成，S，S1，S2可由copy与add操作表达式构成。</p>",
    "img": "",
    "inputTip": "第一行为一个整数n（n在1-20之间）接下来n行为n个字符串，字符串不包含空格及操作命令等。接下来若干行为一系列操作，直到over结束。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "根据操作提示输出对应字符串。",
    "inputExample": "<pre>3\n329strjvc\nOpadfk48\nIfjoqwoqejr\ninsert copy 1 find 2 1 2 2 2\nprint 2\nreset add copy 1 find 3 1 3 copy 2 find 2 2 2 3\nprint 3\ninsert a 3 2\nprintall\nover</pre>",
    "outputExample": "<pre>Op29adfk48\n358\n329strjvc\nOp29adfk48\n35a8</pre>",
    "tip": "推荐使用string类中的相关操作函数。",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "3343",
    "category": "3.9数据结构之C++STL",
    "title": "3343:热血格斗场",
    "description": "<p>为了迎接08年的奥运会，让大家更加了解各种格斗运动，facer新开了一家热血格斗场。格斗场实行会员制，但是新来的会员不需要交入会费，而只要同一名老会员打一场表演赛，证明自己的实力。</p><p>我们假设格斗的实力可以用一个正整数表示，成为实力值。另外，每个人都有一个唯一的id，也是一个正整数。为了使得比赛更好看，每一个新队员都会选择与他实力最为接近的人比赛，即比赛双方的实力值之差的绝对值越小越好，如果有两个人的实力值与他差别相同，则他会选择比他弱的那个（显然，虐人必被虐好）。</p><p>不幸的是，Facer一不小心把比赛记录弄丢了，但是他还保留着会员的注册记录。现在请你帮facer恢复比赛纪录，按照时间顺序依次输出每场比赛双方的id。</p>",
    "img": "",
    "inputTip": "第一行一个数n(0 < n <=100000)，表示格斗场新来的会员数（不包括facer）。以后n行每一行两个数，按照入会的时间给出会员的id和实力值。一开始，facer就算是会员，id为1，实力值1000000000。输入保证两人的实力值不同。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "N行，每行两个数，为每场比赛双方的id，新手的id写在前面。",
    "inputExample": "<pre>3\n2 1\n3 3\n4 2</pre>",
    "outputExample": "<pre>2 1\n3 2\n4 2</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "3344",
    "category": "3.9数据结构之C++STL",
    "title": "3344:冷血格斗场",
    "description": "<p>为了迎接08年的奥运会，让大家更加了解各种格斗运动，facer新开了一家冷血格斗场。格斗场实行会员制，但是新来的会员不需要交入会费，而只要同一名老会员打一场表演赛，证明自己的实力。</p><p>我们假设格斗的实力可以用一个正整数表示，成为实力值，两人的实力值可以相同。另外，每个人都有一个唯一的id，也是一个正整数。为了使得比赛更好看，每一个新队员都会选择与他实力最为接近的人比赛，即比赛双方的实力值之差的绝对值越小越好，如果有多个人的实力值与他差别相同，则他会选择id最小的那个。</p><p>不幸的是，Facer一不小心把比赛记录弄丢了，但是他还保留着会员的注册记录。现在请你帮facer恢复比赛纪录，按照时间顺序依次输出每场比赛双方的id。</p>",
    "img": "",
    "inputTip": "第一行一个数n(0 < n <=100000)，表示格斗场新来的会员数（不包括facer）。以后n行每一行两个数，按照入会的时间给出会员的id和实力值。一开始，facer就算是会员，id为1，实力值1000000000。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "N行，每行两个数，为每场比赛双方的id，新手的id写在前面。",
    "inputExample": "<pre>3\n2 3\n3 1\n4 2</pre>",
    "outputExample": "<pre>2 1\n3 2\n4 2</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "3345",
    "category": "3.9数据结构之C++STL",
    "title": "3345:priority queue练习题",
    "description": "<p>我们定义一个正整数a比正整数b优先的含义是：<br>*a的质因数数目（不包括自身）比b的质因数数目多；<br>*当两者质因数数目相等时，数值较大者优先级高。</p><br><p>现在给定一个容器，初始元素数目为0，之后每次往里面添加10个元素，每次添加之后，要求输出优先级最高与最低的元素，并把该两元素从容器中删除。</p>",
    "img": "",
    "inputTip": "第一行: num (添加元素次数，num <= 30)下面10*num行，每行一个正整数n（n < 10000000).",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "每次输入10个整数后，输出容器中优先级最高与最低的元素，两者用空格间隔。",
    "inputExample": "<pre>1\n10 7 66 4 5 30 91 100 8 9</pre>",
    "outputExample": "<pre>66 5</pre>",
    "tip": "",
    "timeLimited": "2500ms",
    "spaceLimited": "131072kB"
  },
  {
    "id": "835",
    "category": "3.9数据结构之C++STL",
    "title": "835:排列",
    "description": "题目描述：<br>   大家知道，给出正整数n，则1到n这n个数可以构成n！种排列，把这些排列按照从小到大的顺序（字典顺序）列出，如n=3时，列出1 2 3，1 3 2，2 1 3，2 3 1，3 1 2，3 2 1六个排列。<br><br>任务描述：<br>   给出某个排列，求出这个排列的下k个排列，如果遇到最后一个排列，则下1排列为第1个排列，即排列1 2 3…n。<br>   比如：n = 3，k=2 给出排列2 3 1，则它的下1个排列为3 1 2，下2个排列为3 2 1，因此答案为3 2 1。<br>",
    "img": "",
    "inputTip": "第一行是一个正整数m，表示测试数据的个数，下面是m组测试数据，每组测试数据第一行是2个正整数n( 1 <= n < 1024 )和k(1<=k<=64)，第二行有n个正整数，是1，2 … n的一个排列。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对于每组输入数据，输出一行，n个数，中间用空格隔开，表示输入排列的下k个排列。",
    "inputExample": "<pre>3\n3 1\n2 3 1\n3 1\n3 2 1\n10 2\t\n1 2 3 4 5 6 7 8 9 10\n</pre>",
    "outputExample": "<pre>3 1 2\n1 2 3\n1 2 3 4 5 6 7 9 8 10\n</pre>",
    "tip": "qinlu@POJ",
    "timeLimited": "5000ms",
    "spaceLimited": "65536kB"
  }
]