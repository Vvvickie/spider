[
  {
    "id": "1288",
    "category": "4.7算法之搜索",
    "title": "1288:The Rotation Game",
    "description": "The rotation game uses a # shaped board, which can hold 24 pieces of square blocks (see Fig.1). The blocks are marked with symbols 1, 2 and 3, with exactly 8 pieces of each kind. <br><center><img src=\"http://media.openjudge.cn/images/2286_1.jpg\"></center> <br>Initially, the blocks are placed on the board randomly. Your task is to move the blocks so that the eight blocks placed in the center square have the same symbol marked. There is only one type of valid move, which is to rotate one of the four lines, each consisting of seven blocks. That is, six blocks in the line are moved towards the head by one block and the head block is moved to the end of the line. The eight possible moves are marked with capital letters A to H. Figure 1 illustrates two consecutive moves, move A and move C from some initial configuration. <br>",
    "img": "",
    "inputTip": "The input consists of no more than 30 test cases. Each test case has only one line that contains 24 numbers, which are the symbols of the blocks in the initial configuration. The rows of blocks are listed from top to bottom. For each row the blocks are listed from left to right. The numbers are separated by spaces. For example, the first test case in the sample input corresponds to the initial configuration in Fig.1. There are no blank lines between cases. There is a line containing a single `0' after the last test case that ends the input. ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each test case, you must output two lines. The first line contains all the moves needed to reach the final configuration. Each move is a letter, ranging from `A' to `H', and there should not be any spaces between the letters in the line. If no moves are needed, output `No moves needed' instead. In the second line, you must output the symbol of the blocks in the center square after these moves. If there are several possible solutions, you must output the one that uses the least number of moves. If there is still more than one possible solution, you must output the solution that is smallest in dictionary order for the letters of the moves. There is no need to output blank lines between cases. ",
    "inputExample": "<pre>1 1 1 1 3 2 3 2 3 1 3 2 2 3 1 2 2 2 3 1 2 1 3 3\n1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3\n0\n</pre>",
    "outputExample": "<pre>AC\n2\nDDHH\n2\n</pre>",
    "tip": "Shanghai 2004",
    "timeLimited": "15000ms",
    "spaceLimited": "150000kB"
  },
  {
    "id": "13",
    "category": "4.7算法之搜索",
    "title": "13:Sticks",
    "description": "George took sticks of the same length and cut them randomly until all parts became at most 50 units long. Now he wants to return sticks to the original state, but he forgot how many sticks he had originally and how long they were originally. Please help him and design a program which computes the smallest possible original length of those sticks. All lengths expressed in units are integers greater than zero. ",
    "img": "",
    "inputTip": "The input contains blocks of 2 lines. The first line contains the number of sticks parts after cutting, there are at most 64 sticks. The second line contains the lengths of those parts separated by the space. The last line of the file contains zero.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "The output should contains the smallest possible length of original sticks, one per line. ",
    "inputExample": "<pre>9\n5 2 1 5 2 1 5 2 1\n4\n1 2 3 4\n0\n</pre>",
    "outputExample": "<pre>6\n5</pre>",
    "tip": "Central Europe 1995",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "169",
    "category": "4.7算法之搜索",
    "title": "169:The Buses",
    "description": "A man arrives at a bus stop at 12:00. He remains there during 12:00-12:59. The bus stop is used by a number of bus routes. The man notes the times of arriving buses. The times when buses arrive are given. <br><ul><li>\tBuses on the same route arrive at regular intervals from 12:00 to 12:59 throughout the entire hour. <br></li><li>\tTimes are given in whole minutes from 0 to 59. <br></li><li>\tEach bus route stops at least 2 times. <br></li><li>\tThe number of bus routes in the test examples will be <=17. <br></li><li>\tBuses from different routes may arrive at the same time. <br></li><li>\tSeveral bus routes can have the same time of first arrival and/or time interval. If two bus routes have the same starting time and interval, they are distinct and are both to be presented. </li></ul><br>Find the schedule with the fewest number of bus routes that must stop at the bus stop to satisfy the input data. For each bus route, output the starting time and the interval. <br>",
    "img": "",
    "inputTip": "Your program is to read from standard input. The input contains a number n (n <= 300) telling how many arriving buses have been noted, followed by the arrival times in ascending order. ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "Your program is to write to standard output. The output contains one integer, which is the fewest number of bus routes.",
    "inputExample": "<pre>17\n0 3 5 13 13 15 21 26 27 29 37 39 39 45 51 52 53</pre>",
    "outputExample": "<pre>3</pre>",
    "tip": "IOI 1994",
    "timeLimited": "5000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1814",
    "category": "4.7算法之搜索",
    "title": "1814:恼人的青蛙",
    "description": "<p>在韩国，有一种小的青蛙。每到晚上，这种青蛙会跳越稻田，从而踩踏稻子。农民在早上看到被踩踏的稻子，希望找到造成最大损害的那只青蛙经过的路径。每只青蛙总是沿着一条直线跳越稻田，而且每次跳跃的距离都相同。<br><br><img src=\"http://media.openjudge.cn/images/2812_1.jpg\">如下图所示，稻田里的稻子组成一个栅格，每棵稻子位于一个格点上。而青蛙总是从稻田的一侧跳进稻田，然后沿着某条直线穿越稻田，从另一侧跳出去<br><br><img src=\"http://media.openjudge.cn/images/2812_2.jpg\">如下图所示，可能会有多只青蛙从稻田穿越。青蛙的每一跳都恰好踩在一棵水稻上，将这棵水稻拍倒。有些水稻可能被多只青蛙踩踏。当然，农民所见到的是图4中的情形，并看不到图3中的直线，也见不到别人家田里被踩踏的水稻，。<br><img src=\"http://media.openjudge.cn/images/2812_3.jpg\">根据图4，农民能够构造出青蛙穿越稻田时的行走路径，并且只关心那些在穿越稻田时至少踩踏了3棵水稻的青蛙。因此，每条青蛙行走路径上至少包括3棵被踩踏的水稻。而在一条青蛙行走路径的直线上，也可能会有些被踩踏的水稻不属于该行走路径<br>①不是一条行走路径：只有两棵被踩踏的水稻；<br>②是一条行走路径，但不包括（2，6）上的水道；<br>③不是一条行走路径：虽然有3棵被踩踏的水稻，但这三棵水稻之间的距离间隔不相等。<br><br>请你写一个程序，确定：在一条青蛙行走路径中，最多有多少颗水稻被踩踏。例如，图4的答案是7，因为第6行上全部水稻恰好构成一条青蛙行走路径。</p>",
    "img": "",
    "inputTip": "从标准输入设备上读入数据。第一行上两个整数R、C，分别表示稻田中水稻的行数和列数，1≤R、C≤5000。第二行是一个整数N，表示被踩踏的水稻数量， 3≤N≤5000。在剩下的N行中，每行有两个整数，分别是一颗被踩踏水稻的行号(1~R)和列号(1~C)，两个整数用一个空格隔开。而且，每棵被踩踏水稻只被列出一次。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "从标准输出设备上输出一个整数。如果在稻田中存在青蛙行走路径，则输出包含最多水稻的青蛙行走路径中的水稻数量，否则输出0。",
    "inputExample": "<pre>6 7\n14 \n2 1 \n6 6 \n4 2 \n2 5 \n2 6 \n2 7 \n3 4 \n6 1 \n6 2 \n2 3 \n6 3 \n6 4 \n6 5 \n6 7 </pre>",
    "outputExample": "<pre>7\n</pre>",
    "tip": "1054",
    "timeLimited": "2000ms",
    "spaceLimited": "500ms"
  },
  {
    "id": "1819",
    "category": "4.7算法之搜索",
    "title": "1819:木棒",
    "description": "乔治拿来一组等长的木棒，将它们随机地裁断，使得每一节木棍的长度都不超过50个长度单位。然后他又想把这些木棍恢复到为裁截前的状态，但忘记了初始时有多少木棒以及木棒的初始长度。请你设计一个程序，帮助乔治计算木棒的可能最小长度。每一节木棍的长度都用大于零的整数表示。",
    "img": "",
    "inputTip": "输入包含多组数据，每组数据包括两行。第一行是一个不超过64的整数，表示砍断之后共有多少节木棍。第二行是截断以后，所得到的各节木棍的长度。在最后一组数据之后，是一个零。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "为每组数据，分别输出原始木棒的可能最小长度，每组数据占一行。 ",
    "inputExample": "<pre>9\n5 2 1 5 2 1 5 2 1\n4\n1 2 3 4\n0\n</pre>",
    "outputExample": "<pre>6\n5\n</pre>",
    "tip": "POJ 1011",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "192",
    "category": "4.7算法之搜索",
    "title": "192:生日蛋糕",
    "description": "7月17日是Mr.W的生日，ACM-THU为此要制作一个体积为Nπ的M层生日蛋糕，每层都是一个圆柱体。<br>设从下往上数第i(1 <= i <= M)层蛋糕是半径为Ri, 高度为Hi的圆柱。当i < M时，要求Ri > Ri+1且Hi > Hi+1。<br>由于要在蛋糕上抹奶油，为尽可能节约经费，我们希望蛋糕外表面（最下一层的下底面除外）的面积Q最小。<br>令Q = Sπ<br>请编程对给出的N和M，找出蛋糕的制作方案（适当的Ri和Hi的值），使S最小。<br>（除Q外，以上所有数据皆为正整数）<br>",
    "img": "",
    "inputTip": "有两行，第一行为N（N <= 10000），表示待制作的蛋糕的体积为Nπ；第二行为M(M <= 20)，表示蛋糕的层数为M。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "仅一行，是一个正整数S（若无解则S = 0）。",
    "inputExample": "<pre>100\n2</pre>",
    "outputExample": "<pre>68</pre>",
    "tip": "圆柱公式体积V = πR2H侧面积A' = 2πRH底面积A = πR2",
    "timeLimited": "5000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "56",
    "category": "4.7算法之搜索",
    "title": "56:The Troublesome Frog",
    "description": "<p>In Korea, the naughtiness of the cheonggaeguri, a small frog, is legendary.  This is a well-deserved reputation, because the frogs jump through your rice paddy at night, flattening rice plants.  In the morning, after noting which plants have been flattened, you want to identify the path of the frog which did the most damage.  A frog always jumps through the paddy in a straight line, with every hop the same length:<br><img src=\"http://media.openjudge.cn/images/g56/frog1.jpg\">Your rice paddy has plants arranged on the intersection points of a grid as shown in Figure-1, and the troublesome frogs hop completely through your paddy, starting outside the paddy on one side and ending outside the paddy on the other side as shown in Figure-2:<br><img src=\"http://media.openjudge.cn/images/g56/frog3.jpg\">Many frogs can jump through the paddy, hopping from rice plant to rice plant.  Every hop lands on a plant and flattens it, as in Figure-3.  Note that some plants may be landed on by more than one frog during the night.  Of course, you can not see the lines showing the paths of the frogs or any of their hops outside of your paddy ?for the situation in Figure-3, what you can see is shown in Figure-4:<br><img src=\"http://media.openjudge.cn/images/g56/frog2.jpg\">From Figure-4, you can reconstruct all the possible paths which the frogs may have followed across your paddy.  You are only interested in frogs which have landed on at least 3 of your rice plants in their voyage through the paddy.  Such a path is said to be a frog path.  In this case, that means that the three paths shown in Figure-3 are frog paths (there are also other possible frog paths). The vertical path down column 1 might have been a frog path with hop length 4 except there are only 2 plants flattened so we are not interested; and the diagonal path including the plants on row 2 col. 3, row 3 col. 4, and row 6 col. 7 has three flat plants but there is no regular hop length which could have spaced the hops in this way while still landing on at least 3 plants, and hence it is not a frog path.  Note also that along the line a frog path follows there may be additional flattened plants which do not need to be landed on by that path (see the plant at (2, 6) on the horizontal path across row 2 in Figure-4), and in fact some flattened plants may not be explained by any frog path at all.<br><br>Your task is to write a program to determine the maximum number of landings in any single frog path (where the maximum is taken over all possible frog paths).  In Figure-4 the answer is 7, obtained from the frog path across row 6.</p>",
    "img": "",
    "inputTip": "Your program is to read from standard input. The first line contains two integers R and C, respectively the number of rows and columns in your rice paddy, 1 <= R,C <= 5000.  The second line contains the single integer N, the number of flattened rice plants, 3 <= N <= 5000.  Each of the remaining N lines contains two integers, the row number (1 <= row number <= R) and the column number (1 <= column number <= C) of a flattened rice plant, separated by one blank. Each flattened plant is only listed once.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "Your program is to write to standard output. The output contains one line with a single integer, the number of plants flattened along a frog path which did the most damage if there exists at least one frog path, otherwise, 0.",
    "inputExample": "<pre>6 7\n14\n2 1\n6 6\n4 2\n2 5\n2 6\n2 7\n3 4\n6 1\n6 2\n2 3\n6 3\n6 4\n6 5\n6 7\n</pre>",
    "outputExample": "<pre>7</pre>",
    "tip": "IOI 2002",
    "timeLimited": "5000ms",
    "spaceLimited": "500ms"
  },
  {
    "id": "6043",
    "category": "4.7算法之搜索",
    "title": "6043:哆啦A梦的时光机",
    "description": "<p><span style=\"font-size:12.0pt;font-family:宋体\">哆啦</span><span style=\"font-size:12.0pt;font-family:'Calibri','sans-serif'\">A</span><span style=\"font-size:12.0pt;font-family:宋体\">梦有一个神奇的道具：时光机。坐着它，大雄和他的伙伴们能穿越时空，回到过去或者去到未来。</span></p><p><img src=\"http://media.openjudge.cn/images/upload/1372385220.jpg\" height=\"427\" width=\"558\"><br></p><p class=\"MsoNormal\"><span style=\"font-size:12.0pt;font-family:宋体\">有一天，大雄和他的伙伴们想穿越时空进行探险，可是时光机却出了一点故障，只能进行有限的时空穿越操作。大雄他们需要从现在出发，到达一个目标时间点进行探险，结束后再返回到现在，他们希望尽可能减少时光机的操作次数，你能帮助他们吗？</span></p><p class=\"MsoNormal\"><span style=\"font-size:12.0pt\"> </span></p><p class=\"MsoNormal\"><span style=\"font-size:12.0pt;font-family:宋体\">假设大雄和他的伙伴们出发的时间点（现在）为</span><span style=\"font-size:12.0pt\">S</span><span style=\"font-size:12.0pt;font-family:宋体\">（</span><span style=\"font-size:12.0pt\">0 < S < 1,000,000</span><span style=\"font-size:12.0pt;font-family:宋体\">），希望到达的时间点（目标）为</span><span style=\"font-size:12.0pt\">T</span><span style=\"font-size:12.0pt;font-family:宋体\">（</span><span style=\"font-size:12.0pt\">0 < T < 1,000,000</span><span style=\"font-size:12.0pt;font-family:宋体\">），已知时光机可以进行如下的时空穿越操作（</span><span style=\"font-size:12.0pt\">X</span><span style=\"font-size:12.0pt;font-family:宋体\">为正整数）：</span></p><ol style=\"list-style-type:decimal\"><li><p><span style=\"font-size:12.0pt;font-family:宋体\">可以从任意时刻</span><span style=\"font-size:12.0pt\">X</span><span style=\"font-size:12.0pt;font-family:宋体\">穿越到</span><span style=\"font-size:12.0pt\">X+1</span><span style=\"font-size:12.0pt;font-family:宋体\">或者</span><span style=\"font-size:12.0pt\">X-1</span><span style=\"font-size:12.0pt;font-family:宋体\">时刻</span></p></li><li><p><span style=\"font-size:12.0pt;font-family:宋体\">可以从任意时刻</span><span style=\"font-size:12.0pt\">X</span><span style=\"font-size:12.0pt;font-family:宋体\">穿越到</span><span style=\"font-size:12.0pt\">X*2</span><span style=\"font-size:12.0pt;font-family:宋体\">时刻</span></p></li><li><p><span style=\"font-size:12.0pt;font-family:宋体\">当</span><span style=\"font-size:12.0pt\">X</span><span style=\"font-size:12.0pt;font-family:宋体\">为偶数时，可以从</span><span style=\"font-size:12.0pt\">X</span><span style=\"font-size:12.0pt;font-family:宋体\">时刻穿越到</span><span style=\"font-size:12.0pt\">X/2</span><span style=\"font-size:12.0pt;font-family:宋体\">时刻</span></p></li></ol><p class=\"MsoNormal\"><span style=\"font-size:12.0pt\"> </span></p><p class=\"MsoNormal\"><span style=\"font-size:12.0pt;font-family:宋体\">请问，大雄和他的伙伴们从</span><span style=\"font-size:12.0pt\">S</span><span style=\"font-size:12.0pt;font-family:宋体\">时刻出发，先到达</span><span style=\"font-size:12.0pt\">T</span><span style=\"font-size:12.0pt;font-family:宋体\">时刻，再回到</span><span style=\"font-size:12.0pt\">S</span><span style=\"font-size:12.0pt;font-family:宋体\">时刻最少需要多少次时空穿越操作？</span></p>",
    "img": "",
    "inputTip": "输入的第一个数是一个正整数N，表示测试数据一共有N组（0 < N < 20）。之后有N行，每一行包含两个正整数S和T，表示出发和到达时间点。S≠T",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出包括N行，每一行一个正整数，表示每组测试数据对应的最少时光机操作次数。",
    "inputExample": "<pre>2\n5 17\n4 8</pre>",
    "outputExample": "<pre>8\n2</pre>",
    "tip": "对于S=5，T=17：操作如下：5->4->8->16->17->16->8->4->5对于S=4，T=8：操作如下：4->8->4",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "699",
    "category": "4.7算法之搜索",
    "title": "699:The Erythea Campaign",
    "description": "<code>O' mighty warrior,<br>Thy mission is to slay the foul king of Erythea. <br>Thou shall find him in his realm in the south.<br>God bless you,<br>King of Isladia.</code><br>After reading the order, you know you have a long, dangerous way down to the south, to find the king of Erythea in his realm and kill him. The Erythea realm is a rectangular region, with a number of horrible strongholds in it. Impenetrable walls enclose the region, so the only way for you to enter the realm is to fly by your Pegasus (flying horse) and land in some point in the region. The hiding place of the king is known so you just need to find your way to that location. As the area is extensive and covered by different terrain types, you have to travel on the grid-like roads in the region. The problem is, there are many guards on the towers of strongholds who can see you, and once seen, you have no chance to see your family again! The closer you travel to the strongholds, the greater the chances to be seen by the guards. The problem is to find the safest way from the point your Pegasus lands to the point where the king is.<br>More abstractly, you have an m * n grid with squares of the same size, denoting the realm and the roads in it. You can travel along the lines in the grid (roads), and at each intersection (road crossing) you may turn into another road. Assume each stronghold comprises a set of adjacent squares of the grid (Figure 1). As you cannot enter a stronghold, your path never intersects the interior of a stronghold, yet you can travel on a road which is on stronghold boundaries (Figure 2). Suppose you can land your Pegasus exactly on a road crossing (the source point - S in Figure 1) and the hiding place of the king is on another road crossing (the destination point - D in Figure 1). Neither of these points lie inside a stronghold but may be placed on a stronghold boundary (as D does in Figure 1). Each road crossing is assigned a risk level which depends on the shortest road distance from the crossing to a point of the grid which is on the boundary of a stronghold. For a road crossing with the shortest road distance d to a boundary of strongholds, the risk level equals to m + n - d  (Figure 3).  It is assumed that <b>there is at least one stronghold in the region,</b> so that the definition of risk level is well-defined.  The problem is, given the region's map and the source and destination points, find the path from the source to the destination which lies on the grid lines, so that sum of the risk levels of the points on the path (including source and destination) be minimum. As stated before, the path cannot intersect the interior of a stronghold.<br><table><tbody><tr><td><img src=\"http://media.openjudge.cn/images/1697_1.jpg\"><br></td><td><img src=\"http://media.openjudge.cn/images/1697_2.jpg\"></td><td><img src=\"http://media.openjudge.cn/images/1697_3.jpg\"></td></tr><tr><td>Figure 1. An 8 * 6 region. <br>You can travel along the grid lines (including boundary lines). <br>The shaded squares are strongholds.</td><td>Figure 2. (a) Traveling on the boundary of a stronghold is allowed.<br>(b) Crossing a stronghold is not allowed.<br></td><td>Figure 3. Point P in a 5*6 grid has distance 3 from stronghold A and distance 2 from stronghold B. Thus, risk level of P is (5+6)-2 = 9.</td></tr></tbody></table>",
    "img": "",
    "inputTip": "The input consists of several test cases. The first line of the file contains a single number M, which is the number of test cases in the file (1 <= M <= 10). The rest of the file consists of the data of the test cases. Each test case data begins with a line containing the number of rows and the number of columns in the grid, which are in the range 1 to 80. The second line of a test case contains two pairs of integers, which are y and x coordinates of the source point (where the Pegasus landed) and the y and x coordinates of the destination point (where you may find the king). The horizontal and vertical lines in the grid are indexed from left to right and top to bottom from 0, so the coordinates can be expressed using these indices.Following the first two lines, there are lines that describe the map of the region. Each line consists of a string of 0's and 1's, describing squares of the corresponding row. A 1 in the string tells you that the corresponding square in the grid belongs to a stronghold.  The width of the region is the length of all strings, and its height in the number of strings.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "The output for each test case is the total risk of the minimum risk path from the landing point to the destination. Recall that the total risk of a path is sum of the risk levels of the points in the path (including source and destination). If no path exists between source and destination, the output should be 'no solution'. The output for each test case must be written on a separate line. ",
    "inputExample": "<pre>2\n8 6\n1 5 7 1\n000000\n011000\n001000\n000110\n000110\n000010\n111000\n000000\n5 5\n4 0 1 5\n10000\n10000\n11111\n00011\n00001\n</pre>",
    "outputExample": "<pre>149\n101\n</pre>",
    "tip": "The above input file contains two test cases. The first test case is the one shown in Figure 1.",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7222",
    "category": "4.7算法之搜索",
    "title": "7222:怀表问题",
    "description": "<p class=\"MsoNormal\"><span style=\"font-size:11.0pt;font-family:楷体\">怀表是由一个表链和一个表盘连接而成的。同时，表链又是由多个长度为</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">1</span><span style=\"font-size:11.0pt;font-family:楷体\">的表链组件连接而成的。小明现有一个表盘和多个长度为</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">1</span><span style=\"font-size:11.0pt;font-family:楷体\">的表链组件。他希望组合成一个完整的怀表当做生日礼物送给爸爸。</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\"><span style=\"\">   <br></span></span></p><p class=\"MsoNormal\" style=\"\"><span style=\"font-size:11.0pt;font-family:楷体\">表盘和表链组件的两端都有表扣可以和其它的表链组件或者表盘相连。</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\"> </span><span style=\"font-size:11.0pt;font-family:楷体\">一共有两种表扣设计，分别是</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">“L” </span><span style=\"font-size:11.0pt;font-family:楷体\">和</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">“V”</span><span style=\"font-size:11.0pt;font-family:楷体\">。表链组件和表盘的左右两端可以使用相同的或者不同的表扣设计，因此我们有以下四种不同的表链组件和表盘设计方式，</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">“LL”, “LV”, “VL”, “VV”</span><span style=\"font-size:11.0pt;font-family:楷体\">，如“</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">LV</span><span style=\"font-size:11.0pt;font-family:楷体\">”表示左端的表扣设计是</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">”L”, </span><span style=\"font-size:11.0pt;font-family:楷体\">右端的表扣设计是“</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">V</span><span style=\"font-size:11.0pt;font-family:楷体\">”。另，表盘和表链是不允许上下左右翻转的。如果把两个表链组件或者一个表链组件和表盘相连接，那么相连部分的表扣设计必须一致。此外，还必须确保表盘可以连接到表链的任意一端。</span></p><p class=\"MsoNormal\"><span style=\"font-size:11.0pt;font-family:楷体\">例子</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">1</span><span style=\"font-size:11.0pt;font-family:楷体\">：表盘是</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">“LV”</span><span style=\"font-size:11.0pt;font-family:楷体\">，共有</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">5</span><span style=\"font-size:11.0pt;font-family:楷体\">个表链组件分别是，</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">“LL”, “LL”, “LV”, “VL”, “VL” </span><span style=\"font-size:11.0pt;font-family:楷体\">。现在希望组合成长度为</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">4</span><span style=\"font-size:11.0pt;font-family:楷体\">的怀表（表链长度是</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">4</span><span style=\"font-size:11.0pt;font-family:楷体\">）。</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\"> </span><span style=\"font-size:11.0pt;font-family:楷体\">有两种正确的表链组合方式：</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">“VLLLLVVL” </span><span style=\"font-size:11.0pt;font-family:楷体\">和</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">“VLLVVLLL”</span><span style=\"font-size:11.0pt;font-family:楷体\">。而且，对于每一种表链的组合方式，表盘都可以连接到表链的左右两端</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\"> </span><span style=\"font-size:11.0pt;font-family:楷体\">（表盘放到表链左端使用</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">V</span><span style=\"font-size:11.0pt;font-family:楷体\">相连，表盘放到表链右端使用</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">L</span><span style=\"font-size:11.0pt;font-family:楷体\">相连）。</span></p><p class=\"MsoNormal\"><span style=\"font-size:11.0pt;font-family:楷体\">例子</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">2:<span style=\"\">  </span></span><span style=\"font-size:11.0pt;font-family:楷体\">表盘是</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">“LL”</span><span style=\"font-size:11.0pt;font-family:楷体\">，共有</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">4</span><span style=\"font-size:11.0pt;font-family:楷体\">个表链组件分别是，</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">“LL”, “LV”, “VL”, “VV”</span><span style=\"font-size:11.0pt;font-family:楷体\">。现在希望组合成长度为</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">3</span><span style=\"font-size:11.0pt;font-family:楷体\">的怀表（表链长度是</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">3</span><span style=\"font-size:11.0pt;font-family:楷体\">）。有三种正确的表链组合方式：</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">“LLLVVL”, <span style=\"\"> </span>“LVVLLL”</span><span style=\"font-size:11.0pt;font-family:楷体\">和</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">“LVVVVL”</span><span style=\"font-size:11.0pt;font-family:楷体\">。而且，对于每一种表链的组合方式，表盘都可以接到表链的任一端。</span></p><p class=\"MsoNormal\"><span style=\"font-size:11.0pt;font-family:楷体\">注意怀表的组合方式可能不唯一。每一种表链的组合方式都可以当做是一个由</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">”L”</span><span style=\"font-size:11.0pt;font-family:楷体\">和“</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\">V</span><span style=\"font-size:11.0pt;font-family:楷体\">”</span></p><p class=\"MsoNormal\"><span style=\"font-size:11.0pt;font-family:楷体\">组成的字符串。如果两种表链对应的字符串是不匹配的，</span><span style=\"font-size:11.0pt;font-family:'Times New Roman','serif'\"> </span><span style=\"font-size:11.0pt;font-family:楷体\">那么表链也是不相同的。</span></p>",
    "img": "",
    "inputTip": "标准的输入包含若干组测试数据。每组数据第一行是整数N (0 < N ≤ 40)和K (0 < K ≤ N) 。N 代表表链组件的个数，K代表要组合成的怀表长度(表链组件的个数)。 接着的N+ 1 行描述表盘（第二行）和表链组件的表扣设计。有四种可能输入： “LV”, “LL”, “VV” 和“VL”。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对于每组测试数据，输出一行。 输出“YES”, 如果可能按照要求组合成怀表，并输出可能的组合方式的数目。如果不能，则输出”NO”.",
    "inputExample": "<pre>4 4\nLV\nLL\nLV\nVL\nVL\n4 4\nVL\nLL\nLV\nVL\nVL</pre>",
    "outputExample": "<pre>YES\n2\nNO</pre>",
    "tip": "提示: 本题需要使用 long long 数据类型。",
    "timeLimited": "1000ms",
    "spaceLimited": "32768kB"
  },
  {
    "id": "7591",
    "category": "4.7算法之搜索",
    "title": "7591:反质数",
    "description": "<p>将正整数 x 的约数个数表示为 g(x)。例如，g(1)=1,g(4)=3, g(6)=4。</p><p>如果对于任意正整数y，当 0 < y < x\n 时，x 都满足 g(x) > g(y), 则称 x 为反质数。整数 1，2，4，6 等都是反质数。</p><p>现在任意给定两个正整数 M, N，其中，M < N <= 20000000，按从小到大输出其中<span style=\"white-space: normal;\">（包括 M 和 N）</span>的所有反质数。如果没有，则输出大写的NO。</p>",
    "img": "",
    "inputTip": "一行，包含两个正整数M和N，用单个空格隔开。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "在一行内输出所有反质数，以逗号间隔。如果没有，则输出 NO。",
    "inputExample": "<pre>1 13</pre>",
    "outputExample": "<pre>1,2,4,6,12</pre>",
    "tip": "元培-From Whf",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "8466",
    "category": "4.7算法之搜索",
    "title": "8466:火柴棒等式",
    "description": "<p class=\"MsoNormal\">给你<span>n</span>根火柴棍，你可以拼出多少个形如“<span>A+B=C</span>”的等式？等式中的<span>A</span>、<span>B</span>、<span>C</span>是用火柴棍拼出的整数（若该数非零，则最高位不能是<span>0</span>）。用火柴棍拼数字<span>0-9</span>的拼法如图所示：</p><p class=\"MsoNormal\"><img src=\"http://media.openjudge.cn/images/upload/1435655849.jpg\" width=\"375\" height=\"65\"><br></p><p class=\"MsoNormal\">注意：</p><p class=\"MsoNormal\"><span> 1. </span>加号与等号各自需要两根火柴棍</p><p class=\"MsoNormal\"><span> 2. </span>如果<span>A</span>≠<span>B</span>，则<span>A+B=C</span>与<span>B+A=C</span>视为不同的等式（<span>A</span>、<span>B</span>、<span>C</span>≥<span>0</span>）</p><p class=\"MsoNormal\"><span> 3. n</span>根火柴棍必须全部用上</p>",
    "img": "",
    "inputTip": "输入一个整数n（n≤24）。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出能拼成的不同等式的数目。",
    "inputExample": "<pre>5</pre>",
    "outputExample": "<pre>0</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "8468",
    "category": "4.7算法之搜索",
    "title": "8468:单词序列",
    "description": "<p>给出两个单词（开始单词和结束单词）以及一个词典。找出从开始单词转换到结束单词，所需要的最短转换序列。转换的规则如下：<br></p><p>1、每次只能改变一个字母<br></p><p>2、转换过程中出现的单词(除开始单词和结束单词)必须存在于词典中<br></p><p>例如：<br></p><p>开始单词为：hit<br></p><p>结束单词为：cog<br></p><p>词典为：[hot,dot,dog,lot,log,mot]<br></p><p>那么一种可能的最短变换是： hit -> hot -> dot -> dog -> cog,<br></p><p>所以返回的结果是序列的长度5；<br></p><p>注意：<br></p><p>1、如果不能找到这种变换，则输出0；<br></p><p>2、词典中所有单词长度一样；<br></p><p>3、所有的单词都由小写字母构成；</p><p>4、开始单词和结束单词可以不在词典中。<br></p>",
    "img": "",
    "inputTip": "共两行，第一行为开始单词和结束单词（两个单词不同），以空格分开。第二行为若干的单词（各不相同），以空格分隔开来，表示词典。单词长度不超过5,单词个数不超过30。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出转换序列的长度。",
    "inputExample": "<pre>hit cog\nhot dot dog lot log</pre>",
    "outputExample": "<pre>5</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "1024kB"
  },
  {
    "id": "8470",
    "category": "4.7算法之搜索",
    "title": "8470:DNA",
    "description": "<p>考虑一段DNA单链，上面有N个基因片段。这里的基因片段可重叠（例如AGCTC包含AGC和CTC），不可倒置（例如AGCTC不包含TCG）。要问这样的单链最短长度是多少。<br></p>",
    "img": "",
    "inputTip": "输入的第一行是一个正整数T（不超过13），表示数据组数。每组数据若干行，其中第一行一个正整数N（不超过9），表示基因片段的数目，接下来N行每行一个基因片段，由AGCT四个字母组成，且长度介于1和15之间（含两端）。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "每组数据输出一样，表示最短的单链长度包含这N个基因片段。",
    "inputExample": "<pre>1\n5\nTCGG\nGCAG\nCCGC\nGATC\nATCG</pre>",
    "outputExample": "<pre>11</pre>",
    "tip": "",
    "timeLimited": "6000ms",
    "spaceLimited": "1024kB"
  }
]