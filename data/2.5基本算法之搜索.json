[
  {
    "id": "1159",
    "category": "2.5基本算法之搜索",
    "title": "1159:Maze",
    "description": "Acm, a treasure-explorer, is exploring again. This time he is in a special maze, in which there are some doors (at most 5 doors, represented by 'A', 'B', 'C', 'D', 'E' respectively). In order to find the treasure, Acm may need to open doors. However, to open a door he needs to find all the door's keys (at least one) in the maze first. For example, if there are 3 keys of Door A, to open the door he should find all the 3 keys first (that's three 'a's which denote the keys of 'A' in the maze). Now make a program to tell Acm whether he can find the treasure or not. Notice that Acm can only go up, down, left and right in the maze. ",
    "img": "",
    "inputTip": "The input consists of multiple test cases. The first line of each test case contains two integers M and N (1 < N, M < 20), which denote the size of the maze. The next M lines give the maze layout, with each line containing N characters. A character is one of the following: 'X' (a block of wall, which the explorer cannot enter), '.' (an empty block), 'S' (the start point of Acm), 'G' (the position of treasure), 'A', 'B', 'C', 'D', 'E' (the doors), 'a', 'b', 'c', 'd', 'e' (the keys of the doors). The input is terminated with two 0's. This test case should not be processed. ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each test case, in one line output \"YES\" if Acm can find the treasure, or \"NO\" otherwise. ",
    "inputExample": "<pre>4 4 \nS.X. \na.X. \n..XG \n.... \n3 4 \nS.Xa \n.aXB \nb.AG \n0 0\n</pre>",
    "outputExample": "<pre>YES \nNO\n</pre>",
    "tip": "POJ Monthly,Wang Yijie",
    "timeLimited": "2000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1253",
    "category": "2.5基本算法之搜索",
    "title": "1253:Dungeon Master",
    "description": "You are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You cannot move diagonally and the maze is surrounded by solid rock on all sides. <br><br>Is an escape possible? If yes, how long will it take? <br>",
    "img": "",
    "inputTip": "The input consists of a number of dungeons. Each dungeon description starts with a line containing three integers L, R and C (all limited to 30 in size). L is the number of levels making up the dungeon. R and C are the number of rows and columns making up the plan of each level. Then there will follow L blocks of R lines each containing C characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a '#' and empty cells are represented by a '.'. Your starting position is indicated by 'S' and the exit by the letter 'E'. There's a single blank line after each level. Input is terminated by three zeroes for L, R and C. ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "Each maze generates one line of output. If it is possible to reach the exit, print a line of the form Escaped in x minute(s). where x is replaced by the shortest time it takes to escape. If it is not possible to escape, print the line Trapped! ",
    "inputExample": "<pre>3 4 5\nS....\n.###.\n.##..\n###.#\n\n#####\n#####\n##.##\n##...\n\n#####\n#####\n#.###\n####E\n\n1 3 3\nS##\n#E#\n###\n\n0 0 0\n</pre>",
    "outputExample": "<pre>Escaped in 11 minute(s).\nTrapped!\n</pre>",
    "tip": "Ulm Local 1997",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "131",
    "category": "2.5基本算法之搜索",
    "title": "131:Channel Allocation",
    "description": "When a radio station is broadcasting over a very large area, repeaters are used to retransmit the signal so that every receiver has a strong signal. However, the channels used by each repeater must be carefully chosen so that nearby repeaters do not interfere with one another. This condition is satisfied if adjacent repeaters use different channels.<br><br>Since the radio frequency spectrum is a precious resource, the number of channels required by a given network of repeaters should be minimised. You have to write a program that reads in a description of a repeater network and determines the minimum number of channels required.",
    "img": "",
    "inputTip": "The input consists of a number of maps of repeater networks. Each map begins with a line containing the number of repeaters. This is between 1 and 26, and the repeaters are referred to by consecutive upper-case letters of the alphabet starting with A. For example, ten repeaters would have the names A,B,C,...,I and J. A network with zero repeaters indicates the end of input.Following the number of repeaters is a list of adjacency relationships. Each line has the form:A:BCDHwhich indicates that the repeaters B, C, D and H are adjacent to the repeater A. The first line describes those adjacent to repeater A, the second those adjacent to B, and so on for all of the repeaters. If a repeater is not adjacent to any other, its line has the formA:The repeaters are listed in alphabetical order.Note that the adjacency is a symmetric relationship; if A is adjacent to B, then B is necessarily adjacent to A. Also, since the repeaters lie in a plane, the graph formed by connecting adjacent repeaters does not have any line segments that cross. ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each map (except the final one with no repeaters), print a line containing the minumum number of channels needed so that no adjacent channels interfere. The sample output shows the format of this line. Take care that channels is in the singular form when only one channel is required.",
    "inputExample": "<pre>2\nA:\nB:\n4\nA:BC\nB:ACD\nC:ABD\nD:BC\n4\nA:BCD\nB:ACD\nC:ABD\nD:ABC\n0</pre>",
    "outputExample": "<pre>1 channel needed.\n3 channels needed.\n4 channels needed. </pre>",
    "tip": "Southern African 2001",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1388",
    "category": "2.5基本算法之搜索",
    "title": "1388:Lake Counting",
    "description": "Due to recent rains, water has pooled in various places in Farmer John's field, which is represented by a rectangle of N x M (1 <= N <= 100; 1 <= M <= 100) squares. Each square contains either water ('W') or dry land ('.').  Farmer John would like to figure out how many ponds have formed in his field.  A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors.<br><br>Given a diagram of Farmer John's field, determine how many ponds he has.",
    "img": "",
    "inputTip": "* Line 1: Two space-separated integers: N and M* Lines 2..N+1: M characters per line representing one row of Farmer John's field.  Each character is either 'W' or '.'.  The characters do not have spaces between them.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "* Line 1: The number of ponds in Farmer John's field.",
    "inputExample": "<pre>10 12\nW........WW.\n.WWW.....WWW\n....WW...WW.\n.........WW.\n.........W..\n..W......W..\n.W.W.....WW.\nW.W.W.....W.\n.W.W......W.\n..W.......W.</pre>",
    "outputExample": "<pre>3</pre>",
    "tip": "OUTPUT DETAILS:There are three ponds: one in the upper left, one in the lower left,and one along the right side.",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1490",
    "category": "2.5基本算法之搜索",
    "title": "1490:A Knight's Journey",
    "description": "<img src=\"http://media.openjudge.cn/images/g1490/2488_1.jpg\" align=\"right\"><b>Background</b><br>The knight is getting bored of seeing the same black and white squares again and again and has decided to make a journey<br>around the world. Whenever a knight moves, it is two squares in one direction and one square perpendicular to this. The world of a knight is the chessboard he is living on. Our knight lives on a chessboard that has a smaller area than a regular 8 * 8 board, but it is still rectangular. Can you help this adventurous knight to make travel plans?<br><br><b>Problem</b><br>Find a path such that the knight visits every square once. The knight can start and end on any square of the board.",
    "img": "",
    "inputTip": "The input begins with a positive integer n in the first line. The following lines contain n test cases. Each test case consists of a single line with two positive integers p and q, such that 1 <= p * q <= 26. This represents a p * q chessboard, where p describes how many different square numbers 1, . . . , p exist, q describes how many different square letters exist. These are the first q letters of the Latin alphabet: A, . . .",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "The output for every scenario begins with a line containing \"Scenario #i:\", where i is the number of the scenario starting at 1. Then print a single line containing the lexicographically first path that visits all squares of the chessboard with knight moves followed by an empty line. The path should be given on a single line by concatenating the names of the visited squares. Each square name consists of a capital letter followed by a number.If no such path exist, you should output impossible on a single line.",
    "inputExample": "<pre>3\n1 1\n2 3\n4 3</pre>",
    "outputExample": "<pre>Scenario #1:\nA1\n\nScenario #2:\nimpossible\n\nScenario #3:\nA1B3C1A2B4C2A3B1C3A4B2C4\n</pre>",
    "tip": "TUD Programming Contest 2005, Darmstadt, Germany",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "156",
    "category": "2.5基本算法之搜索",
    "title": "156:LETTERS",
    "description": "A single-player game is played on a rectangular board divided in R rows and C columns. There is a single uppercase letter (A-Z) written in every position in the board.<br>Before the begging of the game there is a figure in the upper-left corner of the board (first row, first column). In every move, a player can move the figure to the one of the adjacent positions (up, down,left or right). Only constraint is that a figure cannot visit a position marked with the same letter twice.<br>The goal of the game is to play as many moves as possible.<br>Write a program that will calculate the maximal number of positions in the board the figure can visit in a single game.",
    "img": "",
    "inputTip": "The first line of the input contains two integers R and C, separated by a single blank character, 1 <= R, S <= 20.The following R lines contain S characters each. Each line represents one row in the board.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "The first and only line of the output should contain the maximal number of position in the board the figure can visit.",
    "inputExample": "<pre>3 6\nHFDFFB\nAJHGDH\nDGAGEH</pre>",
    "outputExample": "<pre>6</pre>",
    "tip": "Croatia OI 2002 Regional Competition - Juniors",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "166",
    "category": "2.5基本算法之搜索",
    "title": "166:The Castle",
    "description": "<center><pre>     1   2   3   4   5   6   7  <br>   #############################<br> 1 #   |   #   |   #   |   |   #<br>   #####---#####---#---#####---#<br> 2 #   #   |   #   #   #   #   #<br>   #---#####---#####---#####---#<br> 3 #   |   |   #   #   #   #   #<br>   #---#########---#####---#---#<br> 4 #   #   |   |   |   |   #   #<br>   #############################<br>(Figure 1)<br><br>#  = Wall   <br>|  = No wall<br>-  = No wall</pre></center><br>Figure 1 shows the map of a castle.Write a program that calculates<br>1. how many rooms the castle has<br>2. how big the largest room is<br>The castle is divided into m * n (m<=50, n<=50) square modules. Each such module can have between zero and four walls. <br>",
    "img": "",
    "inputTip": "Your program is to read from standard input. The first line contains the number of modules in the north-south direction and the number of modules in the east-west direction. In the following lines each module is described by a number (0 <= p <= 15). This number is the sum of: 1 (= wall to the west), 2 (= wall to the north), 4 (= wall to the east), 8 (= wall to the south). Inner walls are defined twice; a wall to the south in module 1,1 is also indicated as a wall to the north in module 2,1. The castle always has at least two rooms.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "Your program is to write to standard output: First the number of rooms, then the area of the largest room (counted in modules).",
    "inputExample": "<pre>4\n7\n11 6 11 6 3 10 6\n7 9 6 13 5 15 5\n1 10 12 7 13 7 5\n13 11 10 8 10 12 13</pre>",
    "outputExample": "<pre>5\n9</pre>",
    "tip": "IOI 1994",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1700",
    "category": "2.5基本算法之搜索",
    "title": "1700:八皇后问题",
    "description": "在国际象棋棋盘上放置八个皇后，要求每两个皇后之间不能直接吃掉对方。",
    "img": "",
    "inputTip": "无输入。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "按给定顺序和格式输出所有八皇后问题的解（见Sample Output）。",
    "inputExample": "<pre></pre>",
    "outputExample": "<pre>No. 1\n1 0 0 0 0 0 0 0 \n0 0 0 0 0 0 1 0 \n0 0 0 0 1 0 0 0 \n0 0 0 0 0 0 0 1 \n0 1 0 0 0 0 0 0 \n0 0 0 1 0 0 0 0 \n0 0 0 0 0 1 0 0 \n0 0 1 0 0 0 0 0 \nNo. 2\n1 0 0 0 0 0 0 0 \n0 0 0 0 0 0 1 0 \n0 0 0 1 0 0 0 0 \n0 0 0 0 0 1 0 0 \n0 0 0 0 0 0 0 1 \n0 1 0 0 0 0 0 0 \n0 0 0 0 1 0 0 0 \n0 0 1 0 0 0 0 0 \nNo. 3\n1 0 0 0 0 0 0 0 \n0 0 0 0 0 1 0 0 \n0 0 0 0 0 0 0 1 \n0 0 1 0 0 0 0 0 \n0 0 0 0 0 0 1 0 \n0 0 0 1 0 0 0 0 \n0 1 0 0 0 0 0 0 \n0 0 0 0 1 0 0 0 \nNo. 4\n1 0 0 0 0 0 0 0 \n0 0 0 0 1 0 0 0 \n0 0 0 0 0 0 0 1 \n0 0 0 0 0 1 0 0 \n0 0 1 0 0 0 0 0 \n0 0 0 0 0 0 1 0 \n0 1 0 0 0 0 0 0 \n0 0 0 1 0 0 0 0 \nNo. 5\n0 0 0 0 0 1 0 0 \n1 0 0 0 0 0 0 0 \n0 0 0 0 1 0 0 0 \n0 1 0 0 0 0 0 0 \n0 0 0 0 0 0 0 1 \n0 0 1 0 0 0 0 0 \n0 0 0 0 0 0 1 0 \n0 0 0 1 0 0 0 0 \nNo. 6\n0 0 0 1 0 0 0 0 \n1 0 0 0 0 0 0 0 \n0 0 0 0 1 0 0 0 \n0 0 0 0 0 0 0 1 \n0 1 0 0 0 0 0 0 \n0 0 0 0 0 0 1 0 \n0 0 1 0 0 0 0 0 \n0 0 0 0 0 1 0 0 \nNo. 7\n0 0 0 0 1 0 0 0 \n1 0 0 0 0 0 0 0 \n0 0 0 0 0 0 0 1 \n0 0 0 1 0 0 0 0 \n0 1 0 0 0 0 0 0 \n0 0 0 0 0 0 1 0 \n0 0 1 0 0 0 0 0 \n0 0 0 0 0 1 0 0 \nNo. 8\n0 0 1 0 0 0 0 0 \n1 0 0 0 0 0 0 0 \n0 0 0 0 0 0 1 0 \n0 0 0 0 1 0 0 0 \n0 0 0 0 0 0 0 1 \n0 1 0 0 0 0 0 0 \n0 0 0 1 0 0 0 0 \n0 0 0 0 0 1 0 0 \nNo. 9\n0 0 0 0 1 0 0 0 \n1 0 0 0 0 0 0 0 \n0 0 0 1 0 0 0 0 \n0 0 0 0 0 1 0 0 \n0 0 0 0 0 0 0 1 \n0 1 0 0 0 0 0 0 \n0 0 0 0 0 0 1 0 \n0 0 1 0 0 0 0 0 \n...以下省略</pre>",
    "tip": "此题可使用函数递归调用的方法求解。",
    "timeLimited": "10000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1756",
    "category": "2.5基本算法之搜索",
    "title": "1756:八皇后",
    "description": "会下国际象棋的人都很清楚：皇后可以在横、竖、斜线上不限步数地吃掉其他棋子。如何将8个皇后放在棋盘上（有8 * 8个方格），使它们谁也不能被吃掉！这就是著名的八皇后问题。 <br>对于某个满足要求的8皇后的摆放方法，定义一个皇后串a与之对应，即a=b<sub>1</sub>b<sub>2</sub>...b<sub>8</sub>，其中b<sub>i</sub>为相应摆法中第i行皇后所处的列数。已经知道8皇后问题一共有92组解（即92个不同的皇后串）。<br>给出一个数b，要求输出第b个串。串的比较是这样的：皇后串x置于皇后串y之前，当且仅当将x视为整数时比y小。<br>",
    "img": "",
    "inputTip": "第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数b(1 <= b <= 92)",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出有n行，每行输出对应一个输入。输出应是一个正整数，是对应于b的皇后串。",
    "inputExample": "<pre>2\n1\n92\n</pre>",
    "outputExample": "<pre>15863724\n84136275\n</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1789",
    "category": "2.5基本算法之搜索",
    "title": "1789:算24",
    "description": "给出4个小于10个正整数，你可以使用加减乘除4种运算以及括号把这4个数连接起来得到一个表达式。现在的问题是，是否存在一种方式使得得到的表达式的结果等于24。<br><br>这里加减乘除以及括号的运算结果和运算的优先级跟我们平常的定义一致（这里的除法定义是实数除法）。<br><br>比如，对于5，5，5，1，我们知道5 * (5 – 1 / 5) = 24，因此可以得到24。又比如，对于1，1，4，2，我们怎么都不能得到24。<br>",
    "img": "",
    "inputTip": "输入数据包括多行，每行给出一组测试数据，包括4个小于10个正整数。最后一组测试数据中包括4个0，表示输入的结束，这组数据不用处理。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对于每一组测试数据，输出一行，如果可以得到24，输出“YES”；否则，输出“NO”。",
    "inputExample": "<pre>5 5 5 1\n1 1 4 2\n0 0 0 0\n</pre>",
    "outputExample": "<pre>YES\nNO\n</pre>",
    "tip": "",
    "timeLimited": "3000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1792",
    "category": "2.5基本算法之搜索",
    "title": "1792:迷宫",
    "description": "一天Extense在森林里探险的时候不小心走入了一个迷宫，迷宫可以看成是由n * n的格点组成，每个格点只有2种状态，.和#，前者表示可以通行后者表示不能通行。同时当Extense处在某个格点时，他只能移动到东南西北(或者说上下左右)四个方向之一的相邻格点上，Extense想要从点A走到点B，问在不走出迷宫的情况下能不能办到。如果起点或者终点有一个不能通行(为#)，则看成无法办到。",
    "img": "",
    "inputTip": "第1行是测试数据的组数k，后面跟着k组输入。每组测试数据的第1行是一个正整数n (1 <= n <= 100)，表示迷宫的规模是n * n的。接下来是一个n * n的矩阵，矩阵中的元素为.或者#。再接下来一行是4个整数ha, la, hb, lb，描述A处在第ha行, 第la列，B处在第hb行, 第lb列。注意到ha, la, hb, lb全部是从0开始计数的。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "k行，每行输出对应一个输入。能办到则输出“YES”，否则输出“NO”。",
    "inputExample": "<pre>2\n3\n.##\n..#\n#..\n0 0 2 2\n5\n.....\n###.#\n..#..\n###..\n...#.\n0 0 4 0\n</pre>",
    "outputExample": "<pre>YES\nNO\n</pre>",
    "tip": "",
    "timeLimited": "3000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1804",
    "category": "2.5基本算法之搜索",
    "title": "1804:小游戏",
    "description": "一天早上，你起床的时候想：“我编程序这么牛，为什么不能靠这个赚点小钱呢？”因此你决定编写一个小游戏。<br><br>游戏在一个分割成w * h个正方格子的矩形板上进行。如图所示，每个正方格子上可以有一张游戏卡片，当然也可以没有。<br><br>当下面的情况满足时，我们认为两个游戏卡片之间有一条路径相连：<br><br>路径只包含水平或者竖直的直线段。路径不能穿过别的游戏卡片。但是允许路径临时的离开矩形板。下面是一个例子： <br><br><center><img src=\"http://media.openjudge.cn/images/1101/1101_1.jpg\"></center><br><br>这里在 (1, 3)和 (4, 4)处的游戏卡片是可以相连的。而在 (2, 3) 和 (3, 4) 处的游戏卡是不相连的，因为连接他们的每条路径都必须要穿过别的游戏卡片。<br><br>你现在要在小游戏里面判断是否存在一条满足题意的路径能连接给定的两个游戏卡片。<br>",
    "img": "",
    "inputTip": "输入包括多组数据。一个矩形板对应一组数据。每组数据包括的第一行包括两个整数w和h (1 <= w, h <= 75)，分别表示矩形板的宽度和长度。下面的h行，每行包括w个字符，表示矩形板上的游戏卡片分布情况。使用‘X’表示这个地方有一个游戏卡片；使用空格表示这个地方没有游戏卡片。之后的若干行上每行上包括4个整数x1, y1, x2, y2 (1 <= x1, x2 <= w, 1 <= y1, y2 <= h)。给出两个卡片在矩形板上的位置（注意：矩形板左上角的坐标是(1, 1)）。输入保证这两个游戏卡片所处的位置是不相同的。如果一行上有4个0，表示这组测试数据的结束。如果一行上给出w = h = 0，那么表示所有的输入结束了。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对每一个矩形板，输出一行“Board #n:”，这里n是输入数据的编号。然后对每一组需要测试的游戏卡片输出一行。这一行的开头是“Pair m: ”，这里m是测试卡片的编号（对每个矩形板，编号都从1开始）。接下来，如果可以相连，找到连接这两个卡片的所有路径中包括线段数最少的路径，输出“k segments.”，这里k是找到的最优路径中包括的线段的数目；如果不能相连，输出“impossible.”。每组数据之后输出一个空行。",
    "inputExample": "<pre>5 4\nXXXXX\nX   X\nXXX X\n XXX \n2 3 5 3\n1 3 4 4\n2 3 3 4\n0 0 0 0\n0 0\n</pre>",
    "outputExample": "<pre>Board #1:\nPair 1: 4 segments.\nPair 2: 3 segments.\nPair 3: impossible.\n</pre>",
    "tip": "翻译自Mid-Central European Regional Contest 1999的试题",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1805",
    "category": "2.5基本算法之搜索",
    "title": "1805:碎纸机",
    "description": "你现在负责设计一种新式的碎纸机。一般的碎纸机会把纸切成小片，变得难以阅读。而你设计的新式的碎纸机有以下的特点：<br><br>1.每次切割之前，先要给定碎纸机一个目标数，而且在每张被送入碎纸机的纸片上也需要包含一个数。<br>2.碎纸机切出的每个纸片上都包括一个数。<br>3.要求切出的每个纸片上的数的和要不大于目标数而且与目标数最接近。<br><br>举一个例子，如下图，假设目标数是50，输入纸片上的数是12346。碎纸机会把纸片切成4块，分别包含1，2，34和6。这样这些数的和是43 (= 1 + 2 + 34 + 6)，这是所有的分割方式中，不超过50，而又最接近50的分割方式。又比如，分割成1，23，4和6是不正确的，因为这样的总和是34 (= 1 + 23 + 4 + 6)，比刚才得到的结果43小。分割成12，34和6也是不正确的，因为这时的总和是52 (= 12 + 34 + 6)，超过了50。<br><center><img src=\"http://media.openjudge.cn/images/1416_1.jpg\"></center><br>还有三个特别的规则：<br>1.如果目标数和输入纸片上的数相同，那么纸片不进行切割。<br>2.如果不论怎样切割，分割得到的纸片上数的和都大于目标数，那么打印机显示错误信息。<br>3.如果有多种不同的切割方式可以得到相同的最优结果。那么打印机显示拒绝服务信息。比如，如果目标数是15，输入纸片上的数是111，那么有两种不同的方式可以得到最优解，分别是切割成1和11或者切割成11和1，在这种情况下，打印机会显示拒绝服务信息。<br><br><br>为了设计这样的一个碎纸机，你需要先写一个简单的程序模拟这个打印机的工作。给定两个数，第一个是目标数，第二个是输入纸片上的数，你需要给出碎纸机对纸片的分割方式。",
    "img": "",
    "inputTip": "输入包括多组数据，每一组包括一行。每行上包括两个正整数，分别表示目标数和输入纸片上的数。已知输入保证：两个数都不会以0开头，而且两个数至多都只包含6个数字。输入的最后一行包括两个0，这行表示输入的结束。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对每一组输入数据，输出相应的输出。有三种不同的输出结果：sum part1 part2 ... rejected error 第一种结果表示：1.每一个partj是切割得到的纸片上的一个数。partj的顺序和输入纸片上原始数中数字出现的次序一致。2.sum是切割得到的纸片上的数的和，也就是说：sum = part1 + part2 +...第一种结果中相邻的两个数之间用一个空格隔开。如果不论怎样切割，分割得到的纸片上数的和都大于目标数，那么打印“error”。如果有多种不同的切割方式可以得到相同的最优结果，那么打印“rejected”。 ",
    "inputExample": "<pre>50 12346\n376 144139\n927438 927438\n18 3312\n9 3142\n25 1299\n111 33333\n103 862150\n6 1104\n0 0\n</pre>",
    "outputExample": "<pre>43 1 2 34 6\n283 144 139\n927438 927438\n18 3 3 12\nerror\n21 1 2 9 9\nrejected\n103 86 2 15 0\nrejected\n</pre>",
    "tip": "翻译自Japan 2002 Kanazawa的试题",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1817",
    "category": "2.5基本算法之搜索",
    "title": "1817:城堡问题",
    "description": "<pre><br>     1   2   3   4   5   6   7  <br>   #############################<br> 1 #   |   #   |   #   |   |   #<br>   #####---#####---#---#####---#<br> 2 #   #   |   #   #   #   #   #<br>   #---#####---#####---#####---#<br> 3 #   |   |   #   #   #   #   #<br>   #---#########---#####---#---#<br> 4 #   #   |   |   |   |   #   #<br>   #############################<br>           (图 1)<br><br>   #  = Wall   <br>   |  = No wall<br>   -  = No wall<br></pre><br>图1是一个城堡的地形图。请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大。城堡被分割成mn(m≤50，n≤50)个方块，每个方块可以有0~4面墙。<br>",
    "img": "",
    "inputTip": "程序从标准输入设备读入数据。第一行是两个整数，分别是南北向、东西向的方块数。在接下来的输入行里，每个方块用一个数字(0≤p≤50)描述。用一个数字表示方块周围的墙，1表示西墙，2表示北墙，4表示东墙，8表示南墙。每个方块用代表其周围墙的数字之和表示。城堡的内墙被计算两次，方块(1,1)的南墙同时也是方块(2,1)的北墙。输入的数据保证城堡至少有两个房间。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "城堡的房间数、城堡中最大房间所包括的方块数。结果显示在标准输出设备上。",
    "inputExample": "<pre>4 \n7 \n11 6 11 6 3 10 6 \n7 9 6 13 5 15 5 \n1 10 12 7 13 7 5 \n13 11 10 8 10 12 13 </pre>",
    "outputExample": "<pre>5\n9\n</pre>",
    "tip": "1164",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1818",
    "category": "2.5基本算法之搜索",
    "title": "1818:红与黑",
    "description": "有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。你站在其中一块黑色的瓷砖上，只能向相邻的黑色瓷砖移动。请写一个程序，计算你总共能够到达多少块黑色的瓷砖。",
    "img": "",
    "inputTip": "包括多个数据集合。每个数据集合的第一行是两个整数W和H，分别表示x方向和y方向瓷砖的数量。W和H都不超过20。在接下来的H行中，每行包括W个字符。每个字符表示一块瓷砖的颜色，规则如下  1）‘.’：黑色的瓷砖；  2）‘#’：白色的瓷砖；  3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。当在一行中读入的是两个零时，表示输入结束。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。",
    "inputExample": "<pre>6 9 \n....#. \n.....# \n...... \n...... \n...... \n...... \n...... \n#@...# \n.#..#. \n0 0\n</pre>",
    "outputExample": "<pre>45\n</pre>",
    "tip": "1979",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1998",
    "category": "2.5基本算法之搜索",
    "title": "1998:寻找Nemo",
    "description": "Nemo 是个顽皮的小孩. 一天他一个人跑到深海里去玩. 可是他迷路了. 于是他向父亲 Marlin 发送了求救信号.通过查找地图 Marlin 发现那片海像一个有着墙和门的迷宫.所有的墙都是平行于 X 轴或 Y 轴的. 墙的厚度可以忽略不计.所有的门都开在墙上并且长度为1. Marlin 只能穿过有门的墙. 因为穿过墙是有危险的 (门旁可能会藏有巨毒的水母), Marlin 想穿过尽量少的门找到 Nemo.<br>图-1 显示了一个迷宫的样例及 Marlin 找到 Nemo的路线.<br><center><img src=\"http://media.openjudge.cn/images/2997_1.jpg\"></center><br>我们假设 Marlin 的初始位置在 (0, 0). 给定 Nemo 的位置和墙及门的位置情况,请你写一个程序计算 Marlin 要找到 Nemo最少要穿过多少道门.",
    "img": "",
    "inputTip": "输入有多组测试数据. 每组测试数据以两个非零整数 M 和 N 开始. M 表示迷宫中墙的数目, N 表示门的数目. 接下来有 M 行, 每行包含四个整数描述一堵墙,其格式如下: x y d t (x, y) 表示墙的左下角, d 是墙的方向 -- 0 表示它与 X-轴平行, 1 表示它与 Y-轴平行, t 表示墙的长度. 墙的两个顶点坐标在[1,199]. 接下来有 N 行,用来描述门的情况: x y d x, y, d 与门的描述含义相同. 因为门的长度是 1, t 被省略了. 每组测试数据的最后一行包含两个正的浮点数: f1 f2 (f1, f2) 给出了 Nemo 的位置. 它不在墙和门上.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对于每组测试数据，输出一行，该行包含 Marlin 找到 Nemo需要穿过的最少的门数. 如果他不可能找到 Nemo, 输出 -1.",
    "inputExample": "<pre>8 9\n1 1 1 3\n2 1 1 3\n3 1 1 3\n4 1 1 3\n1 1 0 3\n1 2 0 3\n1 3 0 3\n1 4 0 3\n2 1 1\n2 2 1\n2 3 1\n3 1 1\n3 2 1\n3 3 1\n1 2 0\n3 3 0\n4 3 1\n1.5 1.5\n4 0\n1 1 0 1\n1 1 1 1\n2 1 1 1\n1 2 0 1\n1.5 1.7\n-1 -1</pre>",
    "outputExample": "<pre>5\n-1</pre>",
    "tip": "Beijing 2004  English 2049",
    "timeLimited": "2000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "200",
    "category": "2.5基本算法之搜索",
    "title": "200:Solitaire",
    "description": "Solitaire is a game played on a chessboard 8x8. The rows and columns of the chessboard are numbered from 1 to 8, from the top to the bottom and from left to right respectively. <br><br>There are four identical pieces on the board. In one move it is allowed to: <br><ul><br><li>move a piece to an empty neighboring field (up, down, left or right), <br></li><li>jump over one neighboring piece to an empty field (up, down, left or right). <br></li></ul><br><center><img src=\"http://media.openjudge.cn/images/g200/1198_1.jpg\"></center><br>There are 4 moves allowed for each piece in the configuration shown above. As an example let's consider a piece placed in the row 4, column 4. It can be moved one row up, two rows down, one column left or two columns right. <br>Write a program that: <br><ul><br><li>reads two chessboard configurations from the standard input, <br></li><li>verifies whether the second one is reachable from the first one in at most 8 moves, <br></li><li>writes the result to the standard output. <br></li></ul>",
    "img": "",
    "inputTip": "Each of two input lines contains 8 integers a1, a2, ..., a8 separated by single spaces and describes one configuration of pieces on the chessboard. Integers a2j-1 and a2j (1 <= j <= 4) describe the position of one piece -- the row number and the column number respectively.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "The output should contain one word YES if a configuration described in the second input line is reachable from the configuration described in the first input line in at most 8 moves, or one word NO otherwise.",
    "inputExample": "<pre>4 4 4 5 5 4 6 5\n2 4 3 3 3 6 4 6</pre>",
    "outputExample": "<pre>YES</pre>",
    "tip": "Southwestern Europe 2002",
    "timeLimited": "5000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "2152",
    "category": "2.5基本算法之搜索",
    "title": "2152:Pots",
    "description": "<p>You are given two pots, having the volume of <b>A</b> and <b>B</b> liters respectively. The following operations can be performed:</p><ol><li>FILL(i)        fill the pot <b>i</b> (1 ≤ <b>i </b>≤ 2) from the tap;</li><li>DROP(i)      empty the pot <b>i</b> to the drain;</li><li>POUR(i,j)    pour from pot <b>i</b> to pot <b>j</b>; after this operation either the pot <b>j</b> is full (and there may be some water left in the pot <b>i</b>), or the pot <b>i</b> is empty (and all its contents have been moved to the pot <b>j</b>).</li></ol><p>Write a program to find the shortest possible sequence of these operations that will yield exactly <b>C</b> liters of water in one of the pots.</p>",
    "img": "",
    "inputTip": "On the first and only line are the numbers A, B, and C. These are all integers in the range from 1 to 100 and C≤max(A,B).",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "The first line of the output must contain the length of the sequence of operations K. The following K lines must each describe one operation. If there are several sequences of minimal length, output any one of them. If the desired result can’t be achieved, the first and only line of the file must contain the word ‘impossible’.",
    "inputExample": "<pre>3 5 4</pre>",
    "outputExample": "<pre>6\nFILL(2)\nPOUR(2,1)\nDROP(1)\nPOUR(2,1)\nFILL(2)\nPOUR(2,1)</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2727",
    "category": "2.5基本算法之搜索",
    "title": "2727:仙岛求药",
    "description": "少年李逍遥的婶婶病了，王小虎介绍他去一趟仙灵岛，向仙女姐姐要仙丹救婶婶。叛逆但孝顺的李逍遥闯进了仙灵岛，克服了千险万难来到岛的中心，发现仙药摆在了迷阵的深处。迷阵由M×N个方格组成，有的方格内有可以瞬秒李逍遥的怪物，而有的方格内则是安全。现在李逍遥想尽快找到仙药，显然他应避开有怪物的方格，并经过最少的方格，而且那里会有神秘人物等待着他。现在要求你来帮助他实现这个目标。<br>下图 显示了一个迷阵的样例及李逍遥找到仙药的路线.<br><img src=\"http://media.openjudge.cn/images/3727_1.PNG\"><br>",
    "img": "",
    "inputTip": "输入有多组测试数据. 每组测试数据以两个非零整数 M 和 N 开始，两者均不大于20。M 表示迷阵行数, N 表示迷阵列数。接下来有 M 行, 每行包含N个字符,不同字符分别代表不同含义: 1)\t‘@’：少年李逍遥所在的位置；2)\t‘.’：可以安全通行的方格；3)\t‘#’：有怪物的方格；4)\t‘*’：仙药所在位置。当在一行中读入的是两个零时，表示输入结束。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对于每组测试数据，分别输出一行，该行包含李逍遥找到仙药需要穿过的最少的方格数目(计数包括初始位置的方块)。如果他不可能找到仙药, 则输出 -1。",
    "inputExample": "<pre>8 8\n.@##...#\n#....#.#\n#.#.##..\n..#.###.\n#.#...#.\n..###.#.\n...#.*..\n.#...###\n6 5\n.*.#.\n.#...\n..##.\n.....\n.#...\n....@\n9 6\n.#..#. \n.#.*.# \n.####. \n..#... \n..#... \n..#... \n..#... \n#.@.## \n.#..#. \n0 0\n</pre>",
    "outputExample": "<pre>10\n8\n-1\n</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2753",
    "category": "2.5基本算法之搜索",
    "title": "2753:走迷宫",
    "description": "一个迷宫由R行C列格子组成，有的格子里有障碍物，不能走；有的格子是空地，可以走。<br>给定一个迷宫，求从左上角走到右下角最少需要走多少步(数据保证一定能走到)。只能在水平方向或垂直方向走，不能斜着走。<br>",
    "img": "",
    "inputTip": "第一行是两个整数，Ｒ和Ｃ，代表迷宫的长和宽。（ 1<= R，C <= 40)接下来是Ｒ行，每行Ｃ个字符，代表整个迷宫。空地格子用'.'表示，有障碍物的格子用'#'表示。迷宫左上角和右下角都是'.'。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出从左上角走到右下角至少要经过多少步（即至少要经过多少个空地格子）。计算步数要包括起点和终点。",
    "inputExample": "<pre>5 5\n..###\n#....\n#.#.#\n#.#.#\n#.#..\n</pre>",
    "outputExample": "<pre>9</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2971",
    "category": "2.5基本算法之搜索",
    "title": "2971:抓住那头牛",
    "description": "<p><span style=\"color: rgb(0, 0, 0);font-family: Simsun;font-size: medium;background-color: rgb(255, 255, 255)\">农夫知道一头牛的位置，想要抓住它。农夫和牛都位于数轴上，农夫起始位于点N(0<=N<=100000)，牛位于点K(0<=K<=100000)。农夫有两种移动方式：</span></p><div style=\"color: rgb(0, 0, 0); font-family: Simsun; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);\">1、从X移动到X-1或X+1，每次移动花费一分钟</div><div style=\"color: rgb(0, 0, 0); font-family: Simsun; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);\">2、从X移动到2*X，每次移动花费一分钟</div><div style=\"color: rgb(0, 0, 0); font-family: Simsun; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);\"><br></div><div style=\"color: rgb(0, 0, 0); font-family: Simsun; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);\">假设牛没有意识到农夫的行动，站在原地不动。农夫最少要花多少时间才能抓住牛？</div><p><br></p>",
    "img": "",
    "inputTip": "两个整数，N和K",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个整数，农夫抓到牛所要花费的最小分钟数",
    "inputExample": "<pre>5 17</pre>",
    "outputExample": "<pre>4</pre>",
    "tip": "",
    "timeLimited": "2000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2990",
    "category": "2.5基本算法之搜索",
    "title": "2990:符号三角形",
    "description": "符号三角形的第1行有n个由“+”和”-“组成的符号 ，以后每行符号比上行少1个，2个同号下面是”+“，2个异号下面是”-“ 。计算有多少个不同的符号三角形，使其所含”+“ 和”-“ 的个数相同。<br><br>n=7时的1个符号三角形如下:<br><code>+ + - + - + +<br> + - - - - +<br>  - + + + -<br>   - + + -<br>    - + -<br>     - -<br>      +</code>",
    "img": "",
    "inputTip": "每行1个正整数n<=24,n=0退出.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "n和符号三角形的个数.",
    "inputExample": "<pre>15\n16\n19\n20\n0</pre>",
    "outputExample": "<pre>15 1896\n16 5160\n19 32757\n20 59984</pre>",
    "tip": ".",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "323",
    "category": "2.5基本算法之搜索",
    "title": "323:棋盘问题",
    "description": "在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。",
    "img": "",
    "inputTip": "输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n <= 8 ,  k <= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C<2^31）。",
    "inputExample": "<pre>2 1\n#.\n.#\n4 4\n...#\n..#.\n.#..\n#...\n-1 -1\n</pre>",
    "outputExample": "<pre>2\n1\n</pre>",
    "tip": "蔡错@pku",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "4980",
    "category": "2.5基本算法之搜索",
    "title": "4980:拯救行动",
    "description": "<p>公主被恶人抓走，被关押在牢房的某个地方。牢房用N*M (N, M <= 200)的矩阵来表示。矩阵中的每项可以代表道路（@）、墙壁（#）、和守卫（x）。 <br>英勇的骑士（r）决定孤身一人去拯救公主（a）。我们假设拯救成功的表示是“骑士到达了公主所在的位置”。由于在通往公主所在位置的道路中可能遇到守卫，骑士一旦遇到守卫，必须杀死守卫才能继续前进。 <br>现假设骑士可以向上、下、左、右四个方向移动，每移动一个位置需要1个单位时间，杀死一个守卫需要花费额外的1个单位时间。同时假设骑士足够强壮，有能力杀死所有的守卫。</p><p>给定牢房矩阵，公主、骑士和守卫在矩阵中的位置，请你计算拯救行动成功需要花费最短时间。<br></p>",
    "img": "",
    "inputTip": "第一行为一个整数S，表示输入的数据的组数（多组输入）随后有S组数据，每组数据按如下格式输入     1、两个整数代表N和M, (N, M <= 200).      2、随后N行，每行有M个字符。\"@\"代表道路，\"a\"代表公主，\"r\"代表骑士，\"x\"代表守卫, \"#\"代表墙壁。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "如果拯救行动成功，输出一个整数，表示行动的最短时间。如果不可能成功，输出\"Impossible\"",
    "inputExample": "<pre>2\n7 8\n#@#####@\n#@a#@@r@\n#@@#x@@@\n@@#@@#@#\n#@@@##@@\n@#@@@@@@\n@@@@@@@@ \n13 40\n@x@@##x@#x@x#xxxx##@#x@x@@#x#@#x#@@x@#@x\nxx###x@x#@@##xx@@@#@x@@#x@xxx@@#x@#x@@x@\n#@x#@x#x#@@##@@x#@xx#xxx@@x##@@@#@x@@x@x\n@##x@@@x#xx#@@#xxxx#@@x@x@#@x@@@x@#@#x@#\n@#xxxxx##@@x##x@xxx@@#x@x####@@@x#x##@#@\n#xxx#@#x##xxxx@@#xx@@@x@xxx#@#xxx@x#####\n#x@xxxx#@x@@@@##@x#xx#xxx@#xx#@#####x#@x\nxx##@#@x##x##x#@x#@a#xx@##@#@##xx@#@@x@x\nx#x#@x@#x#@##@xrx@x#xxxx@##x##xx#@#x@xx@\n#x@@#@###x##x@x#@@#@@x@x@@xx@@@@##@@x@@x\nx#xx@x###@xxx#@#x#@@###@#@##@x#@x@#@@#@@\n#@#x@x#x#x###@x@@xxx####x@x##@x####xx#@x\n#x#@x#x######@@#x@#xxxx#xx@@@#xx#x#####@</pre>",
    "outputExample": "<pre>13\n7</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "6044",
    "category": "2.5基本算法之搜索",
    "title": "6044:鸣人和佐助",
    "description": "<p class=\"MsoNormal\"><span style=\"font-size:12.0pt;font-family:宋体\">佐助被大蛇丸诱骗走了，鸣人在多少时间内能追上他呢？</span></p><p class=\"MsoNormal\"><img src=\"http://media.openjudge.cn/images/upload/1372385324.jpg\" height=\"375\" width=\"500\"><br></p><p><span style=\"font-size:12.0pt;font-family:宋体\">已知一张地图（以二维矩阵的形式表示）以及佐助和鸣人的位置。地图上的每个位置都可以走到，只不过有些位置上有大蛇丸的手下，需要先打败大蛇丸的手下才能到这些位置。鸣人有一定数量的查克拉，每一个单位的查克拉可以打败一个大蛇丸的手下。假设鸣人可以往上下左右四个方向移动，每移动一个距离需要花费</span><span style=\"font-size:12.0pt;font-family:'Calibri','sans-serif'\">1</span><span style=\"font-size:12.0pt;font-family:宋体\">个单位时间，打败大蛇丸的手下不需要时间。如果鸣人查克拉消耗完了，则只可以走到没有大蛇丸手下的位置，不可以再移动到有大蛇丸手下的位置。佐助在此期间不移动，大蛇丸的手下也不移动。请问，鸣人要追上佐助最少需要花费多少时间？</span><br></p>",
    "img": "",
    "inputTip": "输入的第一行包含三个整数：M，N，T。代表M行N列的地图和鸣人初始的查克拉数量T。0 < M,N < 200，0 ≤ T < 10后面是M行N列的地图，其中@代表鸣人，+代表佐助。*代表通路，#代表大蛇丸的手下。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出包含一个整数R，代表鸣人追上佐助最少需要花费的时间。如果鸣人无法追上佐助，则输出-1。",
    "inputExample": "<pre>样例输入1\n4 4 1\n#@##\n**##\n###+\n****\n\n样例输入2\n4 4 2\n#@##\n**##\n###+\n****</pre>",
    "outputExample": "<pre>样例输出1\n6\n\n样例输出2\n4</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "6264",
    "category": "2.5基本算法之搜索",
    "title": "6264:走出迷宫",
    "description": "<p>当你站在一个迷宫里的时候，往往会被错综复杂的道路弄得失去方向感，如果你能得到迷宫地图，事情就会变得非常简单。\n<br>假设你已经得到了一个n*m的迷宫的图纸，请你找出从起点到出口的最短路。<br></p>",
    "img": "",
    "inputTip": "第一行是两个整数n和m(1<=n,m<=100)，表示迷宫的行数和列数。接下来n行，每行一个长为m的字符串，表示整个迷宫的布局。字符'.'表示空地，'#'表示墙，'S'表示起点,'T'表示出口。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出从起点到出口最少需要走的步数。",
    "inputExample": "<pre>3 3\nS#T\n.#.\n...</pre>",
    "outputExample": "<pre>6</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "6266",
    "category": "2.5基本算法之搜索",
    "title": "6266:取石子游戏",
    "description": "<p>有两堆石子,两个人轮流去取.每次取的时候,只能从较多的那堆石子里取,并且取的数目必须是较少的那堆石子数目的整数倍.最后谁能够把一堆石子取空谁就算赢.\n<br>比如初始的时候两堆石子的数目是25和7\n<br></p><table border=\"1\"><tbody><tr><td>25 7</td><td>--></td><td>11 7</td><td>--></td><td>4 7</td><td>--></td><td>4 3</td><td>--></td><td>1 3</td><td>--></td><td>1 0</td></tr><tr><td> </td><td>选手1取</td><td> </td><td>选手2取</td><td> </td><td>选手1取</td><td> </td><td>选手2取</td><td> </td><td>选手1取</td></tr></tbody></table><br>最后选手1（先取的）获胜，在取的过程中选手2都只有唯一的一种取法。\n<br>给定初始时石子的数目，如果两个人都采取最优策略，请问先手能否获胜。<p><br></p>",
    "img": "",
    "inputTip": "输入包含多数数据。每组数据一行，包含两个正整数a和b，表示初始时石子的数目。输入以两个0表示结束。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "如果先手胜，输出\"win\"，否则输出\"lose\"",
    "inputExample": "<pre>34 12\n15 24\n0 0</pre>",
    "outputExample": "<pre>win\nlose</pre>",
    "tip": "假设石子数目为(a,b)且a >= b,如果[a/b] >= 2则先手必胜,如果[a/b]<2,那么先手只有唯一的一种取法.[a/b]表示a除以b取整后的值.",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "666",
    "category": "2.5基本算法之搜索",
    "title": "666:放苹果",
    "description": "把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。",
    "img": "",
    "inputTip": "第一行是测试数据的数目t（0 <= t <= 20）。以下每行均包含二个整数M和N，以空格分开。1<=M，N<=10。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对输入的每组数据M和N，用一行输出相应的K。",
    "inputExample": "<pre>1\n7 3\n</pre>",
    "outputExample": "<pre>8</pre>",
    "tip": "lwx@POJ",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7084",
    "category": "2.5基本算法之搜索",
    "title": "7084:迷宫问题",
    "description": "<p><span style=\"font-family: 'Times New Roman', Times, serif\">定义一个二维数组： </span><br style=\"font-family: 'Times New Roman', Times, serif; white-space: normal;\"></p><pre style=\"overflow-x: auto;\">int maze[5][5] = {\n\n0, 1, 0, 0, 0,\n\n0, 1, 0, 1, 0,\n\n0, 0, 0, 0, 0,\n\n0, 1, 1, 1, 0,\n\n0, 0, 0, 1, 0,\n\n};</pre><p><br style=\"font-family: 'Times New Roman', Times, serif; white-space: normal;\"><span style=\"font-family: 'Times New Roman', Times, serif\">它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。</span></p><p><br></p>",
    "img": "",
    "inputTip": "一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "左上角到右下角的最短路径，格式如样例所示。",
    "inputExample": "<pre>0 1 0 0 0\n0 1 0 1 0\n0 0 0 0 0\n0 1 1 1 0\n0 0 0 1 0</pre>",
    "outputExample": "<pre>(0, 0)\n(1, 0)\n(2, 0)\n(2, 1)\n(2, 2)\n(2, 3)\n(2, 4)\n(3, 4)\n(4, 4)</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7218",
    "category": "2.5基本算法之搜索",
    "title": "7218:献给阿尔吉侬的花束",
    "description": "<p class=\"MsoNormal\"><span style=\"font-family:宋体\">    阿尔吉侬是一只聪明又慵懒的小白鼠，它最擅长的就是走各种各样的迷宫。今天它要挑战一个非常大的迷宫，研究员们为了鼓励阿尔吉侬尽快到达终点，就在终点放了一块阿尔吉侬最喜欢的奶酪。现在研究员们想知道，如果阿尔吉侬足够聪明，它最少需要多少时间就能吃到奶酪。</span></p><p class=\"MsoNormal\" style=\"\"><span style=\"font-family:宋体\">    迷宫用一个</span><span>R</span><span style=\"font-family:宋体\">×</span><span>C</span><span style=\"font-family:宋体\">的字符矩阵来表示。字符</span><span>S</span><span style=\"font-family:宋体\">表示阿尔吉侬所在的位置，字符</span><span>E</span><span style=\"font-family:宋体\">表示奶酪所在的位置，字符</span><span>#</span><span style=\"font-family:宋体\">表示墙壁，字符</span><span>.</span><span style=\"font-family:宋体\">表示可以通行。阿尔吉侬在</span><span>1</span><span style=\"font-family:宋体\">个单位时间内可以从当前的位置走到它上下左右四个方向上的任意一个位置，但不能走出地图边界。</span></p>",
    "img": "",
    "inputTip": "第一行是一个正整数T（1 <= T <= 10），表示一共有T组数据。\t每一组数据的第一行包含了两个用空格分开的正整数R和C（2 <= R, C <= 200），表示地图是一个R×C的矩阵。\t接下来的R行描述了地图的具体内容，每一行包含了C个字符。字符含义如题目描述中所述。保证有且仅有一个S和E。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对于每一组数据，输出阿尔吉侬吃到奶酪的最少单位时间。若阿尔吉侬无法吃到奶酪，则输出“oop!”（只输出引号里面的内容，不输出引号）。每组数据的输出结果占一行。",
    "inputExample": "<pre>3\n3 4\n.S..\n###.\n..E.\n3 4\n.S..\n.E..\n....\n3 4\n.S..\n####\n..E.</pre>",
    "outputExample": "<pre>5\n1\noop!</pre>",
    "tip": "",
    "timeLimited": "100ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7221",
    "category": "2.5基本算法之搜索",
    "title": "7221:拯救公主",
    "description": "<p class=\"MsoNormal\"><span style=\"font-family:宋体\">    多灾多难的公主又被大魔王抓走啦！国王派遣了第一勇士阿福去拯救她。</span></p><p class=\"MsoNormal\" style=\"\"><span style=\"font-family:宋体\">    身为超级厉害的术士，同时也是阿福的好伙伴，你决定祝他一臂之力。你为阿福提供了一张大魔王根据地的地图，上面标记了阿福和公主所在的位置，以及一些不能够踏入的禁区。你还贴心地为阿福制造了一些传送门，通过一个传送门可以瞬间转移到任意一个传送门，当然阿福也可以选择不通过传送门瞬移。传送门的位置也被标记在了地图上。此外，你还查探到公主所在的地方被设下了结界，需要集齐</span><span>K</span><span style=\"font-family:宋体\">种宝石才能打开。当然，你在地图上也标记出了不同宝石所在的位置。</span></p><p class=\"MsoNormal\" style=\"\"><span style=\"font-family:宋体\">    你希望阿福能够带着公主早日凯旋。于是在阿福出发之前，你还需要为阿福计算出他最快救出公主的时间。</span></p><p class=\"MsoNormal\" style=\"\"><span style=\"font-family:宋体\">    地图用一个</span><span>R</span><span style=\"font-family:宋体\">×</span><span>C</span><span style=\"font-family:宋体\">的字符矩阵来表示。字符</span><span>S</span><span style=\"font-family:宋体\">表示阿福所在的位置，字符</span><span>E</span><span style=\"font-family:宋体\">表示公主所在的位置，字符</span><span>#</span><span style=\"font-family:宋体\">表示不能踏入的禁区，字符</span><span>$</span><span style=\"font-family:宋体\">表示传送门，字符</span><span>.</span><span style=\"font-family:宋体\">表示该位置安全，数字字符</span><span>0</span><span style=\"font-family:宋体\">至</span><span>4</span><span style=\"font-family:宋体\">表示了宝石的类型。阿福每次可以从当前的位置走到他上下左右四个方向上的任意一个位置，但不能走出地图边界。阿福每走一步需要花费</span><span>1</span><span style=\"font-family:宋体\">个单位时间，从一个传送门到达另一个传送门不需要花费时间。当阿福走到宝石所在的位置时，就视为得到了该宝石，不需要花费额外时间。</span></p><p><br></p>",
    "img": "",
    "inputTip": "第一行是一个正整数T（1 <= T <= 10），表示一共有T组数据。\t每一组数据的第一行包含了三个用空格分开的正整数R、C（2 <= R, C <= 200）和K，表示地图是一个R×C的矩阵，而阿福需要集齐K种宝石才能够打开拘禁公主的结界。\t接下来的R行描述了地图的具体内容，每一行包含了C个字符。字符含义如题目描述中所述。保证有且仅有一个S和E。$的数量不超过10个。宝石的类型在数字0至4范围内，即不会超过5种宝石。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对于每一组数据，输出阿福救出公主所花费的最少单位时间。若阿福无法救出公主，则输出“oop!”（只输出引号里面的内容，不输出引号）。每组数据的输出结果占一行。",
    "inputExample": "<pre>1\n7 8 2\n........\n..S..#0.\n.##..1..\n.0#.....\n...1#...\n...##E..\n...1....</pre>",
    "outputExample": "<pre>11</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7834",
    "category": "2.5基本算法之搜索",
    "title": "7834:分成互质组",
    "description": "<p>给定n个正整数，将它们分组，使得每组中任意两个数互质。至少要分成多少个组？<br></p>",
    "img": "",
    "inputTip": "第一行是一个正整数n。1 <= n <= 10。第二行是n个不大于10000的正整数。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个正整数，即最少需要的组数。",
    "inputExample": "<pre>6\n14 20 33 117 143 175</pre>",
    "outputExample": "<pre>3</pre>",
    "tip": "2008年第十三届“华罗庚金杯”少年数学邀请赛 决赛第5题",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "8436",
    "category": "2.5基本算法之搜索",
    "title": "8436:Saving Tang Monk",
    "description": "<p class=\"MsoNormal\" style=\"\"><span style=\"font-family:宋体\">《</span><span style=\"font-family:'Cambria','serif'\">Journey to theWest</span><span style=\"font-family:宋体\">》</span><span style=\"font-family:'Cambria','serif'\">(also </span><span style=\"font-family:宋体\">《</span><span style=\"font-family:'Cambria','serif'\">Monkey</span><span style=\"font-family:宋体\">》</span><span style=\"font-family:'Cambria','serif'\">) is one of the </span><span><a href=\"http://en.wikipedia.org/wiki/Four_Great_Classical_Novels\" title=\"Four Great Classical Novels\"><span style=\"font-family:'Cambria','serif';color:windowtext\">Four Great Classical Novels</span></a></span><span style=\"font-family:'Cambria','serif'\">of </span><span><a href=\"http://en.wikipedia.org/wiki/Chinese_literature\" title=\"Chinese literature\"><span style=\"font-family:'Cambria','serif';color:windowtext\">Chinese literature</span></a></span><span style=\"font-family:'Cambria','serif'\">. It was writtenby Wu Cheng'en during the Ming Dynasty. In this novel, Monkey King Sun Wukong,pig Zhu Bajie and Sha Wujing, </span><span><a href=\"http://cn.bing.com/dict/search?q=escort&FORM=BDVSP6\"><span style=\"font-family:'Cambria','serif';color:windowtext\">escort</span></a></span><span style=\"font-family:'Cambria','serif'\">ed Tang Monk to India to getsacred Buddhism texts. </span></p><p class=\"MsoNormal\" style=\"\"><span style=\"font-family:'Cambria','serif'\">During thejourney, Tang Monk was often captured by demons. Most of demons wanted to eatTang Monk to achieve immortality, but some female demons just wanted to marryhim because he was handsome. So, fighting demons and saving Monk Tang is themajor job for Sun Wukong to do.</span></p><p class=\"MsoNormal\" style=\"\"><span style=\"font-family:'Cambria','serif'\">Once, TangMonk was captured by the demon White Bones. White Bones lived in a palace andshe cuffed Tang Monk in a room. Sun Wukong managed to get into the palace. Butto rescue Tang Monk, Sun Wukong might need to get some keys and kill somesnakes in his way. </span></p><p class=\"MsoNormal\" style=\"\"><span style=\"font-family:'Cambria','serif'\">The palace can be described as a matrix of characters. Each characterstands for a room. In the matrix, 'K' represents the original position of SunWukong, 'T' represents the location of Tang Monk and 'S' stands for a room witha </span><span style=\"font-family:'Cambria','serif'\">snake</span><span style=\"font-family:'Cambria','serif'\">in it. Please note that there are only one 'K' and one 'T', and at mostfive </span><span style=\"font-family:'Cambria','serif'\">snakes</span><span style=\"font-family:'Cambria','serif'\">in the palace. And, '.' means a clear room as well '#' means a deadlyroom which Sun Wukong couldn't get in. </span></p><p class=\"MsoNormal\" style=\"\"><span style=\"font-family:'Cambria','serif'\">There may be some keys of different kinds scattered in the rooms, butthere is at most one key in one room. There are at most 9 kinds of keys. A roomwith a key in it is represented by a digit(from '1' to '9'). For example, '1'means a room with a first kind key, '2' means a room with a second kind key,'3' means a room with a third kind key... etc. To save Tang Monk, Sun Wukongmust get ALL kinds of keys(in other words, at least one key for each kind). </span></p><p class=\"MsoNormal\" style=\"\"><span style=\"font-family:'Cambria','serif'\"><span style=\"\"> </span>For each step, Sun Wukong couldmove to the adjacent rooms(except deadly rooms) in 4 directions(north, west, southand east), and each step took him one minute. If he entered a room in which aliving </span><span style=\"font-family:'Cambria','serif'\">snake</span><span style=\"font-family:'Cambria','serif'\">stayed, he must kill the </span><span style=\"font-family:'Cambria','serif'\">snake</span><span style=\"font-family:'Cambria','serif'\">.Killing a </span><span style=\"font-family:'Cambria','serif'\">snake</span><span style=\"font-family:'Cambria','serif'\">also took one minute. If Sun Wukong entered a room where there is a keyof kind N, Sun would get that key if and only if he had already got keys ofkind 1,kind 2 ... and kind N-1. In other words, Sun Wukong must get a key ofkind N before he could get a key of kind N+1 (N>=1). If Sun Wukong got allkeys he needed and entered the room in which Tang Monk was </span><span style=\"font-family:'Cambria','serif'\">cuffed</span><span style=\"font-family:'Cambria','serif'\">, the rescue mission is completed. If Sun Wukong didn't get enough keys,he still could pass through Tang Monk's room. </span><span style=\"font-family:'Cambria','serif'\">Since Sun Wukong was a impatient monkey,he wanted to save Tang Monk as quickly as possible. Please figure out theminimum time Sun Wukong needed to rescue Tang Monk.</span></p><p><br></p>",
    "img": "",
    "inputTip": "There are several test cases.For each case, the first line includes two integers N and M(0 < N <= 100, 0<=M<=9), meaning that the palace is a N×N matrix and Sun Wukong needed M kinds of keys(kind 1, kind 2, ... kind M). Then the N×N matrix follows.The input ends with N = 0 and M = 0.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each test case, print the minimum time (in minutes) Sun Wukong needed to save Tang Monk. If it's impossible for Sun Wukong to complete the mission, print \"impossible\"(no quotes).",
    "inputExample": "<pre>3 1\nK.S\n##1\n1#T\n3 1\nK#T\n.S#\n1#.\n3 2\nK#T\n.S.\n21.\n0 0\n</pre>",
    "outputExample": "<pre>5\nimpossible\n8\n</pre>",
    "tip": "guo wei",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "8465",
    "category": "2.5基本算法之搜索",
    "title": "8465:马走日",
    "description": "<p>马在中国象棋以日字形规则移动。</p><p>请编写一段程序，给定n*m大小的棋盘，以及马的初始位置(x，y)，要求不能重复经过棋盘上的同一个点，计算马可以有多少途径遍历棋盘上的所有点。</p>",
    "img": "",
    "inputTip": "第一行为整数T(T < 10)，表示测试数据组数。每一组测试数据包含一行，为四个整数，分别为棋盘的大小以及初始位置坐标n,m,x,y。(0<=x<=n-1,0<=y<=m-1, m < 10, n < 10)",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "每组测试数据包含一行，为一个整数，表示马能遍历棋盘的途径总数，0为无法遍历一次。",
    "inputExample": "<pre>1\n5 4 0 0</pre>",
    "outputExample": "<pre>32</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "1024kB"
  },
  {
    "id": "8783",
    "category": "2.5基本算法之搜索",
    "title": "8783:单词接龙",
    "description": "<p>单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如beast和astonish，如果接成一条龙则变为beastonish，另外相邻的两部分不能存在包含关系，例如at和atide间不能相连。</p>",
    "img": "",
    "inputTip": "输入的第一行为一个单独的整数n(n<=20)表示单词数，以下n行每行有一个单词（只含有大写或小写字母，长度不超过20），输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "只需输出以此字母开头的最长的“龙”的长度。",
    "inputExample": "<pre>5\nat\ntouch\ncheat\nchoose\ntact\na\n</pre>",
    "outputExample": "<pre>23</pre>",
    "tip": "连成的“龙”为atoucheatactactouchoose",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "917",
    "category": "2.5基本算法之搜索",
    "title": "917:Knight Moves",
    "description": "<b>Background</b><br>Mr Somurolov, fabulous chess-gamer indeed, asserts that no one else but him can move knights from one position to another so fast. Can you beat him?<br><b>The Problem</b><br>Your task is to write a program to calculate the minimum number of moves needed for a knight to reach one point from another, so that you have the chance to be faster than Somurolov.<br>For people not familiar with chess, the possible knight moves are shown in Figure 1.<br><center><img src=\"http://media.openjudge.cn/images/g917/1915_1.jpg\"></center>",
    "img": "",
    "inputTip": "The input begins with the number n of scenarios on a single line by itself.Next follow n scenarios. Each scenario consists of three lines containing integer numbers. The first line specifies the length l of a side of the chess board (4 <= l <= 300). The entire board has size l * l. The second and third line contain pair of integers {0, ..., l-1}*{0, ..., l-1} specifying the starting and ending position of the knight on the board. The integers are separated by a single blank. You can assume that the positions are valid positions on the chess board of that scenario.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each scenario of the input you have to calculate the minimal amount of knight moves which are necessary to move from the starting point to the ending point. If starting point and ending point are equal,distance is zero. The distance must be written on a single line.",
    "inputExample": "<pre>3\n8\n0 0\n7 0\n100\n0 0\n30 50\n10\n1 1\n1 1</pre>",
    "outputExample": "<pre>5\n28\n0</pre>",
    "tip": "TUD Programming Contest 2001, Darmstadt, Germany",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  }
]