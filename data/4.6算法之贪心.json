[
  {
    "id": "1455",
    "category": "4.6算法之贪心",
    "title": "1455:An Easy Problem",
    "description": "As we known, data stored in the computers is in binary form. The problem we discuss now is about the positive integers and its binary form.<br><br>Given a positive integer I, you task is to find out an integer J, which is the minimum integer greater than I, and the number of '1's in whose binary form is the same as that in the binary form of I.<br><br>For example, if \"78\" is given, we can write out its binary form, \"1001110\". This binary form has 4 '1's. The minimum integer, which is greater than \"1001110\" and also contains 4 '1's, is \"1010011\", i.e. \"83\", so you should output \"83\".",
    "img": "",
    "inputTip": "One integer per line, which is I (1 <= I <= 1000000).A line containing a number \"0\" terminates input, and this line need not be processed.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "One integer per line, which is J.",
    "inputExample": "<pre>1\n2\n3\n4\n78\n0\n</pre>",
    "outputExample": "<pre>2\n4\n5\n8\n83\n</pre>",
    "tip": "POJ Monthly,zby03",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1768",
    "category": "4.6算法之贪心",
    "title": "1768:最大子矩阵",
    "description": "已知矩阵的大小定义为矩阵中所有元素的和。给定一个矩阵，你的任务是找到最大的非空(大小至少是1 * 1)子矩阵。<br><br>比如，如下4 * 4的矩阵<br><br> 0 -2 -7  0<br> 9  2 -6  2<br>-4  1 -4  1<br>-1  8  0 -2<br><br>的最大子矩阵是<br><br> 9  2<br>-4  1<br>-1  8<br><br>这个子矩阵的大小是15。",
    "img": "",
    "inputTip": "输入是一个N * N的矩阵。输入的第一行给出N (0 < N <= 100)。再后面的若干行中，依次（首先从左到右给出第一行的N个整数，再从左到右给出第二行的N个整数……）给出矩阵中的N2个整数，整数之间由空白字符分隔（空格或者空行）。已知矩阵中整数的范围都在[-127, 127]。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出最大子矩阵的大小。",
    "inputExample": "<pre>4\n0 -2 -7 0 9 2 -6 2\n-4 1 -4  1 -1\n\n8  0 -2</pre>",
    "outputExample": "<pre>15</pre>",
    "tip": "翻译自 Greater New York 2001 的试题",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1797",
    "category": "4.6算法之贪心",
    "title": "1797:金银岛",
    "description": "某天KID利用飞行器飞到了一个金银岛上，上面有许多珍贵的金属，KID虽然更喜欢各种宝石的艺术品，可是也不拒绝这样珍贵的金属。但是他只带着一个口袋，口袋至多只能装重量为w的物品。岛上金属有s个种类, 每种金属重量不同，分别为n<sub>1</sub>, n<sub>2</sub>, ... , n<sub>s</sub>，同时每个种类的金属总的价值也不同，分别为v<sub>1</sub>,v<sub>2</sub>, ..., v<sub>s</sub>。KID想一次带走价值尽可能多的金属，问他最多能带走价值多少的金属。注意到金属是可以被任意分割的，并且金属的价值和其重量成正比。",
    "img": "",
    "inputTip": "第1行是测试数据的组数k，后面跟着k组输入。每组测试数据占3行，第1行是一个正整数w (1 <= w <= 10000)，表示口袋承重上限。第2行是一个正整数s (1 <= s <=100)，表示金属种类。第3行有2s个正整数，分别为n1, v1, n2, v2, ... , ns, vs分别为第一种，第二种，...，第s种金属的总重量和总价值(1 <= ni <= 10000, 1 <= vi <= 10000)。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "k行，每行输出对应一个输入。输出应精确到小数点后2位。",
    "inputExample": "<pre>2\n50\n4\n10 100 50 30 7 34 87 100\n10000\n5\n1 43 43 323 35 45 43 54 87 43\n</pre>",
    "outputExample": "<pre>171.93\n508.00\n</pre>",
    "tip": "",
    "timeLimited": "3000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1799",
    "category": "4.6算法之贪心",
    "title": "1799:最短前缀",
    "description": "一个字符串的前缀是从该字符串的第一个字符起始的一个子串。例如 \"carbon\"的字串是: \"c\", \"ca\", \"car\", \"carb\", \"carbo\", 和 \"carbon\"。注意到这里我们不认为空串是字串, 但是每个非空串是它自身的字串. 我们现在希望能用前缀来缩略的表示单词。例如, \"carbohydrate\" 通常用\"carb\"来缩略表示. 现在给你一组单词, 要求你找到唯一标识每个单词的最短前缀<br>在下面的例子中，\"carbohydrate\" 能被缩略成\"carboh\", 但是不能被缩略成\"carbo\" (或其余更短的前缀) 因为已经有一个单词用\"carbo\"开始<br>一个精确匹配会覆盖一个前缀匹配，例如，前缀\"car\"精确匹配单词\"car\". 因此 \"car\" 是 \"car\"的缩略语是没有二义性的 , “car”不会被当成\"carriage\"或者任何在列表中以\"car\"开始的单词.<br>",
    "img": "",
    "inputTip": "输入包括至少2行，至多1000行. 每行包括一个以小写字母组成的单词，单词长度至少是1，至多是20.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出的行数与输入的行数相同。每行输出由相应行输入的单词开始，后面跟着一个空格接下来是相应单词的没有二义性的最短前缀标识符。",
    "inputExample": "<pre>carbohydrate\ncart\ncarburetor\ncaramel\ncaribou\ncarbonic\ncartilage\ncarbon\ncarriage\ncarton\ncar\ncarbonate\n</pre>",
    "outputExample": "<pre>carbohydrate carboh\ncart cart\ncarburetor carbu\ncaramel cara\ncaribou cari\ncarbonic carboni\ncartilage carti\ncarbon carbon\ncarriage carr\ncarton carto\ncar car\ncarbonate carbona\n</pre>",
    "tip": "翻译自Rocky Mountain 2004",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "19",
    "category": "4.6算法之贪心",
    "title": "19:装箱问题",
    "description": "一个工厂制造的产品形状都是长方体，它们的高度都是h，长和宽都相等，一共有六个型号，他们的长宽分别为1*1, 2*2, 3*3, 4*4, 5*5, 6*6。这些产品通常使用一个 6*6*h 的长方体包裹包装然后邮寄给客户。因为邮费很贵，所以工厂要想方设法的减小每个订单运送时的包裹数量。他们很需要有一个好的程序帮他们解决这个问题从而节省费用。现在这个程序由你来设计。",
    "img": "",
    "inputTip": "输入文件包括几行，每一行代表一个订单。每个订单里的一行包括六个整数，中间用空格隔开，分别为1*1至6*6这六种产品的数量。输入文件将以6个0组成的一行结尾。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "除了输入的最后一行6个0以外，输入文件里每一行对应着输出文件的一行，每一行输出一个整数代表对应的订单所需的最小包裹数。",
    "inputExample": "<pre>0 0 4 0 0 1 \n7 5 1 0 0 0 \n0 0 0 0 0 0 </pre>",
    "outputExample": "<pre>2 \n1 </pre>",
    "tip": "Central Europe 1996",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "20",
    "category": "4.6算法之贪心",
    "title": "20:Communication System",
    "description": "We have received an order from Pizoor Communications Inc. for a special communication system. The system consists of several devices. For each device, we are free to choose from several manufacturers. Same devices from two manufacturers differ in their maximum bandwidths and prices. <br>By overall bandwidth (B) we mean the minimum of the bandwidths of the chosen devices in the communication system and the total price (P) is the sum of the prices of all chosen devices. Our goal is to choose a manufacturer for each device to maximize B/P.<br>",
    "img": "",
    "inputTip": "The first line of the input file contains a single integer t (1 ≤ t ≤ 10), the number of test cases, followed by the input data for each test case. Each test case starts with a line containing a single integer n (1 ≤ n ≤ 100), the number of devices in the communication system, followed by n lines in the following format: the i-th line (1 ≤ i ≤ n) starts with mi (1 ≤ mi ≤ 100), the number of manufacturers for the i-th device, followed by mi pairs of positive integers in the same line, each indicating the bandwidth and the price of the device respectively, corresponding to a manufacturer.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "Your program should produce a single line for each test case containing a single number which is the maximum possible B/P for the test case. Round the numbers in the output to 3 digits after decimal point.",
    "inputExample": "<pre>1 3\n3 100 25 150 35 80 25\n2 120 80 155 40\n2 100 100 120 110</pre>",
    "outputExample": "<pre>0.649</pre>",
    "tip": "Tehran 2002, First Iran Nationwide Internet Programming Contest",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2375",
    "category": "4.6算法之贪心",
    "title": "2375:Sunscreen",
    "description": "To avoid unsightly burns while tanning, each of the C (1 <= C <= 2500) cows must cover her hide with sunscreen when they're at the beach. Cow i has a minimum and maximum SPF rating (1 <= minSPF_i <= 1,000; minSPF_i <= maxSPF_i <= 1,000) that will work. If the SPF rating is too low, the cow suffers sunburn; if the SPF rating is too high, the cow doesn't tan at all.<br><br>The cows have a picnic basket with L (1 <= L <= 2500) bottles of sunscreen lotion, each bottle i with an SPF rating SPF_i (1 <= SPF_i <= 1,000). Lotion bottle i can cover cover_i cows with lotion. A cow may lotion from only one bottle.<br><br>What is the maximum number of cows that can protect themselves while tanning given the available lotions?<br>",
    "img": "",
    "inputTip": "* Line 1: Two space-separated integers: C and L* Lines 2..C+1: Line i describes cow i's lotion requires with two integers: minSPF_i and maxSPF_i* Lines C+2..C+L+1: Line i+C+1 describes a sunscreen lotion bottle i with space-separated integers: SPF_i and cover_i",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "A single line with an integer that is the maximum number of cows that can be protected while tanning",
    "inputExample": "<pre>3 2\n3 10\n2 5\n1 5\n6 2\n4 1</pre>",
    "outputExample": "<pre>2</pre>",
    "tip": "INPUT DETAILS:3 cows; 2 lotions.  Cows want SPF ratings of 3..10, 2..5, and 1..5. Lotions available: 6 (for two cows), 4 (for 1 cow). Cow 1 can use the SPF 6 lotion. Either cow 2 or cow 3 can use the SPF 4 lotion.  Only 2 cows can be covered.",
    "timeLimited": "10000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "2384",
    "category": "4.6算法之贪心",
    "title": "2384:Cell Phone Network",
    "description": "Farmer John has decided to give each of his cows a cell phone in hopes to encourage their social interaction. This, however, requires him to set up cell phone towers on his N (1 <= N <= 10,000) pastures (conveniently numbered 1..N) so they can all communicate.<br><br>Exactly N-1 pairs of pastures are adjacent, and for any two pastures A and B (1 <= A <= N; 1 <= B <= N; A != B) there is a sequence of adjacent pastures such that A is the first pasture in the sequence and B is the last. Farmer John can only place cell phone towers in the pastures, and each tower has enough range to provide service to the pasture it is on and all pastures adjacent to the pasture with the cell tower.<br><br>Help him determine the minimum number of towers he must install to provide cell phone service to each pasture.",
    "img": "",
    "inputTip": "* Line 1: A single integer: N* Lines 2..N: Each line specifies a pair of adjacent pastures with two space-separated integers: A and B",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "* Line 1: A single integer indicating the minimum number of towers to install",
    "inputExample": "<pre>5\n1 3\n5 2\n4 3\n3 5</pre>",
    "outputExample": "<pre>2\n</pre>",
    "tip": "INPUT DETAILS:Farmer John has 5 pastures: pastures 1 and 3 are adjacent, as are pastures 5 and 2, pastures 4 and 3, and pastures 3 and 5. Geometrically, the farm looks like this (or some similar configuration)               4  2               |  |            1--3--5OUTPUT DETAILS:The towers can be placed at pastures 2 and 3 or pastures 3 and 5.",
    "timeLimited": "10000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "2390",
    "category": "4.6算法之贪心",
    "title": "2390:Pearl Pairing",
    "description": "At Bessie's recent birthday party, she received N (2 <= N <= 100,000; N%2 == 0) pearls, each painted one of C different colors (1 <= C <= N).<br><br>Upon observing that the number of pearls N is always even, her creative juices flowed and she decided to pair the pearls so that each pair of pearls has two different colors.<br><br>Knowing that such a set of pairings is always possible for the supplied testcases, help Bessie perform such a pairing. If there are multiple ways of creating a pairing, any solution suffices.",
    "img": "",
    "inputTip": "* Line 1: Two space-separated integers: N and C* Lines 2..C + 1: Line i+1 tells the count of pearls with color i: C_i",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "* Lines 1..N/2: Line i contains two integers a_i and b_i indicating that Bessie can pair two pearls with respective colors a_i and b_i.",
    "inputExample": "<pre>8 3\n2\n2\n4</pre>",
    "outputExample": "<pre>1 3\n1 3\n2 3\n3 2</pre>",
    "tip": "INPUT DETAILS:There are 8 pearls and 3 different colors. Two pearls have color I; two have color II; four have color III.OUTPUT DETAILS:Bessie pairs each pearl of color III with one of color I and II.",
    "timeLimited": "10000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "2404",
    "category": "4.6算法之贪心",
    "title": "2404:Ride to Office",
    "description": "Many staff of are living in a place called MZone, far from their office( 4.5 km ). Due to the bad traffic, many staff choose to ride a bike.<br><br>We may assume that all the people except \"Weiwei\" ride from home to office at a fixed speed. Weiwei is a people with a different riding habit – he always tries to follow another rider to avoid riding alone. When Weiwei gets to the gate of MZone, he will look for someone who is setting off to the Office. If he finds someone, he will follow that rider, or if not, he will wait for someone to follow. On the way from his home to office, at any time if a faster student surpassed Weiwei, he will leave the rider he is following and speed up to follow the faster one.<br><br>We assume the time that Weiwei gets to the gate of MZone is zero. Given the set off time and speed of the other people, your task is to give the time when Weiwei arrives at his office.",
    "img": "",
    "inputTip": "There are several test cases. The first line of each case is N (1 <= N <= 10000) representing the number of riders (excluding Weiwei). N = 0 ends the input. The following N lines are information of N different riders, in such format: Vi [TAB] TiVi is a positive integer <= 40, indicating the speed of the i-th rider (kph, kilometers per hour). Ti is the set off time of the i-th rider, which is an integer and counted in seconds. In any case it is assured that there always exists a nonnegative Ti. ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "Output one line for each case: the arrival time of Weiwei. Round up (ceiling) the value when dealing with a fraction.",
    "inputExample": "<pre>4\n20\t0\n25\t-155\n27\t190\n30\t240\n2\n21\t0\n22\t34\n0\n</pre>",
    "outputExample": "<pre>780\n771\n</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2407",
    "category": "4.6算法之贪心",
    "title": "2407:书架",
    "description": "<p>John最近买了一个书架用来存放奶牛养殖书籍，但书架很快被存满了，只剩最顶层有空余。</p><br><p>John共有N头奶牛(1 ≤ N ≤ 20,000)，每头奶牛有自己的高度Hi(1 ≤ Hi ≤ 10,000)，N头奶牛的总高度为S。书架高度为B(1 ≤ B ≤ S < 2,000,000,007).</p><br><p>为了到达书架顶层，奶牛可以踩着其他奶牛的背，像叠罗汉一样，直到他们的总高度不低于书架高度。当然若奶牛越多则危险性越大。为了帮助John到达书架顶层，找出使用奶牛数目最少的解决方案吧。</p><br>",
    "img": "",
    "inputTip": "第1行：空格隔开的整数N和B第2~N+1行：第i+1行为整数Hi",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "能达到书架高度所使用奶牛的最少数目",
    "inputExample": "<pre>6 40\n6\n18\n11\n13\n19\n11\n</pre>",
    "outputExample": "<pre>3</pre>",
    "tip": "",
    "timeLimited": "20000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "2469",
    "category": "4.6算法之贪心",
    "title": "2469:电池的寿命",
    "description": "<p>小S新买了一个掌上游戏机，这个游戏机由两节5号电池供电。为了保证能够长时间玩游戏，他买了很多5号电池，这些电池的生产商不同，质量也有差异，因而使用寿命也有所不同，有的能使用5个小时，有的可能就只能使用3个小时。显然如果他只有两个电池一个能用5小时一个能用3小时，那么他只能玩3个小时的游戏，有一个电池剩下的电量无法使用，但是如果他有更多的电池，就可以更加充分地利用它们，比如他有三个电池分别能用3、3、5小时，他可以先使用两节能用3个小时的电池，使用半个小时后再把其中一个换成能使用5个小时的电池，两个半小时后再把剩下的一节电池换成刚才换下的电池（那个电池还能用2.5个小时），这样总共就可以使用5.5个小时，没有一点浪费。</p><p>现在已知电池的数量和电池能够使用的时间，请你找一种方案使得使用时间尽可能的长。</p>",
    "img": "",
    "inputTip": "输入包含多组数据。每组数据包括两行，第一行是一个整数N (2 ≤ N ≤ 1000)，表示电池的数目，接下来一行是N个正整数表示电池能使用的时间。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对每组数据输出一行，表示电池能使用的时间，保留到小数点后1位。",
    "inputExample": "<pre>2\n3 5\n3\n3 3 5\n</pre>",
    "outputExample": "<pre>3.0\n5.5\n</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2704",
    "category": "4.6算法之贪心",
    "title": "2704:寻找平面上的极大点",
    "description": "在一个平面上，如果有两个点(x,y),(a,b),如果说(x,y)支配了(a,b)，这是指x>=a,y>=b;<br>用图形来看就是(a,b)坐落在以(x,y)为右上角的一个无限的区域内。<br>给定n个点的集合，一定存在若干个点，它们不会被集合中的任何一点所支配，这些点叫做极大值点。<br>编程找出所有的极大点，按照x坐标由小到大，输出极大点的坐标。<br>本题规定：n不超过100，并且不考虑点的坐标为负数的情况。",
    "img": "",
    "inputTip": "输入包括两行，第一行是正整数n，表示是点数，第二行包含n个点的坐标，坐标值都是整数，坐标范围从0到100，输入数据中不存在坐标相同的点。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "按x轴坐标最小到大的顺序输出所有极大点。输出格式为:(x1,y1),(x2,y2),...(xk,yk)注意：输出的每个点之间有\",\"分隔,最后一个点之后没有\",\",少输出和多输出都会被判错",
    "inputExample": "<pre>5 \n1 2 2 2 3 1 2 3 1 4</pre>",
    "outputExample": "<pre>(1,4),(2,3),(3,1)</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2986",
    "category": "4.6算法之贪心",
    "title": "2986:拼点游戏",
    "description": "C和S两位同学一起玩拼点游戏。有一堆白色卡牌和一堆蓝色卡牌，每张卡牌上写了一个整数点数。C随机抽取n张白色卡牌，S随机抽取n张蓝色卡牌，他们进行n回合拼点，每次两人各出一张卡牌，点数大者获得三颗巧克力，小者获得一颗巧克力，如果点数相同，每人各得二颗巧克力，使用过的卡牌不得重复使用。已知C和S取到的卡牌点数，请编程计算S最多和最少能得到多少颗巧克力。",
    "img": "",
    "inputTip": "输入包含多组测试数据。每组测试数据的第一行是一个整数n(1<=n<=1000)，接下来一行是n个整数，表示C抽到的白色卡牌的点数，下一行也是n个整数，表示S抽到的蓝色卡牌的点数。 输入的最后以一个0表示结束。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对每组数据，输出一行，内容是两个整数用空格格开，分别表示S最多和最少可获得的巧克力数。",
    "inputExample": "<pre>3\n92 83 71\n95 87 74\n2\n20 20\n20 20\n2\n20 19\n22 18\n0</pre>",
    "outputExample": "<pre>9 5\n4 4\n4 4</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "3527",
    "category": "4.6算法之贪心",
    "title": "3527:胡",
    "description": "　　对于一个元素为数字1-9的集合A（每个数字的数量不超过4个，集合中元素的数量不超过14个），判断其是否满足如下规则：<br>　　集合A可以分割为若干个由3个数字组成的集合Bo...Bn和一个由2个数字组成的集合C。其中Bo...Bn需要满足每个集合中的数字均相等或者依次递增一（例如5 5 5以及4 5 6均满足条件）；C中的两个数字相等<br>　　显然，当集合中的元素个数等于3n+2（n=0，1..4）时才有可能满足上述条件，我们将元素个数不为3n+2的集合称为“相公”的集合，满足上述条件的集合称为能够“胡”的集合，否则则是“不胡”的集合",
    "img": "",
    "inputTip": "　　输入的每一行包括一组测试数据，测试数据的开头为0表示测试结束；每一组数据由若干个1-9的数字组成，数字之间用空格隔开",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "　　每一行输出对应一行输入的结果，对于“相公”的集合输出“XIANGGONG”；对于满足“胡”的集合，输出“HU”；否则输出“BUHU”",
    "inputExample": "<pre>1 2\n4 4\n1 1 1 2 3 4 5 6 7 8 9 9 9\n1 1 1 2 3 4 5 6 7 8 9 9 9 9\n0\n</pre>",
    "outputExample": "<pre>BUHU\nHU\nXIANGGONG\nHU\n</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "3528",
    "category": "4.6算法之贪心",
    "title": "3528:最小新整数",
    "description": "<p>给定一个十进制正整数n(0 < n < 1000000000)，每个数位上数字均不为0。n的位数为m。<br>现在从m位中删除k位(0<k < m)，求生成的新整数最小为多少？<br>例如: n = 9128456, k = 2, 则生成的新整数最小为12456</p>",
    "img": "",
    "inputTip": "第一行t, 表示有t组数据；接下来t行，每一行表示一组测试数据，每组测试数据包含两个数字n, k。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "t行，每行一个数字，表示从n中删除k位后得到的最小整数。",
    "inputExample": "<pre>2\n9128456 2\n1444 3\n</pre>",
    "outputExample": "<pre>12456\n1\n</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "407",
    "category": "4.6算法之贪心",
    "title": "407:Heritage",
    "description": "Your rich uncle died recently, and the heritage needs to be divided among your relatives and the church (your uncle insisted in his will that the church must get something). There are N relatives (N <= 18) that were mentioned in the will. They are sorted in descending order according to their importance (the first one is the most important). Since you are the computer scientist in the family, your relatives asked you to help them. They need help, because there are some blanks in the will left to be filled. Here is how the will looks: <br><br>Relative #1 will get 1  / ... of the whole heritage, <br>Relative #2 will get 1  / ... of the whole heritage,<br>----------------------  ...<br>Relative #n will get 1 /  ... of the whole heritage.<br><br>The logical desire of the relatives is to fill the blanks in such way that the uncle's will is preserved (i.e the fractions are non-ascending and the church gets something) and the amount of heritage left for the church is minimized. ",
    "img": "",
    "inputTip": "The only line of input contains the single integer N (1 <= N <= 18).",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "Output the numbers that the blanks need to be filled (on separate lines), so that the heritage left for the church is minimized.",
    "inputExample": "<pre>2</pre>",
    "outputExample": "<pre>2\n3</pre>",
    "tip": "ural 1108",
    "timeLimited": "5000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "676",
    "category": "4.6算法之贪心",
    "title": "676:Sorting by Swapping",
    "description": "Given a permutation of numbers from 1 to n, we can always get the sequence 1, 2, 3, ..., n by swapping pairs of numbers. For example, if the initial sequence is 2, 3, 5, 4, 1, we can sort them in the following way:<br><br>2 3 5 4 1<br>1 3 5 4 2<br>1 3 2 4 5<br>1 2 3 4 5<br><br>Here three swaps have been used. The problem is, given a specific permutation, how many swaps we needs to take at least. <br>",
    "img": "",
    "inputTip": "The first line contains a single integer t (1 <= t <= 20) that indicates the number of test cases. Then follow the t cases. Each case contains two lines. The first line contains the integer n (1 <= n <= 10000), and the second line gives the initial permutation.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each test case, the output will be only one integer, which is the least number of swaps needed to get the sequence 1, 2, 3, ..., n from the initial permutation. ",
    "inputExample": "<pre>2\n3\n1 2 3\n5\n2 3 5 4 1</pre>",
    "outputExample": "<pre>0\n3</pre>",
    "tip": "POJ Monthly--2004.06.27 弱人",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "702",
    "category": "4.6算法之贪心",
    "title": "702:Crossing River",
    "description": "A group of N people wishes to go across a river with only one boat, which can at most carry two persons. Therefore some sort of shuttle arrangement must be arranged in order to row the boat back and forth so that all people may cross. Each person has a different rowing speed; the speed of a couple is determined by the speed of the slower one. Your job is to determine a strategy that minimizes the time for these people to get across.",
    "img": "",
    "inputTip": "The first line of the input contains a single integer T (1 <= T <= 20), the number of test cases. Then T cases follow. The first line of each case contains N, and the second line contains N integers giving the time for each people to cross the river. There won't be more than 1000 people and nobody takes more than 100 seconds to cross.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each test case, print a line containing the total number of seconds required for all the N people to cross the river.",
    "inputExample": "<pre>1\n4\n1 2 5 10\n</pre>",
    "outputExample": "<pre>17</pre>",
    "tip": "POJ Monthly--2004.07.18",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "712",
    "category": "4.6算法之贪心",
    "title": "712:Magic of David Copperfield",
    "description": "The well-known magician David Copperfield loves to show the following trick: a square with N rows and N columns of different pictures appears on a TV screen. Let us number all the pictures in the following order: <br><center><table border=\"\" cellspacing=\"1\" cellpadding=\"7\" width=\"40%\"><tbody><tr><td width=\"25%\" valign=\"TOP\"><font size=\"2\"></font><p align=\"CENTER\"><font size=\"2\">1</font></p></td><td width=\"25%\" valign=\"TOP\"><font size=\"2\"></font><p align=\"CENTER\"><font size=\"2\">2</font></p></td><td width=\"25%\" valign=\"TOP\"><font size=\"2\"></font><p align=\"CENTER\"><font size=\"2\">...</font></p></td><td width=\"25%\" valign=\"TOP\"><font size=\"2\"></font><p align=\"CENTER\"><font size=\"2\">N</font></p></td></tr><tr><td width=\"25%\" valign=\"TOP\"><font size=\"2\"></font><p align=\"CENTER\"><font size=\"2\">:</font></p></td><td width=\"25%\" valign=\"TOP\"><font size=\"2\"></font><p align=\"CENTER\"><font size=\"2\">:</font></p></td><td width=\"25%\" valign=\"TOP\"><font size=\"2\"></font><p align=\"CENTER\"><font size=\"2\">...</font></p></td><td width=\"25%\" valign=\"TOP\"><font size=\"2\"></font><p align=\"CENTER\"><font size=\"2\">:</font></p></td></tr><tr><td width=\"25%\" valign=\"TOP\"><font size=\"2\"></font><p align=\"CENTER\"><font size=\"2\">N*(N-1)+1</font></p></td><td width=\"25%\" valign=\"TOP\"><font size=\"2\"></font><p align=\"CENTER\"><font size=\"2\">N*(N-1)+2</font></p></td><td width=\"25%\" valign=\"TOP\"><font size=\"2\"></font><p align=\"CENTER\"><font size=\"2\">...</font></p></td><td width=\"25%\" valign=\"TOP\"><font size=\"2\"></font><p align=\"CENTER\"><font size=\"2\">N*N</font></p></td></tr></tbody></table></center><br>Each member of the audience is asked to put a finger on the upper left picture (i.e., picture number one) and The Magic begins: the magician tells the audience to move the finger k1 times through the pictures (each move is a shift of the finger to the adjacent picture up, down, left or right provided that there is a picture to move to), then with a slight movement of his hand he removes some of the pictures with an exclamation \"You are not there!\", and ... it is true - your finger is not pointing to any of the pictures removed. Then again, he tells the audience to make k2 moves, and so on. At the end he removes all the pictures but one and smiling triumphantly declares, \"I've caught you\" (applause). <br><br>Just now, David is trying to repeat this trick. Unfortunately, he had a hard day before, and you know how hard to conjure with a headache. You have to write a program that will help David to make his trick. <br>",
    "img": "",
    "inputTip": "The input contains a single integer number N (2<=N<=100). ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "Your program should write the following lines with numbers to the output file: k1 x1,1 x1,2 ... x1,m1k2 x2,1 x2,2 ... x2,m2   ...ke xe,1 xe,2 ... xe,mewhere ki is a number of moves the audience should make on the i-th turn (2N<=k<=10000). All ki should be different (i.e. ki <> kj when i <> j). xi,1, xi,2, ... , xi, mi are the numbers of the pictures David should remove after the audience will make ki moves (the number of the pictures removed is arbitrary, but each picture should be listed only once, and at least one picture should be removed on each turn). A description of the every next turn should begin with a new line. All numbers on each line should be separated by one space. After e iterations, all pictures except one should be removed. ",
    "inputExample": "<pre>3\n</pre>",
    "outputExample": "<pre>8 4 6\n13 9\n10 7 1\n7 8\n11 3 5\n</pre>",
    "tip": "Northeastern Europe 1997",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "718",
    "category": "4.6算法之贪心",
    "title": "718:Integer Intervals",
    "description": "An integer interval [a,b], a < b, is a set of all consecutive integers beginning with a and ending with b. <br>Write a program that: finds the minimal number of elements in a set containing at least two different integers from each interval.",
    "img": "",
    "inputTip": "The first line of the input contains the number of intervals n, 1 <= n <= 10000. Each of the following n lines contains two integers a, b separated by a single space, 0 <= a < b <= 10000. They are the beginning and the end of an interval. ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "Output the minimal number of elements in a set containing at least two different integers from each interval. ",
    "inputExample": "<pre>4\n3 6\n2 4\n0 2\n4 7\n</pre>",
    "outputExample": "<pre>4\n</pre>",
    "tip": "CEOI 1997",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "746",
    "category": "4.6算法之贪心",
    "title": "746:Elevator Stopping Plan",
    "description": "ZSoft Corp. is a software company in GaoKe Hall. And the workers in the hall are very hard-working. But the elevator in that hall always drives them crazy. Why? Because there is only one elevator in GaoKe Hall, while there are hundreds of companies in it. Every morning, people must waste a lot of time waiting for the elevator.Hal, a smart guy in ZSoft, wants to change this situation. He wants to find a way to make the elevator work more effectively. But its not an easy job.<br>There are H floors in GaoKe Hall. It takes 4 seconds for the elevator to raise one floor. It means:It costs (n-1)*4seconds if the elevator goes from the 1 st floor to the nth floor without stop. And the elevator stops 10 second once. So, if the elevator stops at each floor, it will cost (n-1)*4+(n-2)*10seconds (It is not necessary to calculate the stopping time at nth floor). In another way, it takes 20 seconds for the workers to go up or down one floor. It takes (n-1)*20seconds for them to walk from the 1 st floor to the nth floor. Obviously, it is not a good idea. So some people choose to use the elevator to get a floor which is the nearest to their office.<br>After thinking over for a long time, Hal finally found a way to improve this situation. He told the elevator man his idea: First, the elevator man asks the people which floors they want to go. He will then design a stopping plan which minimize the time the last person need to arrive the floor where his office locates. For example, if the elevator is required to stop at the 4 th , 5 th and 10 th floor, the stopping plan would be: the elevator stops at 4 th and 10 th floor. Because the elevator will arrive 4 th floor at 3*4=12second, then it will stop 10 seconds, then it will arrive 10 th floor at 3*4+10+6*4=46second. People who want to go 4 th floor will reach their office at 12<br>second, people who want to go to 5 th floor will reach at 12+20=32second and people who want to go to 10 th floor will reach at 46 second. Therefore it takes 46 seconds for the last person to reach his office. It is a good deal for all people.<br>Now, you are supposed to write a program to help the elevator man to design the stopping plan,which minimize the time the last person needs to arrive at his floor.<br>",
    "img": "",
    "inputTip": "The input consists of several test cases. Each test case is in a single line as the following:n f1 f2 ... fnIt means, there are totally n floors at which the elevator need to stop, and n = 0 means no testcases any more. f1 f2 ... fn are the floors at which the elevator is to be stopped (1<=n<=30000, 2<=f1< f2 ... fn<=30000). Every number is separated by a single space.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each testcase, output the time the last reading person needs in the a single line",
    "inputExample": "<pre>3 4 5 10\n1 2\n0\n</pre>",
    "outputExample": "<pre>46\n4\n</pre>",
    "tip": "LouTiancheng@POJ",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "8469",
    "category": "4.6算法之贪心",
    "title": "8469:特殊密码锁",
    "description": "<p>有一种特殊的二进制密码锁，由n个相连的按钮组成（n<30），按钮有凹/凸两种状态，用手按按钮会改变其状态。</p><p>然而让人头疼的是，当你按一个按钮时，跟它相邻的两个按钮状态也会反转。当然，如果你按的是最左或者最右边的按钮，该按钮只会影响到跟它相邻的一个按钮。</p><p>当前密码锁状态已知，需要解决的问题是，你至少需要按多少次按钮，才能将密码锁转变为所期望的目标状态。<br></p>",
    "img": "",
    "inputTip": "两行，给出两个由0、1组成的等长字符串，表示当前/目标密码锁状态，其中0代表凹，1代表凸。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "至少需要进行的按按钮操作次数，如果无法实现转变，则输出impossible。",
    "inputExample": "<pre>011\n000</pre>",
    "outputExample": "<pre>1</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "1024kB"
  }
]