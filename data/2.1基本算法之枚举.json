[
  {
    "id": "15",
    "category": "2.1基本算法之枚举",
    "title": "15:Counterfeit Dollar",
    "description": "Sally Jones has a dozen Voyageur silver dollars. However, only eleven of the coins are true silver dollars; one coin is counterfeit even though its color and size make it indistinguishable from the real silver dollars. The counterfeit coin has a different weight from the other coins but Sally does not know if it is heavier or lighter than the real coins. <br>Happily, Sally has a friend who loans her a very accurate balance scale. The friend will permit Sally three weighings to find the counterfeit coin. For instance, if Sally weighs two coins against each other and the scales balance then she knows these two coins are true. Now if Sally weighs <br>one of the true coins against a third coin and the scales do not balance then Sally knows the third coin is counterfeit and she can tell whether it is light or heavy depending on whether the balance on which it is placed goes up or down, respectively. <br>By choosing her weighings carefully, Sally is able to ensure that she will find the counterfeit coin with exactly three weighings. ",
    "img": "",
    "inputTip": "The first line of input is an integer n (n > 0) specifying the number of cases to follow. Each case consists of three lines of input, one for each weighing. Sally has identified each of the coins with the letters A--L. Information on a weighing will be given by two strings of letters and then one of the words ``up'', ``down'', or ``even''. The first string of letters will represent the coins on the left balance; the second string, the coins on the right balance. (Sally will always place the same number of coins on the right balance as on the left balance.) The word in the third position will tell whether the right side of the balance goes up, down, or remains even. ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each case, the output will identify the counterfeit coin by its letter and tell whether it is heavy or light. The solution will always be uniquely determined. ",
    "inputExample": "<pre>1 \nABCD EFGH even \nABCI EFJK up \nABIJ EFGH even </pre>",
    "outputExample": "<pre>K is the counterfeit coin and it is light. </pre>",
    "tip": "East Central North America 1998",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1661",
    "category": "2.1基本算法之枚举",
    "title": "1661:Bomb Game",
    "description": "Bosko and Susko are playing an interesting game on a board made of rectangular fields arranged in A rows and B columns.<br><br>When the game starts, Susko puts its virtual pillbox in one field one the board. Then Bosko selects fields on which he will throw his virtual bombs. After each bomb, Susko will tell Bosko whether his pillbox is in the range of this bomb or not.<br><br>The range of a bomb with diameter P (P is always odd), which is thrown in field (R, S), is a square area. The center of the square is in the field (R, S), and the side of the square is parallel to the sides of the board and with length P.<br><br>After some bombs have been thrown, Bosko should find out the position of Susko's pillbox. However, the position may be not unique, and your job is to help Bosko to calculate the number of possible positions.",
    "img": "",
    "inputTip": "First line of input contains three integers: A, B and K, 1 <= A, B, K <=100. A represents the number of rows, B the number of columns and K the number of thrown bombs.Each of the next K lines contains integers R, S, P and T, describing a bomb thrown in the field at R-th row and S-th column with diameter P, 1 <= R <= A, 1 <= S <= B, 1 <= P <= 99, P is odd. If the pillbox is in the range of this bomb, T equals to 1; otherwise it is 0.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "Output the number of possible fields, which Susko's pillbox may stay in.",
    "inputExample": "<pre>5 5 3\n3 3 3 1\n3 4 1 0\n3 4 3 1\n</pre>",
    "outputExample": "<pre>5</pre>",
    "tip": "Croatia OI 2002 National – Juniors",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1749",
    "category": "2.1基本算法之枚举",
    "title": "1749:数字方格",
    "description": "<p><img src=\"http://media.openjudge.cn/images/2747_1.jpg\"><br>如上图，有3个方格，每个方格里面都有一个整数a1，a2，a3。已知0 <= a1, a2, a3 <= n，而且a1 + a2是2的倍数，a2 + a3是3的倍数， a1 + a2 + a3是5的倍数。你的任务是找到一组a1，a2，a3，使得a1 + a2 + a3最大。<br></p>",
    "img": "",
    "inputTip": "一行，包含一个整数n (0 <= n <= 100)。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个整数，即a1 + a2 + a3的最大值。",
    "inputExample": "<pre>3\n</pre>",
    "outputExample": "<pre>5\n</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1752",
    "category": "2.1基本算法之枚举",
    "title": "1752:鸡兔同笼",
    "description": "<p>一个笼子里面关了鸡和兔子（鸡有2只脚，兔子有4只脚，没有例外）。已经知道了笼子里面脚的总数a，问笼子里面至少有多少只动物，至多有多少只动物。</p>",
    "img": "",
    "inputTip": "一行，一个正整数a (a < 32768)。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一行，包含两个正整数，第一个是最少的动物数，第二个是最多的动物数，两个正整数用一个空格分开。如果没有满足要求的答案，则输出两个0，中间用一个空格分开。",
    "inputExample": "<pre>20\n</pre>",
    "outputExample": "<pre>5 10\n</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1809",
    "category": "2.1基本算法之枚举",
    "title": "1809:两倍",
    "description": "<p>给定2到15个不同的正整数，你的任务是计算这些数里面有多少个数对满足：数对中一个数是另一个数的两倍。<br><br>比如给定1 4 3 2 9 7 18 22，得到的答案是3，因为2是1的两倍，4是2个两倍，18是9的两倍。<br></p>",
    "img": "",
    "inputTip": "一行，给出2到15个两两不同且小于100的正整数。最后用0表示输入结束。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个整数，即有多少个数对满足其中一个数是另一个数的两倍。",
    "inputExample": "<pre>1 4 3 2 9 7 18 22 0\n</pre>",
    "outputExample": "<pre>3\n</pre>",
    "tip": "翻译自Mid-Central USA 2003的试题",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1812",
    "category": "2.1基本算法之枚举",
    "title": "1812:完美立方",
    "description": "<p>形如a<sup>3</sup>= b<sup>3</sup> + c<sup>3</sup> + d<sup>3</sup>的等式被称为完美立方等式。例如12<sup>3</sup>= 6<sup>3</sup> + 8<sup>3</sup> + 10<sup>3</sup> 。编写一个程序，对任给的正整数N (N≤100)，寻找所有的四元组(a, b, c, d)，使得<span style=\"white-space: normal;\">a</span><sup style=\"white-space: normal;\">3</sup><span style=\"white-space: normal;\"> = b</span><sup style=\"white-space: normal;\">3</sup><span style=\"white-space: normal;\"> + c</span><sup style=\"white-space: normal;\">3</sup><span style=\"white-space: normal;\"> + d</span><sup style=\"white-space: normal;\">3</sup>，其中a,b,c,d 大于 1, 小于等于N，且b<=c<=d。</p>",
    "img": "",
    "inputTip": "一个正整数N (N≤100)。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "每行输出一个完美立方。输出格式为：Cube = a, Triple = (b,c,d)其中a,b,c,d所在位置分别用实际求出四元组值代入。请按照a的值，从小到大依次输出。当两个完美立方等式中a的值相同，则b值小的优先输出、仍相同则c值小的优先输出、再相同则d值小的先输出。",
    "inputExample": "<pre>24</pre>",
    "outputExample": "<pre>Cube = 6, Triple = (3,4,5)\nCube = 12, Triple = (6,8,10)\nCube = 18, Triple = (2,12,16)\nCube = 18, Triple = (9,12,15)\nCube = 19, Triple = (3,10,18)\nCube = 20, Triple = (7,14,17)\nCube = 24, Triple = (12,16,20)</pre>",
    "tip": "1543",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1813",
    "category": "2.1基本算法之枚举",
    "title": "1813:熄灯问题",
    "description": "<p>有一个由按钮组成的矩阵，其中每行有6个按钮，共5行。每个按钮的位置上有一盏灯。当按下一个按钮后，该按钮以及周围位置(上边、下边、左边、右边)的灯都会改变一次。即，如果灯原来是点亮的，就会被熄灭；如果灯原来是熄灭的，则会被点亮。在矩阵角上的按钮改变3盏灯的状态；在矩阵边上的按钮改变4盏灯的状态；其他的按钮改变5盏灯的状态。<br><br><img src=\"http://media.openjudge.cn/images/2811_1.jpg\">在上图中，左边矩阵中用X标记的按钮表示被按下，右边的矩阵表示灯状态的改变。对矩阵中的每盏灯设置一个初始状态。请你按按钮，直至每一盏等都熄灭。与一盏灯毗邻的多个按钮被按下时，一个操作会抵消另一次操作的结果。在下图中，第2行第3、5列的按钮都被按下，因此第2行、第4列的灯的状态就不改变。<br><br><img src=\"http://media.openjudge.cn/images/2811_2.jpg\">请你写一个程序，确定需要按下哪些按钮，恰好使得所有的灯都熄灭。根据上面的规则，我们知道1）第2次按下同一个按钮时，将抵消第1次按下时所产生的结果。因此，每个按钮最多只需要按下一次；2）各个按钮被按下的顺序对最终的结果没有影响；3）对第1行中每盏点亮的灯，按下第2行对应的按钮，就可以熄灭第1行的全部灯。如此重复下去，可以熄灭第1、2、3、4行的全部灯。同样，按下第1、2、3、4、5列的按钮，可以熄灭前5列的灯。<br><br><br></p>",
    "img": "",
    "inputTip": "5行组成，每一行包括6个数字（0或1）。相邻两个数字之间用单个空格隔开。0表示灯的初始状态是熄灭的，1表示灯的初始状态是点亮的。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "5行组成，每一行包括6个数字（0或1）。相邻两个数字之间用单个空格隔开。其中的1表示需要把对应的按钮按下，0则表示不需要按对应的按钮。",
    "inputExample": "<pre>0 1 1 0 1 0\n1 0 0 1 1 1\n0 0 1 0 0 1\n1 0 0 1 0 1\n0 1 1 1 0 0</pre>",
    "outputExample": "<pre>1 0 1 0 0 1\n1 1 0 1 0 1\n0 0 1 0 1 1\n1 0 0 1 0 0\n0 1 0 0 0 0</pre>",
    "tip": "1222",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1815",
    "category": "2.1基本算法之枚举",
    "title": "1815:画家问题",
    "description": "<p>有一个正方形的墙，由N*N个正方形的砖组成，其中一些砖是白色的，另外一些砖是黄色的。Bob是个画家，想把全部的砖都涂成黄色。但他的画笔不好使。当他用画笔涂画第(i, j)个位置的砖时， 位置(i-1, j)、 (i+1, j)、 (i, j-1)、 (i, j+1)上的砖都会改变颜色。请你帮助Bob计算出最少需要涂画多少块砖，才能使所有砖的颜色都变成黄色。<br></p><center><img src=\"http://media.openjudge.cn/images/2813_1.jpg\"></center>",
    "img": "",
    "inputTip": "第一行是一个整数n (1≤n ≤15)，表示墙的大小。接下来的n行表示墙的初始状态。每一行包含n个字符。第i行的第j个字符表示位于位置(i,j)上的砖的颜色。“w”表示白砖，“y”表示黄砖。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一行，如果Bob能够将所有的砖都涂成黄色，则输出最少需要涂画的砖数，否则输出“inf”。",
    "inputExample": "<pre>5\nwwwww\nwwwww\nwwwww\nwwwww\nwwwww</pre>",
    "outputExample": "<pre>15 </pre>",
    "tip": "1681",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1816",
    "category": "2.1基本算法之枚举",
    "title": "1816:拨钟问题",
    "description": "<p>有9个时钟，排成一个3*3的矩阵。<br></p><center><pre style=\"overflow-x: auto;\">|-------|    |-------|    |-------|<br>|       |    |       |    |   |   |<br>|---O   |    |---O   |    |   O   |<br>|       |    |       |    |       |<br>|-------|    |-------|    |-------|<br>    A            B            C    <br><br>|-------|    |-------|    |-------|<br>|       |    |       |    |       |<br>|   O   |    |   O   |    |   O   |<br>|   |   |    |   |   |    |   |   |<br>|-------|    |-------|    |-------|<br>    D            E            F    <br><br>|-------|    |-------|    |-------|<br>|       |    |       |    |       |<br>|   O   |    |   O---|    |   O   |<br>|   |   |    |       |    |   |   |<br>|-------|    |-------|    |-------|<br>    G            H            I    <br>(图 1)</pre></center><p>现在需要用最少的移动，将9个时钟的指针都拨到12点的位置。共允许有9种不同的移动。如下表所示，每个移动会将若干个时钟的指针沿顺时针方向拨动90度。<br><br>\t<br></p><pre style=\"overflow-x: auto;\">移动    影响的时钟<br> <br> 1         ABDE<br> 2         ABC<br> 3         BCEF<br> 4         ADG<br> 5         BDEFH<br> 6         CFI<br> 7         DEGH<br> 8         GHI<br> 9         EFHI    <br></pre><p></p>",
    "img": "",
    "inputTip": "9个整数，表示各时钟指针的起始位置，相邻两个整数之间用单个空格隔开。其中，0=12点、1=3点、2=6点、3=9点。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出一个最短的移动序列，使得9个时钟的指针都指向12点。按照移动的序号从小到大输出结果。相邻两个整数之间用单个空格隔开。",
    "inputExample": "<pre>3 3 0 \n2 2 2 \n2 1 2 </pre>",
    "outputExample": "<pre>4 5 8 9 </pre>",
    "tip": "1166",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1943",
    "category": "2.1基本算法之枚举",
    "title": "1943:满足条件的整数",
    "description": "<p>假设a、b、c均为整数，且满足a，b，c 大于1，并且小于等于100，找出所有符合条件：“a<sup>2</sup>+ b<sup><span style=\"font-size: 13px\">2</span></sup>= c<sup>2</sup>”的整数组。</p>",
    "img": "",
    "inputTip": "无。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "按a从小到大的顺序输出所有满足条件的整数组（若a相同，则按b从小到大的顺序输出），每行一组，每一组数据的输出样式为： a*a + b*b = c*c注意：1）为避免重复输出，要求a<=b；2）加号和等号左右各有一个空格，除此之外无多余空格。",
    "inputExample": "<pre></pre>",
    "outputExample": "<pre></pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1973",
    "category": "2.1基本算法之枚举",
    "title": "1973:确定进制",
    "description": "<p>6*9 = 42 对于十进制来说是错误的，但是对于13进制来说是正确的。即, 6(13) * 9(13) = 42(13)， 而 42(13) = 4 * 13<sup>1</sup>+ 2 * 13<sup>0</sup>= 54(10)。 你的任务是写一段程序读入三个整数p、q和 r，然后确定一个进制 B(2<=B<=16) 使得 p * q = r. 如果 B有很多选择, 输出最小的一个。例如： p = 11, q = 11, r = 121. 则有 11(3) * 11(3) = 121(3) 因为 11(3) = 1 * 3<sup>1</sup>+ 1 * 3<sup>0</sup>= 4(10) 和 121(3) = 1 * 3<sup>2</sup>+ 2 * 3<sup>1</sup>+ 1 * 3<sup>0</sup>= 16(10)。 对于进制 10,有 11(10) * 11(10) = 121(10)。这种情况下，应该输出 3。如果没有合适的进制，则输出 0。</p>",
    "img": "",
    "inputTip": "一行，包含三个整数p、q、r，相邻两个整数之间用单个空格隔开。 p、q、r的所有位都是数字，并且1 <= p、q、r <= 1,000,000。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个整数：即使得p * q = r成立的最小的B。如果没有合适的B，则输出 0。",
    "inputExample": "<pre>6 9 42</pre>",
    "outputExample": "<pre>13\n</pre>",
    "tip": "Taejon 2002, POJ 1331, 程序设计实习07",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1978",
    "category": "2.1基本算法之枚举",
    "title": "1978:生理周期",
    "description": "<p>人生来就有三个生理周期，分别为体力、感情和智力周期，它们的周期长度为23天、28天和33天。每一个周期中有一天是高峰。在高峰这天，人会在相应的方面表现出色。例如，智力周期的高峰，人会思维敏捷，精力容易高度集中。因为三个周期的周长不同，所以通常三个周期的高峰不会落在同一天。对于每个人，我们想知道何时三个高峰落在同一天。对于每个周期，我们会给出从当前年份的第一天开始，到出现高峰的天数（不一定是第一次高峰出现的时间）。你的任务是给定一个从当年第一天开始数的天数，输出从给定时间开始（不包括给定时间）下一次三个高峰落在同一天的时间（距给定时间的天数）。例如：给定时间为10，下次出现三个高峰同天的时间是12，则输出2（注意这里不是3）。</p>",
    "img": "",
    "inputTip": "一行，包含四个整数：p, e, i和d，相邻两个整数之间用单个空格隔开。 p, e, i分别表示体力、情感和智力高峰出现的时间（时间从当年的第一天开始计算）。d 是给定的时间，可能小于p, e, 或 i。 所有给定时间是非负的并且小于等于365, 所求的时间小于等于21252。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个整数，即从给定时间起，下一次三个高峰同天的时间（距离给定时间的天数）。",
    "inputExample": "<pre>4 5 6 7</pre>",
    "outputExample": "<pre>16994</pre>",
    "tip": "East Central North America 1999, POJ 1006， 程序设计实习2007",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2472",
    "category": "2.1基本算法之枚举",
    "title": "2472:子串计算",
    "description": "<p>给出一个只包含0和1的字符串（长度在1到100之间），求其每一个子串出现的次数。</p>",
    "img": "",
    "inputTip": "一行，一个01字符串。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对所有出现次数在1次以上的子串，输出该子串及出现次数，中间用单个空格隔开。按子串的字典序从小到大依次输出，每行一个。",
    "inputExample": "<pre>10101</pre>",
    "outputExample": "<pre>0 2\n01 2\n1 3\n10 2\n101 2</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "250",
    "category": "2.1基本算法之枚举",
    "title": "250:Safecracker",
    "description": "<p>\"The item is locked in a Klein safe behind a painting in the second-floor library. Klein safes are extremely rare; most of them, along with Klein and his factory, were destroyed in World War II. Fortunately old Brumbaugh from research knew Klein's secrets and wrote them down before he died. A Klein safe has two distinguishing features: a combination lock that uses letters instead of numbers, and an engraved quotation on the door. A Klein quotation always contains between five and twelve distinct uppercase letters, usually at the beginning of sentences, and mentions one or more numbers. Five of the uppercase letters form the combination that opens the safe. By combining the digits from all the numbers in the appropriate way you get a numeric target. (The details of constructing the target number are classified.) To find the combination you must select five letters v, w, x, y, and z that satisfy the following equation, where each letter is replaced by its ordinal position in the alphabet (A=1, B=2, ..., Z=26). The combination is then vwxyz. If there is more than one solution then the combination is the one that is lexicographically greatest, i.e., the one that would appear last in a dictionary.\" <br><br>v - w<sup>2</sup>+ x<sup>3</sup>- y<sup>4</sup>+ z<sup>5</sup>= target <br><br>\"For example, given target 1 and letter set ABCDEFGHIJKL, one possible solution is FIECB, since 6 - 9<sup>2</sup>+ 5<sup>3</sup>- 3<sup>4</sup>+ 2<sup>5</sup>= 1. There are actually several solutions in this case, and the combination turns out to be LKEBA. Klein thought it was safe to encode the combination within the engraving, because it could take months of effort to try all the possibilities even if you knew the secret. But of course computers didn't exist then.\" <br><br><br>\"Develop a program to find Klein combinations in preparation for field deployment. Use standard test methodology as per departmental regulations. <br><br></p>",
    "img": "",
    "inputTip": "Input consists of one or more lines containing a positive integer target less than twelve million, a space, then at least five and at most twelve distinct uppercase letters. The last line will contain a target of zero and the letters END; this signals the end of the input.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each line output the unique Klein combination, or 'no solution' if there is no correct combination. Use the exact format shown below.\"",
    "inputExample": "<pre>1 ABCDEFGHIJKL\n11700519 ZAYEXIWOVU\n3072997 SOUGHT\n1234567 THEQUICKFROG\n0 END</pre>",
    "outputExample": "<pre>LKEBA\nYOXUZ\nGHOST\nno solution</pre>",
    "tip": "Mid-Central USA 2002",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2673",
    "category": "2.1基本算法之枚举",
    "title": "2673:比赛排名",
    "description": "<p>5名运动员参加100米赛跑，各自对比赛结果进行了预测：<br>A说：E是第1名。<br>B说：我是第2名。<br>C说：A肯定垫底。<br>D说：C肯定拿不了第1名。<br>E说：D应该是第1名。<br>比赛结束后发现，只有获第1名和第2名的选手猜对了，E不是第2名和第3名，没有出现名次并列的情况。<br>请编程判断5位选手各是第几名。<br><br></p>",
    "img": "",
    "inputTip": "无",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出要求：按ABCDE的顺序输出5行，其中第1行是A的名次，第2行是B的名次，第3行是C的名次，第4行是D的名次，第5行是E的名次。",
    "inputExample": "<pre></pre>",
    "outputExample": "<pre></pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2722",
    "category": "2.1基本算法之枚举",
    "title": "2722:和数",
    "description": "<p>给定一个正整数序列，判断其中有多少个数，等于数列中其他两个数的和。 比如，对于数列1 2 3 4, 这个问题的答案就是2, 因为3 = 2 + 1, 4 = 1 + 3。</p>",
    "img": "",
    "inputTip": "共两行，第一行是数列中数的个数n ( 1 <= n <= 100)，第二行是由n个不大于10000的正整数组成的数列，相邻两个整数之间用单个空格隔开。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个整数，即数列中等于其他两个数之和的数的个数。",
    "inputExample": "<pre>4\n1 2 3 4</pre>",
    "outputExample": "<pre>2\n</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2723",
    "category": "2.1基本算法之枚举",
    "title": "2723:因子问题",
    "description": "<p>任给两个正整数N、M，求一个最小的正整数a，使得a和(M-a)都是N的因子。</p>",
    "img": "",
    "inputTip": "包括两个整数N、M。N不超过1,000,000。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出一个整数a，表示结果。如果某个案例中满足条件的正整数不存在，则在对应行输出-1",
    "inputExample": "<pre>35 10\n</pre>",
    "outputExample": "<pre>5\n</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2983",
    "category": "2.1基本算法之枚举",
    "title": "2983:谁是你的潜在朋友",
    "description": "“臭味相投”——这是我们描述朋友时喜欢用的词汇。两个人是朋友通常意味着他们存在着许多共同的兴趣。然而作为一个宅男，你发现自己与他人相互了解的机会并不太多。幸运的是，你意外得到了一份北大图书馆的图书借阅记录，于是你挑灯熬夜地编程，想从中发现潜在的朋友。<br>首先你对借阅记录进行了一番整理，把N个读者依次编号为1,2,…,N，把M本书依次编号为1,2,…,M。同时，按照“臭味相投”的原则，和你喜欢读同一本书的人，就是你的潜在朋友。你现在的任务是从这份借阅记录中计算出每个人有几个潜在朋友。",
    "img": "",
    "inputTip": "第一行两个整数N,M，2 <= N ，M<= 200。接下来有N行，第i(i = 1,2,…,N)行每一行有一个数，表示读者i-1最喜欢的图书的编号P(1<=P<=M)",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "包括N行，每行一个数，第i行的数表示读者i有几个潜在朋友。如果i和任何人都没有共同喜欢的书，则输出“BeiJu”（即悲剧，^ ^）",
    "inputExample": "<pre>4  5\n2\n3\n2\n1</pre>",
    "outputExample": "<pre>1\nBeiJu\n1\nBeiJu</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "3526",
    "category": "2.1基本算法之枚举",
    "title": "3526:最简真分数",
    "description": "<p>给出n个正整数，任取两个数分别作为分子和分母组成最简真分数，编程求共有几个这样的组合。</p>",
    "img": "",
    "inputTip": "第一行是一个正整数n（n<=600）。第二行是n个不同的整数，相邻两个整数之间用单个空格隔开。整数大于1且小于等于1000。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个整数，即最简真分数组合的个数。",
    "inputExample": "<pre>7\n3 5 7 9 11 13 15\n</pre>",
    "outputExample": "<pre>17\n</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "6184",
    "category": "2.1基本算法之枚举",
    "title": "6184:找和为K的两个元素",
    "description": "<p>在一个长度为n(n < 1000)的整数序列中，判断是否存在某两个元素之和为k。<br></p>",
    "img": "",
    "inputTip": "第一行输入序列的长度n和k，用空格分开。第二行输入序列中的n个整数，用空格分开。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "如果存在某两个元素的和为k，则输出yes，否则输出no。",
    "inputExample": "<pre>9 10\n1 2 3 4 5 6 7 8 9</pre>",
    "outputExample": "<pre>yes</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "6187",
    "category": "2.1基本算法之枚举",
    "title": "6187:称体重",
    "description": "<p>赵、钱、孙、李四个人中既有大人也有小孩，给他们称体重时发现，他们每个人的体重都不一样，且体重（单位：公斤）恰好是10的整数倍，且他们的体重都不高\n于50公斤，已知赵、钱两人的体重之和恰好等于孙、李两人的体重之和；赵、李两人的体重之和大于孙、钱两人的体重之和，并且赵、孙俩人的体重之和还小于钱的体重。请编写一个程序，按照体重从小到大的顺序，打印出四人的姓氏的首字母和体重数。<br></p>",
    "img": "",
    "inputTip": "无",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "打印出四人的姓氏的首字母（小写）和体重数（每人一行，姓名首字母和体重数之间用空格隔开）。",
    "inputExample": "<pre>无</pre>",
    "outputExample": "<pre>z 10\nq 20\ns 30\nl 40\n（以上输出仅用于说明格式）</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "6188",
    "category": "2.1基本算法之枚举",
    "title": "6188:比饭量",
    "description": "<p>3个人比饭量，每人说了两句话：\n<br>A说：B比我吃的多，C和我吃的一样多\n<br>B说：A比我吃的多，A也比C吃的多\n<br>C说：我比B吃得多，B比A吃的多。\n<br>事实上，饭量和正确断言的个数是反序的关系。\n<br>请编程按饭量的大小输出3个人的顺序。<br></p>",
    "img": "",
    "inputTip": "无输入",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "按照饭量大小输出3人顺序，比如：ABC",
    "inputExample": "<pre>无</pre>",
    "outputExample": "<pre>无</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7213",
    "category": "2.1基本算法之枚举",
    "title": "7213:垃圾炸弹",
    "description": "<p class=\"MsoNormal\" style=\"\"><span style=\"font-family:'Times New Roman','serif'\">    2014</span><span style=\"font-family:宋体\">年巴西世界杯（</span><span style=\"font-family:'Times New Roman','serif'\">2014 FIFA World Cup</span><span style=\"font-family:宋体\">）开踢啦！为了方便球迷观看比赛，里约街道上很多路口都放置了的直播大屏幕，但是人群散去后总会在这些路口留下一堆垃圾。为此巴西政府决定动用一种最新发明</span><span style=\"font-family:'Times New Roman','serif'\">——</span><span style=\"font-family:宋体\">“垃圾炸弹”。这种“炸弹”利用最先进的量子物理技术，爆炸后产生的冲击波可以完全清除波及范围内的所有垃圾，并且不会产生任何其他不良影响。炸弹爆炸后冲击波是以正方形方式扩散的，炸弹威力（扩散距离）以</span><span style=\"font-family:'Times New Roman','serif'\">d</span><span style=\"font-family:宋体\">给出，表示可以传播</span><span style=\"font-family:'Times New Roman','serif'\">d</span><span style=\"font-family:宋体\">条街道。</span></p><p><span style=\"font-size:10.5pt;font-family:宋体\">    例如下图是一个</span><span style=\"font-size:10.5pt;font-family:'Times New Roman','serif'\">d=1</span><span style=\"font-size:10.5pt;font-family:宋体\">的“垃圾炸弹”爆炸后的波及范围。</span></p><p><img src=\"http://media.openjudge.cn/images/upload/1403230629.jpg\" height=\"266\" width=\"439\"></p><p><span style=\"font-size:10.5pt;font-family:宋体\">    假设里约热内卢市的布局为严格的</span><span style=\"font-size:10.5pt;font-family:'Times New Roman','serif'\">1025*1025</span><span style=\"font-size:10.5pt;font-family:宋体\">的网格状，由于财政问题市政府只买得起一枚“垃圾炸弹”，希望你帮他们找到合适的投放地点，使得一次清除的垃圾总量最多（假设垃圾数量可以用一个非负整数表示，并且除设置大屏幕的路口以外的地点没有垃圾）。</span><br></p>",
    "img": "",
    "inputTip": "第一行给出“炸弹”威力d(1 <= d <= 50)。第二行给出一个数组n(1 <= n <= 20)表示设置了大屏幕(有垃圾)的路口数目。接下来n行每行给出三个数字x, y, i, 分别代表路口的坐标(x, y)以及垃圾数量i. 点坐标(x, y)保证是有效的（区间在0到1024之间），同一坐标只会给出一次。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出能清理垃圾最多的投放点数目，以及能够清除的垃圾总量。",
    "inputExample": "<pre>1\n2\n4 4 10\n6 6 20</pre>",
    "outputExample": "<pre>1 30</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7216",
    "category": "2.1基本算法之枚举",
    "title": "7216:Minecraft",
    "description": "<p><span style=\"font-size:10.5pt;font-family:'Times New Roman','serif'\">Minecraft</span><span style=\"font-size:10.5pt;font-family:宋体\">是一个几乎无所不能的沙盒游戏，玩家可以利用游戏内的各种资源进行创造，搭建自己的世界。</span></p><p><img src=\"http://media.openjudge.cn/images/upload/1403231004.png\" height=\"405\" width=\"720\"></p><p class=\"MsoNormal\"><span style=\"font-family:宋体\">在</span><span style=\"font-family:'Times New Roman','serif'\">Minecraft</span><span style=\"font-family:宋体\">中，基本的建筑元素是边长为</span><span style=\"font-family:'Times New Roman','serif'\">1</span><span style=\"font-family:宋体\">个单位的立方体，</span><span style=\"font-family:'Times New Roman','serif'\">Tony</span><span style=\"font-family:宋体\">想用</span><span style=\"font-family:'Times New Roman','serif'\">N</span><span style=\"font-family:宋体\">个这种小立方体搭建一个长方体，并用他珍藏已久的贴纸对其进行装饰。如果一张贴纸可以贴满小立方体的一个面。那么，他需要用掉多少张贴纸呢？</span></p>",
    "img": "",
    "inputTip": "一个整数N，表示小明所拥有的小立方体的个数。N不会超过1000。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个整数，即小明最少用掉的贴纸有多少张。",
    "inputExample": "<pre>9</pre>",
    "outputExample": "<pre>30</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7217",
    "category": "2.1基本算法之枚举",
    "title": "7217:猴子吃桃",
    "description": "<p>    海滩上有一堆桃子，N只猴子来分。第一只猴子把这堆桃子平均分为N份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子接着把剩下的桃子平均分成N份，又多了一个，它同样把多的一个扔入海中，拿走了一份。第三、第四、……，第N只猴子仍是最终剩下的桃子分成N份，扔掉多了的一个，并拿走一份。<br>    编写程序，输入猴子的数量N，输出海滩上最少的桃子数，使得每只猴子都可吃到桃子。<br><br></p>",
    "img": "",
    "inputTip": "一个整数N。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出当猴子数量为N时海滩上最少的桃子数。结果保证在int型范围内。",
    "inputExample": "<pre>2</pre>",
    "outputExample": "<pre>7</pre>",
    "tip": "",
    "timeLimited": "3000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "755",
    "category": "2.1基本算法之枚举",
    "title": "755:Flip Game",
    "description": "Flip game is played on a rectangular 4x4 field with two-sided pieces placed on each of its 16 squares. One side of each piece is white and the other one is black and each piece is lying either it's black or white side up. Each round you flip 3 to 5 pieces, thus changing the color of their upper side from black to white and vice versa. The pieces to be flipped are chosen every round according to the following rules:<br><ol><li>Choose any one of the 16 pieces. <br></li><li>Flip the chosen piece and also all adjacent pieces to the left, to the right, to the top, and to the bottom of the chosen piece (if there are any).</li></ol> <br><img src=\"http://media.openjudge.cn/images/g755/1753_1.jpg\" align=\"right\">Consider the following position as an example:<br><br>bwbw<br>wwww<br>bbwb<br>bwwb<br>Here \"b\" denotes pieces lying their black side up and \"w\" denotes pieces lying their white side up. If we choose to flip the 1st piece from the 3rd row (this choice is shown at the picture), then the field will become:<br><br>bwbw<br>bwww<br>wwwb<br>wwwb<br>The goal of the game is to flip either all pieces white side up or all pieces black side up. You are to write a program that will search for the minimum number of rounds needed to achieve this goal.",
    "img": "",
    "inputTip": "The input consists of 4 lines with 4 characters \"w\" or \"b\" each that denote game field position.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "Write to the output file a single integer number - the minimum number of rounds needed to achieve the goal of the game from the given position. If the goal is initially achieved, then write 0. If it's impossible to achieve the goal, then write the word \"Impossible\" (without quotes).",
    "inputExample": "<pre>bwwb\nbbwb\nbwwb\nbwww</pre>",
    "outputExample": "<pre>4\n</pre>",
    "tip": "Northeastern Europe 2000",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7621",
    "category": "2.1基本算法之枚举",
    "title": "7621:硬币面值组合",
    "description": "<p>使用1角、2角、5角硬币组成 n 角钱。 </p><p>设1角、2角、5角的硬币各用了a、b、c个，列出所有可能的a, b, c组合。 </p><p>输出顺序为：先按c的值从小到大，若c相同则按b的值从小到大。<br></p>",
    "img": "",
    "inputTip": "一个整数n（1 <= n <= 100)，代表需要组成的钱的角数。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出有若干行，每行的形式为：i           a           b           c第1列i代表当前行数（行数从001开始，固定3个字符宽度，宽度不足3的用0填充），后面3列a, b, c分别代表1角、2角、5角硬币的个数（每个数字固定12个字符宽度，宽度不足的在左边填充空格）。",
    "inputExample": "<pre>10</pre>",
    "outputExample": "<pre>001          10           0           0\n002           8           1           0\n003           6           2           0\n004           4           3           0\n005           2           4           0\n006           0           5           0\n007           5           0           1\n008           3           1           1\n009           1           2           1\n010           0           0           2</pre>",
    "tip": "习题(15-2)",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7623",
    "category": "2.1基本算法之枚举",
    "title": "7623:五户共井问题",
    "description": "<p>有A, B, C, D, E五家人共用一口井，已知井深不超过k米。A, B, C, D, E的绳长各不相同，而且厘米表示的绳长一定是整数。\n<br>从井口放下绳索正好达到水面时：\n<br>(a)需要A家的绳n1条接上B家的绳1条\n<br>(b)需要B家的绳n2条接上C家的绳1条\n<br>(c)需要C家的绳n3条接上D家的绳1条\n<br>(d)需要D家的绳n4条接上E家的绳1条\n<br>(e)需要E家的绳n5条接上A家的绳1条\n<br>问井深和各家绳长。<br></p>",
    "img": "",
    "inputTip": "输入只有1行。包括空格分开的6个整数。第一个整数k（1 <= k <= 20)，代表井的最大深度（单位：米）。接下来是5个正整数n1, n2, n3, n4, n5。这五个整数的含义见上面的题目描述。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出只有1行。如果找到了可行解，就输出6个整数，用空格分开，分别代表井的深度和A, B, C, D, E的绳长（单位都是厘米）。如果有多组可行解，输出井的深度最小的那组解。如果不存在可行解，就输出一行：not found",
    "inputExample": "<pre>10 2 3 4 5 6</pre>",
    "outputExample": "<pre>721 265 191 148 129 76</pre>",
    "tip": "习题(15-5)",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7647",
    "category": "2.1基本算法之枚举",
    "title": "7647:余数相同问题",
    "description": "<p>已知三个正整数 a，b，c。<br></p><p>现有一个大于1的整数x，将其作为除数分别除a，b，c，得到的余数相同。</p><p>请问满足上述条件的x的最小值是多少？</p><p>数据保证x有解。</p>",
    "img": "",
    "inputTip": "一行，三个不大于1000000的正整数a，b，c，两个整数之间用一个空格隔开。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个整数，即满足条件的x的最小值。",
    "inputExample": "<pre>300 262 205</pre>",
    "outputExample": "<pre>19</pre>",
    "tip": "《奥数典型题举一反三（小学六年级）》 (ISBN 978-7-5445-2883-2)  第一章 第一讲 例1",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7649",
    "category": "2.1基本算法之枚举",
    "title": "7649:我家的门牌号",
    "description": "<p>我家住在一条短胡同里，这条胡同的门牌号从1开始顺序编号。</p><p>若所有的门牌号之和减去我家门牌号的两倍，恰好等于n，求我家的门牌号及总共有多少家。<br></p><p>数据保证有唯一解。</p>",
    "img": "",
    "inputTip": "一个正整数n。n < 100000。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一行，包含两个正整数，分别是我家的门牌号及总共有多少家，中间用单个空格隔开。",
    "inputExample": "<pre>100</pre>",
    "outputExample": "<pre>10 15</pre>",
    "tip": "《奥数典型题举一反三（小学六年级）》 (ISBN 978-7-5445-2883-2) 第二章 第七讲 例2 拓展一",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7650",
    "category": "2.1基本算法之枚举",
    "title": "7650:不定方程求解",
    "description": "<p>给定正整数a，b，c。求不定方程 ax+by=c 关于未知数x和y的所有非负整数解组数。<br></p>",
    "img": "",
    "inputTip": "一行，包含三个正整数a，b，c，两个整数之间用单个空格隔开。每个数均不大于1000。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个整数，即不定方程的非负整数解组数。",
    "inputExample": "<pre>2 3 18</pre>",
    "outputExample": "<pre>4</pre>",
    "tip": "《奥数典型题举一反三（小学六年级）》 (ISBN 978-7-5445-2883-2) 第四章 第二讲 例1",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7827",
    "category": "2.1基本算法之枚举",
    "title": "7827:质数的和与积",
    "description": "<p>两个质数的和是S，它们的积最大是多少？</p>",
    "img": "",
    "inputTip": "一个不大于10000的正整数S，为两个质数的和。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个整数，为两个质数的最大乘积。数据保证有解。",
    "inputExample": "<pre>50</pre>",
    "outputExample": "<pre>589</pre>",
    "tip": "《奥数典型题举一反三（小学五年级）》 (ISBN 978-7-5445-2882-5) 第三章 第二讲 例1",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7832",
    "category": "2.1基本算法之枚举",
    "title": "7832:最接近的分数",
    "description": "<p>分母不超过 N 且 小于 A/B 的最大最简分数是多少？</p>",
    "img": "",
    "inputTip": "三个正整数N，A，B，相邻两个数之间用单个空格隔开。1 <= A < B < N <= 1000。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "两个正整数，分别是所求分数的分子和分母，中间用单个空格隔开。",
    "inputExample": "<pre>100 7 13</pre>",
    "outputExample": "<pre>50 93</pre>",
    "tip": "2007年我爱数学少年夏令营数学竞赛 第9题",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "8755",
    "category": "2.1基本算法之枚举",
    "title": "8755:砝码称重",
    "description": "<p>设有1g、2g、3g、5g、10g、20g的砝码各若干枚（其总重<=1000），要求：计算<span style=\"white-space: normal;\">用这些砝码能称出的不同重量的个数，但不包括一个砝码也不用的情况。<!--=1000），要求：计算<span--></span></p>",
    "img": "",
    "inputTip": "一行，包括六个正整数a1,a2,a3,a4,a5,a6，表示1g砝码有a1个，2g砝码有a2个，……，20g砝码有a6个。相邻两个整数之间用单个空格隔开。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "以“Total=N”的形式输出，其中N为可以称出的不同重量的个数。",
    "inputExample": "<pre>1 1 0 0 0 0</pre>",
    "outputExample": "<pre>Total=3</pre>",
    "tip": "样例给出的砝码可以称出1g，2g，3g三种不同的重量。",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "8757",
    "category": "2.1基本算法之枚举",
    "title": "8757:三个三位数",
    "description": "<p>将1，2，…，9共9个数分成三组，分别组成三个三位数，且使这三个三位数构成\n   1:2:3的比例，试求出所有满足条件的三个三位数。</p><p>例如：三个三位数192，384，576满足以上条件。\n</p>",
    "img": "",
    "inputTip": "无。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "每行三个三位数，为满足条件的一种方案。这三个三位数按从小到大的方式给出，相邻两个数之间用单个空格隔开。请按照第一个三位数从小到大的顺序依次输出每种方案。",
    "inputExample": "<pre>无</pre>",
    "outputExample": "<pre>不提供</pre>",
    "tip": "NOIP1998复赛 普及组 第一题",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "8759",
    "category": "2.1基本算法之枚举",
    "title": "8759:火车上的人数",
    "description": "<p>火车从始发站（称为第1站）开出，在始发站上车的人数为a，然后到达第2站，在第2站有人上、下车，但上、下车的人数相同，因此在第2站开出时（即在到达第3站之前）车上的人数保持为a人。从第3站起（包括第3站）上、下车的人数有一定规律：上车的人数都是上两站上车人数之和，而下车人数等于上一站上车人数，一直到终点站的前一站（第n-1站），都满足此规律。现给出的条件是：共有n个车站，始发站上车的人数为a，最后一站下车的人数是m（全部下车）。试问x站开出时车上的人数是多少？</p>",
    "img": "",
    "inputTip": "一行，包含四个整数a，n，m和x，相邻两个整数之间用单个空格隔开。0 <= a <= 10, 3 <= x < n <= 15, 0 <= m <= 10000。题目保证数据有唯一解。允许有人在同一站上下车。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个整数，为从x站开出时车上的人数。",
    "inputExample": "<pre>5 7 32 4</pre>",
    "outputExample": "<pre>13</pre>",
    "tip": "NOIP1998复赛 提高组 第一题",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "8760",
    "category": "2.1基本算法之枚举",
    "title": "8760:Cantor表",
    "description": "<p>现代数学的著名证明之一是Georg Cantor证明了有理数是可枚举的。他是用下面这一张表来证明这一命题的：</p><p style=\"text-align: center;\"><img src=\"http://media.openjudge.cn/images/upload/1444269707.png\" width=\"500\" height=\"145\" style=\"text-align: right;\"></p><p>我们以Z字形给上表的每一项编号。第一项是1/1，然后是1/2，2/1，3/1，2/2，…</p><p>给定N，求第N项。</p>",
    "img": "",
    "inputTip": "一个整数N（1≤N≤10000000）。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个分数，即表中的第N项。",
    "inputExample": "<pre>7</pre>",
    "outputExample": "<pre>1/4</pre>",
    "tip": "NOIP1999复赛 普及组 第一题",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  }
]