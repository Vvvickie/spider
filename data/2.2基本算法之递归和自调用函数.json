[
  {
    "id": "1696",
    "category": "2.2基本算法之递归和自调用函数",
    "title": "1696:逆波兰表达式",
    "description": "逆波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 + 3的逆波兰表示法为+ 2 3。逆波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 + 3) * 4的逆波兰表示法为* + 2 3 4。本题求解逆波兰表达式的值，其中运算符包括+ - * /四个。",
    "img": "",
    "inputTip": "输入为一行，其中运算符和运算数之间都用空格分隔，运算数是浮点数。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出为一行，表达式的值。可直接用printf(\"%f\\n\", v)输出表达式的值v。",
    "inputExample": "<pre>* + 11.0 12.0 + 24.0 35.0</pre>",
    "outputExample": "<pre>1357.000000</pre>",
    "tip": "可使用atof(str)把字符串转换为一个double类型的浮点数。atof定义在math.h中。此题可使用函数递归调用的方法求解。",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1750",
    "category": "2.2基本算法之递归和自调用函数",
    "title": "1750:全排列",
    "description": "<p>给定一个由不同的小写字母组成的字符串，输出这个字符串的所有全排列。 我们假设对于小写字母有'a' < 'b' < ... < 'y' < 'z'，而且给定的字符串中的字母已经按照从小到大的顺序排列。 </p>",
    "img": "",
    "inputTip": "输入只有一行，是一个由不同的小写字母组成的字符串，已知字符串的长度在1到6之间。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出这个字符串的所有排列方式，每行一个排列。要求字母序比较小的排列在前面。字母序如下定义：已知S = s1s2...sk , T = t1t2...tk，则S < T 等价于，存在p (1 <= p <= k)，使得s1 = t1, s2 = t2, ..., sp - 1 = tp - 1, sp < tp成立。",
    "inputExample": "<pre>abc</pre>",
    "outputExample": "<pre>abc\nacb\nbac\nbca\ncab\ncba\n</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1751",
    "category": "2.2基本算法之递归和自调用函数",
    "title": "1751:分解因数",
    "description": "给出一个正整数a，要求分解成若干个正整数的乘积，即a = a1 * a2 * a3 * ... * an，并且1 < a1 <= a2 <= a3 <= ... <= an，问这样的分解的种数有多少。注意到a = a也是一种分解。",
    "img": "",
    "inputTip": "第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数a (1 < a < 32768)",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "n行，每行输出对应一个输入。输出应是一个正整数，指明满足要求的分解的种数",
    "inputExample": "<pre>2\n2\n20\n</pre>",
    "outputExample": "<pre>1\n4\n</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1755",
    "category": "2.2基本算法之递归和自调用函数",
    "title": "1755:菲波那契数列",
    "description": "菲波那契数列是指这样的数列: 数列的第一个和第二个数都为1，接下来每个数都等于前面2个数之和。<br>给出一个正整数a，要求菲波那契数列中第a个数是多少。<br>",
    "img": "",
    "inputTip": "第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数a(1 <= a <= 20)",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出有n行，每行输出对应一个输入。输出应是一个正整数，为菲波那契数列中第a个数的大小",
    "inputExample": "<pre>4\n5\n2\n19\n1\n</pre>",
    "outputExample": "<pre>5\n1\n4181\n1\n</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1777",
    "category": "2.2基本算法之递归和自调用函数",
    "title": "1777:文件结构“图”",
    "description": "<p>在计算机上看到文件系统的结构通常很有用。Microsoft Windows上面的\"explorer\"程序就是这样的一个例子。但是在有图形界面之前，没有图形化的表示方法的，那时候最好的方式是把目录和文件的结构显示成一个\"图\"的样子，而且使用缩排的形式来表示目录的结构。比如：<br><br></p><pre style=\"overflow-x: auto;\">ROOT<br>|     dir1<br>|     file1<br>|     file2<br>|     file3<br>|     dir2<br>|     dir3<br>|     file1<br>file1<br>file2<br></pre><p>这个图说明：ROOT目录包括三个子目录和两个文件。第一个子目录包含3个文件，第二个子目录是空的，第三个子目录包含一个文件。<br></p>",
    "img": "",
    "inputTip": "你的任务是写一个程序读取一些测试数据。每组测试数据表示一个计算机的文件结构。每组测试数据以'*'结尾，而所有合理的输入数据以'#'结尾。一组测试数据包括一些文件和目录的名字（虽然在输入中我们没有给出，但是我们总假设ROOT目录是最外层的目录）。在输入中,以']'表示一个目录的内容的结束。目录名字的第一个字母是'd'，文件名字的第一个字母是'f'。文件名可能有扩展名也可能没有（比如fmyfile.dat和fmyfile）。文件和目录的名字中都不包括空格,长度都不超过30。一个目录下的子目录个数和文件个数之和不超过30。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "在显示一个目录中内容的时候，先显示其中的子目录（如果有的话），然后再显示文件（如果有的话）。文件要求按照名字的字母表的顺序显示（目录不用按照名字的字母表顺序显示，只需要按照目录出现的先后显示）。对每一组测试数据，我们要先输出\"DATA SET x:\"，这里x是测试数据的编号（从1开始）。在两组测试数据之间要输出一个空行来隔开。你需要注意的是，我们使用一个'|'和5个空格来表示出缩排的层次。",
    "inputExample": "<pre>file1\nfile2\ndir3\ndir2\nfile1\nfile2\n]\n]\nfile4\ndir1\n]\nfile3\n*\nfile2\nfile1\n*\n#</pre>",
    "outputExample": "<pre>DATA SET 1:\nROOT\n|     dir3\n|     |     dir2\n|     |     file1\n|     |     file2\n|     dir1\nfile1\nfile2\nfile3\nfile4\n\nDATA SET 2:\nROOT\nfile1\nfile2\n</pre>",
    "tip": "一个目录和它的子目录处于不同的层次一个目录和它的里面的文件处于同一层次",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1788",
    "category": "2.2基本算法之递归和自调用函数",
    "title": "1788:Pell数列",
    "description": "Pell数列a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, ...的定义是这样的，a<sub>1</sub> = 1, a<sub>2</sub> = 2, ... , a<sub>n</sub> = 2 * a<sub>n − 1</sub> + a<sub>n - 2</sub> (n > 2)。<br>给出一个正整数k，要求Pell数列的第k项模上32767是多少。<br>",
    "img": "",
    "inputTip": "第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数k (1 ≤ k < 1000000)。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "n行，每行输出对应一个输入。输出应是一个非负整数。",
    "inputExample": "<pre>2\n1\n8\n</pre>",
    "outputExample": "<pre>1\n408\n</pre>",
    "tip": "",
    "timeLimited": "3000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2705",
    "category": "2.2基本算法之递归和自调用函数",
    "title": "2705:扩号匹配问题",
    "description": "在某个字符串（长度不超过100）中有左括号、右括号和大小写字母；规定（与常见的算数式子一样）任何一个左括号都从内到外与在它右边且距离最近的右括号匹配。写一个程序，找到无法匹配的左括号和右括号，输出原来字符串，并在下一行标出不能匹配的括号。不能匹配的左括号用\"$\"标注,不能匹配的右括号用\"?\"标注.",
    "img": "",
    "inputTip": "输入包括多组数据，每组数据一行，包含一个字符串，只包含左右括号和大小写字母，字符串长度不超过100注意：cin.getline(str,100)最多只能输入99个字符！",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对每组输出数据，输出两行，第一行包含原始输入字符，第二行由\"$\",\"?\"和空格组成，\"$\"和\"?\"表示与之对应的左括号和右括号不能匹配。",
    "inputExample": "<pre>((ABCD(x)\n)(rttyy())sss)(</pre>",
    "outputExample": "<pre>((ABCD(x)\n$$\n)(rttyy())sss)(\n?            ?$\n</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "3089",
    "category": "2.2基本算法之递归和自调用函数",
    "title": "3089:爬楼梯",
    "description": "<p>树老师爬楼梯，他可以每次走1级或者2级，输入楼梯的级数，求不同的走法数<br>\t例如：楼梯一共有3级，他可以每次都走一级，或者第一次走一级，第二次走两级<br>        也可以第一次走两级，第二次走一级，一共3种方法。</p>",
    "img": "",
    "inputTip": "输入包含若干行，每行包含一个正整数N，代表楼梯级数，1 <= N <= 30",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "不同的走法数，每一行输入对应一行输出",
    "inputExample": "<pre>5\n8\n10</pre>",
    "outputExample": "<pre>8\n34\n89</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "6261",
    "category": "2.2基本算法之递归和自调用函数",
    "title": "6261:汉诺塔问题",
    "description": "<p>约19世纪末，在欧州的商店中出售一种智力玩具，在一块铜板上有三根杆，最左边的杆上自上而下、由小到大顺序串着由64个圆盘构成的塔。目的是将最左边杆上的盘全部移到中间的杆上，条件是一次只能移动一个盘，且不允许大盘放在小盘的上面。\n<br>这是一个著名的问题，几乎所有的教材上都有这个问题。由于条件是一次只能移动一个盘，且不允许大盘放在小盘上面，所以64个盘的移动次数是：<span style=\";color:red;;\">18,446,744,073,709,551,615</span><br>这是一个天文数字，若每一微秒可能计算(并不输出)一次移动，那么也需要几乎一百万年。我们仅能找出问题的解决方法并解决较小N值时的汉诺塔，但很难用计算机解决64层的汉诺塔。\n<br><br>假定圆盘从小到大编号为1, 2, ...<br></p>",
    "img": "",
    "inputTip": "输入为一个整数后面跟三个单字符字符串。整数为盘子的数目，后三个字符表示三个杆子的编号。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出每一步移动盘子的记录。一次移动一行。每次移动的记录为例如 a->3->b 的形式，即把编号为3的盘子从a杆移至b杆。",
    "inputExample": "<pre>2 a b c</pre>",
    "outputExample": "<pre>a->1->c\na->2->b\nc->1->b</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "666",
    "category": "2.2基本算法之递归和自调用函数",
    "title": "666:放苹果",
    "description": "把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。",
    "img": "",
    "inputTip": "第一行是测试数据的数目t（0 <= t <= 20）。以下每行均包含二个整数M和N，以空格分开。1<=M，N<=10。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对输入的每组数据M和N，用一行输出相应的K。",
    "inputExample": "<pre>1\n7 3\n</pre>",
    "outputExample": "<pre>8</pre>",
    "tip": "lwx@POJ",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7592",
    "category": "2.2基本算法之递归和自调用函数",
    "title": "7592:求最大公约数问题",
    "description": "<p>给定两个正整数，求它们的最大公约数。<br></p>",
    "img": "",
    "inputTip": "输入一行，包含两个正整数(<1,000,000,000)。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出一个正整数，即这两个正整数的最大公约数。",
    "inputExample": "<pre>6 9</pre>",
    "outputExample": "<pre>3</pre>",
    "tip": "求最大公约数可以使用辗转相除法：假设a > b > 0，那么a和b的最大公约数等于b和a%b的最大公约数，然后把b和a%b作为新一轮的输入。由于这个过程会一直递减，直到a%b等于0的时候，b的值就是所要求的最大公约数。比如：9和6的最大公约数等于6和9%6=3的最大公约数。由于6%3==0，所以最大公约数为3。",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "8758",
    "category": "2.2基本算法之递归和自调用函数",
    "title": "8758:2的幂次方表示",
    "description": "<p>任何一个正整数都可以用2的幂次方表示。例如：</p><p style=\"text-align: left;\">    137=2<sup>7</sup>+2<sup>3</sup>+2<sup>0</sup></p><p>同时约定方次用括号来表示，即a<sup>b</sup>可表示为a(b)。由此可知，137可表示为：</p><p style=\"text-align: left;\">    2(7)+2(3)+2(0)</p><p>进一步：7=2<sup>2</sup>+2+2<sup>0</sup>（2<sup>1</sup>用2表示）</p><p>        3=2+2<sup>0</sup></p><p>所以最后137可表示为：</p><p>    2(2(2)+2+2(0))+2(2+2(0))+2(0)</p><p>又如：</p><p>    1315=2<sup>10</sup>+2<sup>8</sup>+2<sup>5</sup>+2+1</p><p>所以1315最后可表示为：</p><p>    2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)</p>",
    "img": "",
    "inputTip": "一个正整数n（n≤20000）。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一行，符合约定的n的0，2表示（在表示中不能有空格）。",
    "inputExample": "<pre>137</pre>",
    "outputExample": "<pre>2(2(2)+2+2(0))+2(2+2(0))+2(0)</pre>",
    "tip": "NOIP1998复赛 普及组 第一题",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "9273",
    "category": "2.2基本算法之递归和自调用函数",
    "title": "9273:PKU2506Tiling",
    "description": "<p><span style=\"FONT-SIZE: medium\"><span style=\"FONT-SIZE: medium\">对于一个2行N列的走道。现在用1*2,2*2的砖去铺满。问有多少种不同的方式。<br><br>下图是一个2行17列的走道的某种铺法。<br><br><br><br><img src=\"http://media.openjudge.cn/images/g1508/2506_1.jpg\" width=\"380\" height=\"59\"><br></span></span></p>",
    "img": "",
    "inputTip": "整个测试有多组数据，请做到文件底结束。每行给出一个数字N，0 <= n <= 250 ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "如题",
    "inputExample": "<pre>2\n8\n12\n100\n200</pre>",
    "outputExample": "<pre>3\n171\n2731\n845100400152152934331135470251\n1071292029505993517027974728227441735014801995855195223534251</pre>",
    "tip": "",
    "timeLimited": "2000ms",
    "spaceLimited": "1000ms"
  }
]