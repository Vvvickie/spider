[
  {
    "id": "1350",
    "category": "4.2算法之数论",
    "title": "1350:Euclid's Game",
    "description": "Two players, Stan and Ollie, play, starting with two natural numbers. Stan, the first player, subtracts any positive multiple of the lesser of the two numbers from the greater of the two numbers, provided that the resulting number must be nonnegative. Then Ollie, the second player, does the same with the two resulting numbers, then Stan, etc., alternately, until one player is able to subtract a multiple of the lesser number from the greater to reach 0, and thereby wins. For example, the players may start with (25,7): <br><pre>         25 7<br>         11 7<br>          4 7<br>          4 3<br>          1 3<br>          1 0</pre><br>an Stan wins. ",
    "img": "",
    "inputTip": "The input consists of a number of lines. Each line contains two positive integers giving the starting two numbers of the game. Stan always starts.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each line of input, output one line saying either Stan wins or Ollie wins assuming that both of them play perfectly. The last line of input contains two zeroes and should not be processed.",
    "inputExample": "<pre>34 12\n15 24\n0 0\n</pre>",
    "outputExample": "<pre>Stan wins\nOllie wins\n</pre>",
    "tip": "Waterloo local 2002.09.28",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1486",
    "category": "4.2算法之数论",
    "title": "1486:A Funny Game",
    "description": "Alice and Bob decide to play a funny game. At the beginning of the game they pick n(1 <= n <= 10<sup>6</sup>) coins in a circle, as Figure 1 shows. A move consists in removing one or two adjacent coins, leaving all other coins untouched. At least one coin must be removed. Players alternate moves with Alice starting. The player that removes the last coin wins. (The last player to move wins. If you can't move, you lose.)<br><center><img src=\"http://media.openjudge.cn/images/2484_1.jpg\"><br>Figure 1</center><br><b>Note</b>: For n > 3, we use c1, c2, ..., cn to denote the coins clockwise and if Alice remove c2, then c1 and c3 are NOT adjacent! (Because there is an empty place between c1 and c3.)<br><br>Suppose that both Alice and Bob do their best in the game. <br>You are to write a program to determine who will finally win the game. ",
    "img": "",
    "inputTip": "There are several test cases. Each test case has only one line, which contains a positive integer n (1 <= n <= 106). There are no blank lines between cases. A line with a single 0 terminates the input.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each test case, if Alice win the game,output \"Alice\", otherwise output \"Bob\".",
    "inputExample": "<pre>1\n2\n3\n0\n</pre>",
    "outputExample": "<pre>Alice\nAlice\nBob</pre>",
    "tip": "POJ Contest,Author:Mathematica@ZSU",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "185",
    "category": "4.2算法之数论",
    "title": "185:反正切函数的应用",
    "description": "反正切函数可展开成无穷级数，有如下公式<br><br><img src=\"http://media.openjudge.cn/images/1183_1.jpg\">(其中0 <= x <= 1) 公式(1)<br><br>使用反正切函数计算PI是一种常用的方法。例如，最简单的计算PI的方法：<br><br>PI=4arctan(1)=4(1-1/3+1/5-1/7+1/9-1/11+...)     公式(2)<br><br>然而，这种方法的效率很低，但我们可以根据角度和的正切函数公式：<br><br>tan(a+b)=[tan(a)+tan(b)]/[1-tan(a)*tan(b)]  公式(3)<br><br>通过简单的变换得到：<br><br>arctan(p)+arctan(q)=arctan[(p+q)/(1-pq)]    公式(4)<br><br>利用这个公式，令p=1/2,q=1/3，则(p+q)/(1-pq)=1，有<br><br>arctan(1/2)+arctan(1/3)=arctan[(1/2+1/3)/(1-1/2*1/3)]=arctan(1)<br><br>使用1/2和1/3的反正切来计算arctan(1)，速度就快多了。<br>我们将公式(4)写成如下形式<br><br>arctan(1/a)=arctan(1/b)+arctan(1/c)<br><br>其中a,b和c均为正整数。<br><br>我们的问题是：对于每一个给定的a（1 <= a <= 60000），求b＋c的值。我们保证对于任意的a都存在整数解。如果有多个解，要求你给出b+c最小的解。<br>",
    "img": "",
    "inputTip": "输入文件中只有一个正整数a，其中 1 <= a <= 60000。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出文件中只有一个整数，为 b+c 的值。",
    "inputExample": "<pre>1</pre>",
    "outputExample": "<pre>5</pre>",
    "tip": "Noi 01",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2419",
    "category": "4.2算法之数论",
    "title": "2419:Coins",
    "description": "<p>Snoopy has three coins. One day he tossed them on a table then and tried to flip some of them so that they had either all heads or all tails facing up. After several attempts, he found that regardless of the initial configuration of the coins, he could always achieve the goal by doing exactly two flippings, under the condition that only one coin could be flipped each time and a coin could be flipped more than once. He also noticed that he could never succeed with less than two flippings.</p><p>Snoopy then wondered, if he had <i>n</i> coins, was there a minimum number <i>x</i> such that he could do exactly <i>x</i> flippings to satisfy his requirements?</p>",
    "img": "",
    "inputTip": "The input contains multiple test cases. Each test case consists of a single positive integer n (n < 10,000) on a separate line. A zero indicates the end of input and should not be processed.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each test case output a single line containing your answer without leading or trailing spaces. If the answer does not exist, output “No Solution!”",
    "inputExample": "<pre>2\n3\n0</pre>",
    "outputExample": "<pre>No Solution!\n2</pre>",
    "tip": "POJ Monthly--2007.04.01, Snoopy",
    "timeLimited": "1000ms",
    "spaceLimited": "131072kB"
  },
  {
    "id": "3533",
    "category": "4.2算法之数论",
    "title": "3533:方程求解",
    "description": "<p>编写一个程序，用Jacobi迭代法求解n阶线性方程组Ax=b。输入数据确保Jacobi迭代法收敛。<br> <img src=\"http://media.openjudge.cn/images/g3533/3533_1.png\"><img>Jacobi迭代法的迭代公式：<br><img src=\"http://media.openjudge.cn/images/g3533/3533_2.png\"><img></p>",
    "img": "",
    "inputTip": "第1行有一个正整数n和一个正的双精度数\tε，n是方程组的阶数、\tε是结果的精度要求。接下来是n行数据，每行包含n+1个双精度数。第i行的前n个数据是第i个方程的系数向量，最后一个数据是第i个方程的右式值。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个整数，表示所计算出的解向量使得方程组中多少个方程的左式值与右式值相差超过右式值的万分之一。",
    "inputExample": "<pre>5 0.000294118\n-0.329221 -0.054962 0.0968168 -0.0723648 0.0520982 0.0529794 \n-0.00123477 0.161426 0.0619855 0.050214 0.0195094 -0.0284821 \n0.0251155 -0.0314213 0.104726 -0.034825 0.0124324 -0.000931532 \n-0.0265115 -0.00221929 0.0267514 0.132498 0.0205734 -0.0564419 \n0.0711287 -0.173507 0.161147 0.122201 0.54361 -0.015625\n</pre>",
    "outputExample": "<pre>4\n因为计算出的解向量为[-0.0890094 -0.00092776 -0.146684 -0.433396 0.123449]，\n由此计算出的5个方程的右式值分别是0.0529473、-0.0284863、-0.000940252、-0.0564465、-0.0156611\n</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "4975",
    "category": "4.2算法之数论",
    "title": "4975:两只鼹鼠",
    "description": "<p style=\"margin-bottom: 0in\"><span style=\"font-family:DejaVu Sans\">一个圆形花圃被分为</span><span style=\"font-family:serif\">k</span><span style=\"font-family:DejaVu Sans\">个扇形区域（</span><span style=\"font-family:serif\">0,1</span><span style=\"font-family:DejaVu Sans\">，…，</span><span style=\"font-family:serif\">k-1</span><span style=\"font-family:DejaVu Sans\">）。有两只小鼹鼠</span><span style=\"font-family:serif\">A</span><span style=\"font-family:DejaVu Sans\">，</span><span style=\"font-family:serif\">B</span><span style=\"font-family:DejaVu Sans\">分别位于其中的两个区域。鼹鼠从一个扇形区域移动到相邻的区域需要</span><span style=\"font-family:serif\">1</span><span style=\"font-family:DejaVu Sans\">分钟。已知</span><span style=\"font-family:serif\">A</span><span style=\"font-family:DejaVu Sans\">鼹鼠总是沿顺时针方向移动</span><span style=\"font-family:serif\">(</span><span style=\"font-family:DejaVu Sans\">序号增大</span><span style=\"font-family:serif\">)</span><span style=\"font-family:DejaVu Sans\">，</span><span style=\"font-family:serif\">B</span><span style=\"font-family:DejaVu Sans\">鼹鼠总是沿逆时针方向移动（序号减小），两只鼹鼠都是每隔一段时间钻出地面一次。请你求出两只鼹鼠第一次同时在同一个扇形区域钻出地面的时间。如果永远遇不到，则输出“</span><span style=\"font-family:serif\">no answer”</span><span style=\"font-family:DejaVu Sans\">。</span></p><p><br></p>",
    "img": "",
    "inputTip": "第一行为一个整数k，表示扇形区域的个数。1 <= k< = 10000第二行为两个整数la，lb分别表示两只鼹鼠初始时所处的位置。0 <= la, lb < k。第三行为两个整数ia，ib分别为两只鼹鼠钻出地面的间隔时间。0 < ia, ib < 100。第四行为两个整数fa，fb分别为两只鼹鼠第一次钻出地面的时间。0 <= fa < ia, 0 <= fb < ib。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "用一个整数表示两只鼹鼠第一次同时在同一个扇形区域钻出地面的时间。若两只鼹鼠永远无法相遇，输出“no answer”。",
    "inputExample": "<pre>7\n1 5\n3 5\n1 2</pre>",
    "outputExample": "<pre>37</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "706",
    "category": "4.2算法之数论",
    "title": "706:Georgia and Bob",
    "description": "Georgia and Bob decide to play a self-invented game. They draw a row of grids on paper, number the grids from left to right by 1, 2, 3, ..., and place N chessmen on different grids, as shown in the following figure for example:<br><center><img src=\"http://media.openjudge.cn/images/1704_1.jpg\"></center><br>Georgia and Bob move the chessmen in turn. Every time a player will choose a chessman, and move it to the left without going over any other chessmen or across the left edge. The player can freely choose number of steps the chessman moves, with the constraint that the chessman must be moved at least ONE step and one grid can at most contains ONE single chessman. The player who cannot make a move loses the game. <br><br>Georgia always plays first since \"Lady first\". Suppose that Georgia and Bob both do their best in the game, i.e., if one of them knows a way to win the game, he or she will be able to carry it out.<br><br>Given the initial positions of the n chessmen, can you predict who will finally win the game?<br>",
    "img": "",
    "inputTip": "The first line of the input contains a single integer T (1 <= T <= 20), the number of test cases. Then T cases follow. Each test case contains two lines. The first line consists of one integer N (1 <= N <= 1000), indicating the number of chessmen. The second line contains N different integers P1, P2 ... Pn (1 <= Pi <= 10000), which are the initial positions of the n chessmen.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each test case, prints a single line, \"Georgia will win\", if Georgia will win the game; \"Bob will win\", if Bob will win the game; otherwise 'Not sure'.",
    "inputExample": "<pre>2\n3\n1 2 3\n8\n1 5 6 7 9 12 14 17\n</pre>",
    "outputExample": "<pre>Bob will win\nGeorgia will win\n</pre>",
    "tip": "POJ Monthly--2004.07.18",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "908",
    "category": "4.2算法之数论",
    "title": "908:Three powers",
    "description": "Consider the set of all non-negative integer powers of 3. <br><center>S = { 1, 3, 9, 27, 81, ... } </center><br>Consider the sequence of all subsets of S ordered by the value of the sum of their elements. The question is simple: find the set at the n-th position in the sequence and print it in increasing order of its elements. ",
    "img": "",
    "inputTip": "Each line of input contains a number n, which is a positive integer with no more than 19 digits. The last line of input contains 0 and it should not be processed. ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each line of input, output a single line displaying the n-th set as described above, in the format used in the sample output. ",
    "inputExample": "<pre>1\n7\n14\n783\n1125900981634049\n0\n</pre>",
    "outputExample": "<pre>{ }\n{ 3, 9 }\n{ 1, 9, 27 }\n{ 3, 9, 27, 6561, 19683 }\n{ 59049, 3486784401, 205891132094649, 717897987691852588770249 }\n</pre>",
    "tip": "Waterloo local 2004.06.12",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "9274",
    "category": "4.2算法之数论",
    "title": "9274:beeline",
    "description": "<p><span style=\"font-size: medium;\">平面上的一点若有k条已知直线通过，则称为k重点，在平面上引n条直线，这些直线相交所得的二重、三重、……、n重点的数目为k2、……、kn，求这些直线将平面分成了多少块。 <br>\n</span></p>",
    "img": "",
    "inputTip": "第一行一个整数n（1<=n<=10^6）。第二行n-1个整数，第i个整数表示ki+1. ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个数，即平面被划分成的块数 ",
    "inputExample": "<pre>4\n4 0 0</pre>",
    "outputExample": "<pre>9</pre>",
    "tip": "",
    "timeLimited": "12000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "9278",
    "category": "4.2算法之数论",
    "title": "9278:旅行",
    "description": "<p><span style=\"font-size: medium;\">转眼毕业了，曾经朝夕相处的同学们不得不都各奔东西，大家都去了不同的城市开始新的生活。在各自城市居住了一段时间后，他们都感到了一些厌倦，想去看看其他人的生活究竟如何，于是他们都选择到另一个同学所在城市去旅游，并且希望旅游的城市各不相同，他们想知道有多少种不同的方案，可是数量实在太多了，他们无法计算出来，你能帮助他们吗。<br>\n</span></p>",
    "img": "",
    "inputTip": "一个正整数n(n<200)，表示人数。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个数，表示有多少不同的方案。",
    "inputExample": "<pre>3</pre>",
    "outputExample": "<pre>2</pre>",
    "tip": "有如下两种方案：同学1去同学2的城市，同学2去同学3的城市，同学3去同学1的城市同学1去同学3的城市，同学3去同学2的城市，同学2去同学1的城市",
    "timeLimited": "10000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "9287",
    "category": "4.2算法之数论",
    "title": "9287:Irrelevant Elements",
    "description": "<p><span style=\"font-size: medium;\">年轻的密码分析学家Georgie正在研究产生从0到m – 1的随机数的不同的方案。他认为标准的随机数发生器不够好。所以，他发明了一个更为随机性的随机数产生方案。 <br>\n首先，Georgie选择n并且产生n个从0到m – 1的随机数。产生的随机数为a1,a2,……,an。然后，Georgie计算出每对相邻的两个数的和。把初始的数组替换成为和的数组，这样得到n-1个整数：a1 + a2，a2 + a3，……，an–1 + an。然后对新的数组执行同样的操作，得到n-2个数。重复这个过程，直到只有一个数剩下。这个数取它摸m的值。这样给出这个过程产生的结果。 <br>\nGeorgie自豪地向他的计算机老师描述这个方案，却被老师指出这个方案有很多缺点。其中一个重要的缺点是这个过程的结果有时候甚至不依赖于最初产生的某些数。比如，当n=3并且m=2，这个时候，结果不依赖于a2。 <br>\n现在，Georgie想要研究这个现象。如果产生的结果不依赖于初始数组的第i个元素，那么，他称这个元素为不相关的。他考虑不同的n和m，想要知道对于这些参数，哪些元素是不相关的。你帮他找出来。 <br>\n</span></p>",
    "img": "",
    "inputTip": "输入文件包含n和m（1 <= n <=100,000，2 <= m <= 10^9）。 ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对于给定的n和m，输出文件的第一行输出初始数组中不相关元素的数量。第二行输出所有的i，其中第i个元素是不相关的。第二行输出的数必须升序排列并且相邻两数间严格用一个空格隔开。 ",
    "inputExample": "<pre>3 2</pre>",
    "outputExample": "<pre>1\n2</pre>",
    "tip": "",
    "timeLimited": "51000ms",
    "spaceLimited": "1000ms"
  }
]