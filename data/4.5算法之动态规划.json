[
  {
    "id": "1249",
    "category": "4.5算法之动态规划",
    "title": "1249:Humble Numbers",
    "description": "A number whose only prime factors are 2,3,5 or 7 is called a humble number. The sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 24, 25, 27, ... shows the first 20 humble numbers. <br><br>Write a program to find and print the nth element in this sequence.<br>",
    "img": "",
    "inputTip": "The input consists of one or more test cases. Each test case consists of one integer n with 1 <= n <= 5842. Input is terminated by a value of zero (0) for n.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each test case, print one line saying \"The nth humble number is number.\". Depending on the value of n, the correct suffix \"st\", \"nd\", \"rd\", or \"th\" for the ordinal number nth has to be used like it is shown in the sample output.",
    "inputExample": "<pre>1\n2\n3\n4\n11\n12\n13\n21\n22\n23\n100\n1000\n5842\n0\n</pre>",
    "outputExample": "<pre>The 1st humble number is 1.\nThe 2nd humble number is 2.\nThe 3rd humble number is 3.\nThe 4th humble number is 4.\nThe 11th humble number is 12.\nThe 12th humble number is 14.\nThe 13th humble number is 15.\nThe 21st humble number is 28.\nThe 22nd humble number is 30.\nThe 23rd humble number is 32.\nThe 100th humble number is 450.\nThe 1000th humble number is 385875.\nThe 5842nd humble number is 2000000000.\n</pre>",
    "tip": "Ulm Local 1996",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1413",
    "category": "4.5算法之动态规划",
    "title": "1413:Mondriaan's Dream",
    "description": "Squares and rectangles fascinated the famous Dutch painter Piet Mondriaan. One night, after producing the drawings in his 'toilet series' (where he had to use his toilet paper to draw on, for all of his paper was filled with squares and rectangles), he dreamt of filling a large rectangle with small rectangles of width 2 and height 1 in varying ways. <br><center><img src=\"http://media.openjudge.cn/images/2411_1.jpg\"></center><br>Expert as he was in this material, he saw at a glance that he'll need a computer to calculate the number of ways to fill the large rectangle whose dimensions were integer values, as well. Help him, so that his dream won't turn into a nightmare!",
    "img": "",
    "inputTip": "The input contains several test cases. Each test case is made up of two integer numbers: the height h and the width w of the large rectangle. Input is terminated by h=w=0. Otherwise, 1<=h,w<=11. ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each test case, output the number of different ways the given rectangle can be filled with small rectangles of size 2 times 1. Assume the given large rectangle is oriented, i.e. count symmetrical tilings multiple times. ",
    "inputExample": "<pre>1 2\n1 3\n1 4\n2 2\n2 3\n2 4\n2 11\n4 11\n0 0\n</pre>",
    "outputExample": "<pre>1\n0\n1\n2\n3\n5\n144\n51205\n</pre>",
    "tip": "Ulm Local 2000",
    "timeLimited": "3000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "16",
    "category": "4.5算法之动态规划",
    "title": "16:Dividing",
    "description": "Marsha and Bill own a collection of marbles. They want to split the collection among themselves so that both receive an equal share of the marbles. This would be easy if all the marbles had the same value, because then they could just split the collection in half. But unfortunately, some of the marbles are larger, or more beautiful than others. So, Marsha and Bill start by assigning a value, a natural number between one and six, to each marble. Now they want to divide the marbles so that each of them gets the same total value. Unfortunately, they realize that it might be impossible to divide the marbles in this way (even if the total value of all marbles is even). For example, if there are one marble of value 1, one of value 3 and two of value 4, then they cannot be split into sets of equal value. So, they ask you to write a program that checks whether there is a fair partition of the marbles. ",
    "img": "",
    "inputTip": "Each line in the input file describes one collection of marbles to be divided. The lines contain six non-negative integers n1 , . . . , n6 , where ni is the number of marbles of value i. So, the example from above would be described by the input-line \"1 0 1 2 0 0\". The maximum total number of marbles will be 20000. The last line of the input file will be \"0 0 0 0 0 0\"; do not process this line. ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each collection, output \"Collection #k:\", where k is the number of the test case, and then either \"Can be divided.\" or \"Can't be divided.\". Output a blank line after each test case. ",
    "inputExample": "<pre>1 0 1 2 0 0 \n1 0 0 0 1 1 \n0 0 0 0 0 0 </pre>",
    "outputExample": "<pre>Collection #1:\nCan't be divided.\n\nCollection #2:\nCan be divided.</pre>",
    "tip": "Mid-Central European Regional Contest 1999",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1665",
    "category": "4.5算法之动态规划",
    "title": "1665:完美覆盖",
    "description": "一张普通的国际象棋棋盘，它被分成 8 乘 8 (8 行 8 列) 的 64 个方格。设有形状一样的多米诺牌，每张牌恰好覆盖棋盘上相邻的两个方格，即一张多米诺牌是一张 1 行 2 列或者 2 行 1 列的牌。那么，是否能够把 32 张多米诺牌摆放到棋盘上，使得任何两张多米诺牌均不重叠，每张多米诺牌覆盖两个方格，并且棋盘上所有的方格都被覆盖住？我们把这样一种排列称为棋盘被多米诺牌完美覆盖。这是一个简单的排列问题，同学们能够很快构造出许多不同的完美覆盖。但是，计算不同的完美覆盖的总数就不是一件容易的事情了。不过，同学们 发挥自己的聪明才智，还是有可能做到的。<br>现在我们通过计算机编程对 3 乘 n 棋盘的不同的完美覆盖的总数进行计算。<br><br><img src=\"http://media.openjudge.cn/images/2663_1.jpg\"><br><br>任务<br>对 3 乘 n 棋盘的不同的完美覆盖的总数进行计算。<br>",
    "img": "",
    "inputTip": "一次输入可能包含多行，每一行分别给出不同的 n 值 ( 即 3 乘 n 棋盘的列数 )。当输入 -1 的时候结束。n 的值最大不超过 30.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "针对每一行的 n 值，输出 3 乘 n 棋盘的不同的完美覆盖的总数。 ",
    "inputExample": "<pre>2\n8\n12\n-1\n</pre>",
    "outputExample": "<pre>3\n153\n2131\n</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1793",
    "category": "4.5算法之动态规划",
    "title": "1793:矩形覆盖",
    "description": "在平面上给出了n个点，现在需要用一些平行于坐标轴的矩形把这些点覆盖住。每个点都需要被覆盖，而且可以被覆盖多次。每个矩形都至少要覆盖两个点，而且处于矩形边界上的点也算作被矩形覆盖。注意：矩形的长宽都必须是正整数，也就是说矩形不能退化为线段或者点。<br><br>现在的问题是：怎样选择矩形，才能够使矩形的总面积最小。<br>",
    "img": "",
    "inputTip": "输入包括多组测试数据。每组测试数据的第一行给出n (2 <= n <= 15)，表示平面上的点数。后面的n行，每行上包括两个整数x, y (-1000 <= x, y <= 1000)，给出一个点在平面上的x坐标和y坐标。输入数据保证：这n个点在平面上的位置各不相同。最后一组测试数据中n = 0，表示输入的结束，这组数据不用处理。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对每一组测试数据，输出一行，包括一个正整数，给出矩形的最小总面积。",
    "inputExample": "<pre>2\n0 1\n1 0\n0\n</pre>",
    "outputExample": "<pre>1</pre>",
    "tip": "矩形的总面积指的是所有矩形的面积直接相加的结果",
    "timeLimited": "3000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "191",
    "category": "4.5算法之动态规划",
    "title": "191:钉子和小球",
    "description": "<p>有一个三角形木板,竖直立放，上面钉着n(n+1)/2颗钉子，还有(n+1)个格子（当n=5时如图1）。每颗钉子和周围的钉子的距离都等于d，每个格子的宽度也都等于d，且除了最左端和最右端的格子外每个格子都正对着最下面一排钉子的间隙。<br>让一个直径略小于d的小球中心正对着最上面的钉子在板上自由滚落，小球每碰到一个钉子都可能落向左边或右边（概率各1/2），且球的中心还会正对着下一颗将要碰上的钉子。例如图2就是小球一条可能的路径。<br>我们知道小球落在第i个格子中的概率pi=<img src=\"http://media.openjudge.cn/images/1189_1.jpg\">，其中i为格子的编号，从左至右依次为0,1,...,n。<br>现在的问题是计算拔掉某些钉子后，小球落在编号为m的格子中的概率pm。假定最下面一排钉子不会被拔掉。例如图3是某些钉子被拔掉后小球一条可能的路径。<br></p><center><img src=\"http://media.openjudge.cn/images/1189_2.jpg\"></center>",
    "img": "",
    "inputTip": "第1行为整数n（2 <= n <= 50）和m（0 <= m <= n）。以下n行依次为木板上从上至下n行钉子的信息，每行中'*'表示钉子还在，'.'表示钉子被拔去，注意在这n行中空格符可能出现在任何位置。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "仅一行，是一个既约分数(0写成0/1)，为小球落在编号为m的格子中的概pm。既约分数的定义：A/B是既约分数，当且仅当A、B为正整数且A和B没有大于1的公因子。",
    "inputExample": "<pre>5 2\n    *\n   * .\n  * * *\n * . * *\n* * * * *</pre>",
    "outputExample": "<pre>7/16</pre>",
    "tip": "Noi 99",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "193",
    "category": "4.5算法之动态规划",
    "title": "193:棋盘分割",
    "description": "将一个８*８的棋盘进行如下分割：将原棋盘割下一块矩形棋盘并使剩下部分也是矩形，再将剩下的部分继续如此分割，这样割了(n-1)次后，连同最后剩下的矩形棋盘共有n块矩形棋盘。(每次切割都只能沿着棋盘格子的边进行)<br><center><img src=\"http://media.openjudge.cn/images/1191_1.jpg\"></center><br>原棋盘上每一格有一个分值，一块矩形棋盘的总分为其所含各格分值之和。现在需要把棋盘按上述规则分割成n块矩形棋盘，并使各矩形棋盘总分的均方差最小。<br>均方差<img src=\"http://media.openjudge.cn/images/1191_2.jpg\">，其中平均值<img src=\"http://media.openjudge.cn/images/1191_3.jpg\">，xi为第i块矩形棋盘的总分。<br>请编程对给出的棋盘及n，求出O'的最小值。<br>",
    "img": "",
    "inputTip": "第1行为一个整数n(1 < n < 15)。第2行至第9行每行为8个小于100的非负整数，表示棋盘上相应格子的分值。每行相邻两数之间用一个空格分隔。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "仅一个数，为O'（四舍五入精确到小数点后三位）。",
    "inputExample": "<pre>3\n1 1 1 1 1 1 1 3\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 0\n1 1 1 1 1 1 0 3</pre>",
    "outputExample": "<pre>1.633</pre>",
    "tip": "Noi 99",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1980",
    "category": "4.5算法之动态规划",
    "title": "1980:陪审团的人选",
    "description": "在遥远的国家佛罗布尼亚，嫌犯是否有罪，须由陪审团决定。陪审团是由法官从公众中挑选的。先随机挑选n个人作为陪审团的候选人，然后再从这n个人中选m人组成陪审团。选m人的办法是：<br><br>控方和辩方会根据对候选人的喜欢程度，给所有候选人打分，分值从0到20。为了公平起见，法官选出陪审团的原则是：选出的m个人，必须满足辩方总分和控方总分的差的绝对值最小。如果有多种选择方案的辩方总分和控方总分的之差的绝对值相同，那么选辩控双方总分之和最大的方案即可。<br>",
    "img": "",
    "inputTip": "输入包含多组数据。每组数据的第一行是两个整数n和m，n是候选人数目，m是陪审团人数。注意，1<=n<=200, 1<=m<=20 而且 m<=n。接下来的n行，每行表示一个候选人的信息，它包含2个整数，先后是控方和辩方对该候选人的打分。候选人按出现的先后从1开始编号。两组有效数据之间以空行分隔。最后一组数据n=m=0",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对每组数据，先输出一行，表示答案所属的组号,如 'Jury #1', 'Jury #2', 等。接下来的一行要象例子那样输出陪审团的控方总分和辩方总分。再下来一行要以升序输出陪审团里每个成员的编号，两个成员编号之间用空格分隔。每组输出数据须以一个空行结束。",
    "inputExample": "<pre>4 2 \n1 2 \n2 3 \n4 1 \n6 2 \n0 0 </pre>",
    "outputExample": "<pre>Jury #1 \nBest jury has value 6 for prosecution and value 4 for defence: \n 2 3 </pre>",
    "tip": "Southwestern European Regional Contest 1996, POJ 1015, 程序设计实习2007",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "223",
    "category": "4.5算法之动态规划",
    "title": "223:UNIMODAL PALINDROMIC DECOMPOSITIONS",
    "description": "<p>A sequence of positive integers is Palindromic if it reads the same forward and backward. For example:<br>23 11 15 1 37 37 1 15 11 23<br>1 1 2 3 4 7 7 10 7 7 4 3 2 1 1<br>A Palindromic sequence is Unimodal Palindromic if the values do not decrease up to the middle value and then (since the sequence is palindromic) do not increase from the middle to the end For example, the first example sequence above is NOT Unimodal Palindromic while the second example is.<br>A Unimodal Palindromic sequence is a Unimodal Palindromic Decomposition of an integer N, if the sum of the integers in the sequence is N. For example, all of the Unimodal Palindromic Decompositions of the first few integers are given below:<br>1: (1)<br>2: (2), (1 1)<br>3: (3), (1 1 1)<br>4: (4), (1 2 1), (2 2), (1 1 1 1)<br>5: (5), (1 3 1), (1 1 1 1 1)<br>6: (6), (1 4 1), (2 2 2), (1 1 2 1 1), (3 3),<br>(1 2 2 1), ( 1 1 1 1 1 1)<br>7: (7), (1 5 1), (2 3 2), (1 1 3 1 1), (1 1 1 1 1 1 1)<br>8: (8), (1 6 1), (2 4 2), (1 1 4 1 1), (1 2 2 2 1),<br>(1 1 1 2 1 1 1), ( 4 4), (1 3 3 1), (2 2 2 2),<br>(1 1 2 2 1 1), (1 1 1 1 1 1 1 1)<br><br>Write a program, which computes the number of Unimodal Palindromic Decompositions of an integer.<br></p>",
    "img": "",
    "inputTip": "Input consists of a sequence of positive integers, one per line ending with a 0 (zero) indicating the end.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each input value except the last, the output is a line containing the input value followed by a space, then the number of Unimodal Palindromic Decompositions of the input value. See the example on the next page.",
    "inputExample": "<pre>2\n3\n4\n5\n6\n7\n8\n10\n23\n24\n131\n213\n92\n0</pre>",
    "outputExample": "<pre>2 2\n3 2\n4 4\n5 3\n6 7\n7 5\n8 11\n10 17\n23 104\n24 199\n131 5010688\n213 1055852590\n92 331143</pre>",
    "tip": "N < 250",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2373",
    "category": "4.5算法之动态规划",
    "title": "2373:Telephone Wire",
    "description": "Farmer John's cows are getting restless about their poor telephone service; they want FJ to replace the old telephone wire with new, more efficient wire. The new wiring will utilize N (2 <= N <= 100,000) already-installed telephone poles, each with some height_i meters (1 <= height_i <= 100). The new wire will connect the tops of each pair of adjacent poles and will incur a penalty cost C * the two poles' height difference for each section of wire where the poles are of different heights (1 <= C <= 100). The poles, of course, are in a certain sequence and can not be moved.<br><br>Farmer John figures that if he makes some poles taller he can reduce his penalties, though with some other additional cost. He can add an integer X number of meters to a pole at a cost of X^2.<br><br>Help Farmer John determine the cheapest combination of growing pole heights and connecting wire so that the cows can get their new and improved service.",
    "img": "",
    "inputTip": "* Line 1: Two space-separated integers: N and C* Lines 2..N+1: Line i+1 contains a single integer: height_i",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "* Line 1: The minimum total amount of money that it will cost Farmer John to attach the new telephone wire.",
    "inputExample": "<pre>5 2\n2\n3\n5\n1\n4</pre>",
    "outputExample": "<pre>15</pre>",
    "tip": "INPUT DETAILS:There are 5 telephone poles, and the vertical distance penalty is $2/meter. The poles initially have heights of 2, 3, 5, 1, and 4, respectively.OUTPUT DETAILS:The best way is for Farmer John to raise the first pole by 1 unit and the fourth pole by 2 units, making the heights (in order) 3, 3, 5, 3, and 4. This costs $5. The remaining wiring will cost $2*(0+2+2+1) = $10, for a total of $15.",
    "timeLimited": "10000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "2424",
    "category": "4.5算法之动态规划",
    "title": "2424:Tiling a Grid With Dominoes",
    "description": "We wish to tile a grid 4 units high and N units long with rectangles (dominoes) 2 units by one unit (in either orientation). For example, the figure shows the five different ways that a grid 4 units high and 2 units wide may be tiled.<br><p align=\"center\" style=\"text-autospace: none\"><br><img border=\"0\" src=\"http://media.openjudge.cn/images/3423.jpg\" width=\"456\" height=\"166\"></p><br>Write a program that takes as input the width, W, of the grid and outputs the number of different ways to tile a 4-by-W grid.",
    "img": "",
    "inputTip": "The first line of input contains a single integer N, (1 ≤ N ≤ 1000) which is the number of datasets that follow.Each dataset contains a single decimal integer, the width, W, of the grid for this problem instance.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each problem instance, there is one line of output: The problem instance number as a decimal integer (start counting at one), a single space and the number of tilings of a 4-by-W grid. The values of W will be chosen so the count will fit in a 32-bit integer.",
    "inputExample": "<pre>3\n2\n3\n7</pre>",
    "outputExample": "<pre>1 5\n2 11\n3 781</pre>",
    "tip": "Greater NY 2007",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2454",
    "category": "4.5算法之动态规划",
    "title": "2454:雷涛的小猫",
    "description": "<p>雷涛同学非常的有爱心，在他的宿舍里，养着一只因为受伤被救助的小猫(当然，这样的行为是违反学生宿舍管理条例的)。在他的照顾下，小猫很快恢复了健康，并且愈发的活泼可爱了。</p><center><img src=\"http://media.openjudge.cn/images/3453_1.jpg\"></center><p>可是有一天，雷涛下课回到寝室，却发现小猫不见了！经过一番寻找，才发现她正趴在阳台上对窗外的柿子树发呆…</p><p>在北京大学的校园里，有许多柿子树，在雷涛所在的宿舍楼前，就有<i>N</i>棵。并且这<i>N</i>棵柿子树每棵的高度都是<i>H</i>。冬天的寒冷渐渐笼罩了大地，树上的叶子渐渐掉光了，只剩下一个个黄澄澄的柿子，看着非常喜人。而雷涛的小猫恰好非常的爱吃柿子，看着窗外树上的柿子，她十分眼馋，于是决定利用自己敏捷的跳跃能力跳到树上去吃柿子。</p><p>小猫可以从宿舍的阳台上跳到窗外任意一棵柿子树的树顶。之后，她每次都可以在当前位置沿着当前所在的柿子树向下跳1单位距离。当然，小猫的能力远不止如此，她还可以在树之间跳跃。每次她都可以从当前这棵树跳到另外的任意一棵，在这个过程中，她的高度会下降<i>Delta</i>单位距离。每个时刻，只要她所在的位置有柿子，她就可以吃掉。整个“吃柿子行动”一直到小猫落到地面上为止。</p><p>雷涛调查了所有柿子树上柿子的生长情况。他很想知道，小猫从阳台出发，最多能吃到多少柿子？他知道写一个程序可以很容易的解决这个问题，但是他现在懒于写任何代码。于是，现在你的任务就是帮助雷涛写一个这样的程序。</p><p>图为<i>N</i> = 3, <i>H</i> = 10, <i>Delta</i> = 2的一个例子。小猫按照图示路线进行跳跃，可以吃到最多的8个柿子</p><center><img src=\"http://media.openjudge.cn/images/3453_2.jpg\"></center>",
    "img": "",
    "inputTip": "输入文件的第一行有三个以空格分隔的整数，分别代表N, H, Delta接下来的N行，每行第一个整数为Ni，代表第i棵树上的柿子数量。接下来是Ni个整数，每个整数Tij代表第i棵柿子树的Tij高度上长有一个柿子。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出仅包含一个整数，即小猫最多吃到的柿子数。",
    "inputExample": "<pre>3 10 2\n3 1 4 10\n6 3 5 9 7 8 9\n5 4 5 3 6 9\n</pre>",
    "outputExample": "<pre>8\n</pre>",
    "tip": "1 ≤ N, H ≤ 20000 ≤ Ni ≤ 50001 ≤ Delta ≤ N, 1 ≤ Tij ≤ H输入文件大小不大于40960KB",
    "timeLimited": "20000ms",
    "spaceLimited": "10000ms"
  },
  {
    "id": "3368",
    "category": "4.5算法之动态规划",
    "title": "3368:Sanguo",
    "description": "<div><p>After East Han dynasty, China was divided into several states. Wei, Wu, and Shu are the greatest three states among them. This was the era of Sanguo. During this period, wars frequently happened between states. Zhuge Liang, the commander and strategist of Shu, wanted to enlarge Shu's power. He was considering conquering <i>N</i> cities. However, these cities must be defeated in a specified order. <i>City-X</i> could be defeated only after <i>City-1</i>, <i>City-2</i>, <i>City-3</i> ... <i>City-(X-1)</i> had been defeated. However, passing through the cities that had not been defeated was eligible. Zhuge wanted to use three generals, Guan Yu, Zhang Fei, and Zhao yun, each of whom should lead an army. The three armies, started from Yizhou, which was numbered with <i>City-0</i>. After conquered all the <i>N</i> cities (each cities must be conquered at least by one army), they had to return to Yizhou.</p><p>The <i>N</i> cities and Yizhou were connected by <i>M</i> bi-directed roads. To travel from city to city was a very boring and expensive thing. So Zhuge wanted to minimize the total length of the three armies' traveling. You were hired to help him to compute the minimum total length of the traveling.</p></div>",
    "img": "",
    "inputTip": "Line1: two integers N and M. N is the number of cities Zhuge wanted to conquer, and M is the number of roads between the N + 1 cities.Line2...Line(M+1): each line contain 3 integers, X, Y, Len, indicating a road between City-X and City-Y, with the length of Len.You can suppose that all the N + 1 cities are connected.N ≤ 500, M ≤ 20000, Len ≤ 1000",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "Line1: an integer, which is the minimum total length of the three armies' traveling.",
    "inputExample": "<pre>5 15\n5 5 48\n1 4 658\n4 0 843\n1 4 41\n1 4 330\n5 2 864\n4 2 115\n4 0 303\n2 3 685\n0 0 879\n1 5 649\n2 4 942\n4 0 379\n5 2 769\n5 1 856\n</pre>",
    "outputExample": "<pre>3668</pre>",
    "tip": "",
    "timeLimited": "3000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "39",
    "category": "4.5算法之动态规划",
    "title": "39:A decorative fence",
    "description": "Richard just finished building his new house. Now the only thing the house misses is a cute little wooden fence. He had no idea how to make a wooden fence, so he decided to order one. Somehow he got his hands on the ACME Fence Catalogue 2002, the ultimate resource on cute little wooden fences. After reading its preface he already knew, what makes a little wooden fence cute.<br>A wooden fence consists of N wooden planks, placed vertically in a row next to each other. A fence looks cute if and only if the following conditions are met:<br> The planks have different lengths, namely 1, 2, . . . , N plank length units.<br> Each plank with two neighbors is either larger than each of its neighbors or smaller than each of them. (Note that this makes the top of the fence alternately rise and fall.)<br>It follows, that we may uniquely describe each cute fence with N planks as a permutation a1, . . . , aN of the numbers 1, . . . ,N such that (any i; 1 < i < N) (ai − ai−1)*(ai − ai+1) > 0 and vice versa, each such permutation describes a cute fence.<br>It is obvious, that there are many di\u000berent cute wooden fences made of N planks. To bring some order into their catalogue, the sales manager of ACME decided to order them in the following way: Fence A (represented by the permutation a1, . . . , aN) is in the catalogue before fence B (represented by b1, . . . , bN) if and only if there exists such i, that (any j < i) aj = bj and (ai < bi). (Also to decide, which of the two fences is earlier in the catalogue, take their corresponding permutations, find the first place on which they differ and compare the values on this place.) All the cute fences with N planks are numbered (starting from 1) in the order they appear in the catalogue. This number is called their catalogue number.<br><center><img src=\"http://media.openjudge.cn/images/1037/fence.gif\"></center><br>After carefully examining all the cute little wooden fences, Richard decided to order some of them. For each of them he noted the number of its planks and its catalogue number. Later, as he met his friends, he wanted to show them the fences he ordered, but he lost the catalogue somewhere. The only thing he has got are his notes. Please help him find out, how will his fences look like.",
    "img": "",
    "inputTip": "The first line of the input file contains the number K (1 <= K <= 100) of input data sets. K lines follow, each of them describes one input data set. Each of the following K lines contains two integers N and C (1 <= N <= 20), separated by a space. N is the number of planks in the fence, C is the catalogue number of the fence.You may assume, that the total number of cute little wooden fences with 20 planks fits into a 64-bit signed integer variable (long long in C/C++, int64 in FreePascal). You may also assume that the input is correct, in particular that C is at least 1 and it doesn抰 exceed the number of cute fences with N planks.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each input data set output one line, describing the C-th fence with N planks in the catalogue. More precisely, if the fence is described by the permutation a1, . . . , aN, then the corresponding line of the output file should contain the numbers ai (in the correct order), separated by single spaces.",
    "inputExample": "<pre>2\n2 1\n3 3</pre>",
    "outputExample": "<pre>1 2\n2 3 1</pre>",
    "tip": "CEOI 2002",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "392",
    "category": "4.5算法之动态规划",
    "title": "392:Blocks",
    "description": "Some of you may have played a game called 'Blocks'. There are n blocks in a row, each box has a color. Here is an example: Gold, Silver, Silver, Silver, Silver, Bronze, Bronze, Bronze, Gold. <br>The corresponding picture will be as shown below:<br><center><img src=\"http://media.openjudge.cn/images/g392/1390_1.jpg\"><br>Figure 1</center><br>If some adjacent boxes are all of the same color, and both the box to its left(if it exists) and its right(if it exists) are of some other color, we call it a 'box segment'. There are 4 box segments. That is: gold, silver, bronze, gold. There are 1, 4, 3, 1 box(es) in the segments respectively.<br><br>Every time, you can click a box, then the whole segment containing that box DISAPPEARS. If that segment is composed of k boxes, you will get k*k points. for example, if you click on a silver box, the silver segment disappears, you got 4*4=16 points.<br><br>Now let's look at the picture below:<br><center><img src=\"http://media.openjudge.cn/images/g392/1390_2.jpg\"><br>Figure 2</center><br><br>The first one is OPTIMAL.<br><br>Find the highest score you can get, given an initial state of this game.",
    "img": "",
    "inputTip": "The first line contains the number of tests t(1<=t<=15). Each case contains two lines. The first line contains an integer n(1<=n<=200), the number of boxes. The second line contains n integers, representing the colors of each box. The integers are in the range 1~n.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each test case, print the case number and the highest possible score.",
    "inputExample": "<pre>2\n9\n1 2 2 2 2 3 3 3 1\n1\n1</pre>",
    "outputExample": "<pre>Case 1: 29\nCase 2: 1</pre>",
    "tip": "Liu Rujia@POJ",
    "timeLimited": "5000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "4979",
    "category": "4.5算法之动态规划",
    "title": "4979:海贼王之伟大航路",
    "description": "<p style=\"margin-bottom: 0in\">“<span style=\"font-family:DejaVu Sans\">我是要成为海贼王的男人！”，路飞一边喊着这样的口号，一边和他的伙伴们一起踏上了伟大航路的艰险历程。</span></p><p><img style=\"width: 646px; height: 254px;\" src=\"http://media.openjudge.cn/images/upload/1340073793.jpg\"></p><p style=\"margin-bottom: 0in\"><span style=\"font-family:DejaVu Sans\">路飞他们伟大航路行程的起点是罗格镇，终点是拉夫德鲁（那里藏匿着“唯一的大秘宝”——</span>ONE\nPIECE<span style=\"font-family:DejaVu Sans\">）。而航程中间，则是各式各样的岛屿。</span></p><p style=\"margin-bottom: 0in\"><span style=\"font-family:DejaVu Sans\">因为伟大航路上的气候十分异常，所以来往任意两个岛屿之间的时间差别很大，从</span>A<span style=\"font-family:DejaVu Sans\">岛到</span>B<span style=\"font-family:DejaVu Sans\">岛可能需要</span>1<span style=\"font-family:DejaVu Sans\">天，而从</span>B<span style=\"font-family:DejaVu Sans\">岛到</span>A<span style=\"font-family:DejaVu Sans\">岛则可能需要</span>1<span style=\"font-family:DejaVu Sans\">年。当然，任意两个岛之间的航行时间虽然差别很大，但都是已知的。</span></p><p style=\"margin-bottom: 0in\"><span style=\"font-family:DejaVu Sans\">现在假设路飞一行从罗格镇（起点）出发，遍历伟大航路中间所有的岛屿（但是已经经过的岛屿不能再次经过），最后到达拉夫德鲁（终点）。假设他们在岛上不作任何的停留，请问，他们最少需要花费多少时间才能到达终点？</span></p>",
    "img": "",
    "inputTip": "输入数据包含多行。第一行包含一个整数N(2 < N ≤ 16)，代表伟大航路上一共有N个岛屿（包含起点的罗格镇和终点的拉夫德鲁）。其中，起点的编号为1，终点的编号为N。之后的N行每一行包含N个整数，其中，第i(1 ≤ i ≤ N)行的第j(1 ≤ j ≤ N)个整数代表从第i个岛屿出发到第j个岛屿需要的时间t(0 < t < 10000)。第i行第i个整数为0。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出为一个整数，代表路飞一行从起点遍历所有中间岛屿（不重复）之后到达终点所需要的最少的时间。",
    "inputExample": "<pre>样例输入1：\n4\n0 10 20 999\n5 0 90 30\n99 50 0 10\n999 1 2 0\n\n样例输入2：\n5\n0 18 13 98 8\n89 0 45 78 43 \n22 38 0 96 12\n68 19 29 0 52\n95 83 21 24 0</pre>",
    "outputExample": "<pre>样例输出1：\n100\n\n样例输出2：\n137</pre>",
    "tip": "提示：对于样例输入1：路飞选择从起点岛屿1出发，依次经过岛屿3，岛屿2，最后到达终点岛屿4。花费时间为20+50+30=100。对于样例输入2：可能的路径及总时间为：1,2,3,4,5: 18+45+96+52=2111,2,4,3,5: 18+78+29+12=1371,3,2,4,5: 13+38+78+52=1811,3,4,2,5: 13+96+19+43=1711,4,2,3,5: 98+19+45+12=1741,4,3,2,5: 98+29+38+43=208所以最短的时间花费为137单纯的枚举在N=16时需要14!次运算，一定会超时。",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "5890",
    "category": "4.5算法之动态规划",
    "title": "5890:Tour",
    "description": "<p>John Doe, a skilled pilot, enjoys traveling. While on vacation, he rents a small plane and starts visiting beautiful places. To save money, John must determine the shortest closed tour that connects his destinations. Each destination is represented by a point in the plane pi = < xi,yi >. John uses the following strategy: he starts from the leftmost point, then he goes strictly left to right to the rightmost point, and then he goes strictly right back to the starting point. It is known that the points have distinct x-coordinates.</p><p>Write a program that, given a set of n points in the plane, computes the shortest closed tour that connects the points according to John's strategy.</p>",
    "img": "",
    "inputTip": "The program input is from a text file. Each data set in the file stands for a particular set of points. For each set of points the data set contains the number of points, and the point coordinates in ascending order of the x coordinate. White spaces can occur freely in input. The input data are correct.The number of points of each data set is at most 50, and each coordinate does not exceed 20000 by an absolute value.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each set of data, your program should print the result to the standard output from the beginning of a line. The tour length, a floating-point number with two fractional digits, represents the result. An input/output sample is in the table below. Here there are two data sets. The first one contains 3 points specified by their x and y coordinates. The second point, for example, has the x coordinate 2, and the y coordinate 3. The result for each data set is the tour length, (6.47 for the first data set in the given example).",
    "inputExample": "<pre>3\n1 1\n2 3\n3 1\n4\n1 1\n2 3\n3 1\n4 2</pre>",
    "outputExample": "<pre>6.47\n7.89</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "6047",
    "category": "4.5算法之动态规划",
    "title": "6047:分蛋糕",
    "description": "<p class=\"MsoNormal\" style=\"margin-left:21.0pt\"><span style=\"font-size:12.0pt;font-family:宋体\">有一块矩形大蛋糕，长和宽分别是整数</span><em><span style=\"font-size:12.0pt\">w</span></em><span style=\"font-size:12.0pt\"> </span><span style=\"font-size:12.0pt;font-family:宋体\">、</span><em><span style=\"font-size:12.0pt\">h</span></em><span style=\"font-size:12.0pt;font-family:宋体\">。现要将其切成</span><em><span style=\"font-size:12.0pt\">m</span></em><span style=\"font-size:12.0pt;font-family:宋体\">块小蛋糕，每个小蛋糕都必须是矩形、且长和宽均为整数。切蛋糕时，每次切一块蛋糕，将其分成两个矩形蛋糕。请计算：最后得到的</span><em><span style=\"font-size:12.0pt\">m</span></em><span style=\"font-size:12.0pt;font-family:宋体\">块小蛋糕中，最大的那块蛋糕的面积下限。</span></p><p class=\"MsoNormal\" style=\"margin-left:21.0pt\"><span style=\"font-size:12.0pt;font-family:宋体\">假设</span><em><span style=\"font-size:12.0pt\">w</span></em><span style=\"font-size:12.0pt\">= 4, <em>h</em>= 4, <em>m</em>= 4</span><span style=\"font-size:12.0pt;font-family:宋体\">，则下面的切法可使得其中最大蛋糕块的面积最小。</span></p><p class=\"MsoNormal\" style=\"margin-left:21.0pt\"><img src=\"http://media.openjudge.cn/images/upload/1372385654.gif\" height=\"170\" width=\"171\"><br></p><p class=\"MsoNormal\" style=\"margin-top:auto;;margin-left:21.0pt;margin-top:auto;text-align:left;\"><span style=\"font-size:12.0pt;font-family:宋体\">假设</span><em><span style=\"font-size:12.0pt\">w</span></em><span style=\"font-size:12.0pt\">= 4, <em>h</em>= 4, <em>m</em>= 3</span><span style=\"font-size:12.0pt;font-family:宋体\">，则下面的切法会使得其中最大蛋糕块的面积最小</span><span style=\"font-size:12.0pt\">:</span></p><p class=\"MsoNormal\" style=\"margin-top:auto;;margin-left:21.0pt;margin-top:auto;text-align:left;\"><img src=\"http://media.openjudge.cn/images/upload/1372385663.gif\" height=\"176\" width=\"179\"><br></p><p class=\"MsoNormal\" style=\"margin-left:21.0pt\"><br></p>",
    "img": "",
    "inputTip": "共有多行，每行表示一个测试案例。每行是三个用空格分开的整数w, h, m ，其中1 ≤ w, h, m ≤ 20 ， m ≤ wh. 当 w = h = m = 0 时不需要处理，表示输入结束。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "每个测试案例的结果占一行，输出一个整数，表示最大蛋糕块的面积下限。",
    "inputExample": "<pre>4 4 4\n4 4 3\n0 0 0</pre>",
    "outputExample": "<pre>4\n6</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "610",
    "category": "4.5算法之动态规划",
    "title": "610:Banal Tickets",
    "description": "Peter is fond of number theory. That's why he is looking for interesting bus tickets. Ticket with the number of length 2N is called interesting if the product of the first N digits of its number is equal to the product of the last N digits. Other tickets are called banal. <br>Peter has found a used ticket in his pocket. Unfortunately the ticket was punched, so Peter cannot recognize some digits. He wonders whether this ticket was an interesting one. Moreover he wants to know how many different interesting and banal tickets could be punched to get this one.<br>Help Peter to find answers to his questions. ",
    "img": "",
    "inputTip": "The first line of the input file contains an integer N(1 <= N<=18). The next line contains a string representing the ticket number. If some digit is punched out it is denoted by \"?\" otherwise it is denoted by itself.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "On the first line of the output file print the number of interesting tickets. On the second line print the number of banal tickets.",
    "inputExample": "<pre>2 \n2??3</pre>",
    "outputExample": "<pre>4 \n96 </pre>",
    "tip": "Northeastern Europe 2003, Northern Subregion",
    "timeLimited": "5000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "663",
    "category": "4.5算法之动态规划",
    "title": "663:帮助 Jimmy",
    "description": " \"Help Jimmy\" 是在下图所示的场景上完成的游戏。<br><center><img src=\"http://media.openjudge.cn/images/1661_1.jpg\"></center><br>场景中包括多个长度和高度各不相同的平台。地面是最低的平台，高度为零，长度无限。<br><br>Jimmy老鼠在时刻0从高于所有平台的某处开始下落，它的下落速度始终为1米/秒。当Jimmy落到某个平台上时，游戏者选择让它向左还是向右跑，它跑动的速度也是1米/秒。当Jimmy跑到平台的边缘时，开始继续下落。Jimmy每次下落的高度不能超过MAX米，不然就会摔死，游戏也会结束。<br><br>设计一个程序，计算Jimmy到底地面时可能的最早时间。<br>",
    "img": "",
    "inputTip": "第一行是测试数据的组数t（0 <= t <= 20）。每组测试数据的第一行是四个整数N，X，Y，MAX，用空格分隔。N是平台的数目（不包括地面），X和Y是Jimmy开始下落的位置的横竖坐标，MAX是一次下落的最大高度。接下来的N行每行描述一个平台，包括三个整数，X1[i]，X2[i]和H[i]。H[i]表示平台的高度，X1[i]和X2[i]表示平台左右端点的横坐标。1 <= N <= 1000，-20000 <= X, X1[i], X2[i] <= 20000，0 < H[i] < Y <= 20000（i = 1..N）。所有坐标的单位都是米。Jimmy的大小和平台的厚度均忽略不计。如果Jimmy恰好落在某个平台的边缘，被视为落在平台上。所有的平台均不重叠或相连。测试数据保证问题一定有解。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对输入的每组测试数据，输出一个整数，Jimmy到底地面时可能的最早时间。",
    "inputExample": "<pre>1\n3 8 17 20\n0 10 8\n0 10 13\n4 14 3</pre>",
    "outputExample": "<pre>23</pre>",
    "tip": "POJ Monthly--2004.05.15 CEOI 2000",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "9276",
    "category": "4.5算法之动态规划",
    "title": "9276:Connected Graph",
    "description": "<p><span style=\"font-size: medium\">An undirected graph is a set V of vertices and a set of E∈{V*V} edges.An undirected graph is connected if and only if for every pair (u,v) of vertices,u is reachable from v. <br><br>You are to write a program that tries to calculate the number of different connected undirected graph with n vertices. <br>For example,there are 4 different connected undirected graphs with 3 vertices. <br></span></p>",
    "img": "",
    "inputTip": "The input contains several test cases.  Each test case contains an integer n, denoting the number of vertices.  You may assume that 1<=n<=50. The last test case is followed by  one zero. ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each test case output the answer on a single line. ",
    "inputExample": "<pre>1\n2\n3\n4\n0</pre>",
    "outputExample": "<pre>1\n1\n4\n38</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "131072kB"
  },
  {
    "id": "9279",
    "category": "4.5算法之动态规划",
    "title": "9279:[Seoul 2007]Tile走道铺砖",
    "description": "<p><span style=\"font-size: medium\">还是传统的走道铺砖问题，还是2行N列，现在给你三种砖，其规格分别为1*2,2*1,2*2。现在用这三种砖将走道铺满且砖与砖块之间不能重叠。问有多少种做法，值得注意的是：如果一种铺放的方法可以由另一个翻转过来得到则这两种只视为一种放法<br></span></p>",
    "img": "",
    "inputTip": "现给出N的值，请问有多少种不同的放法 ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "如题",
    "inputExample": "<pre>Sample input 1\n2\n\nSample input 2\n4</pre>",
    "outputExample": "<pre>Sample output 1\n3\nSample output 2\n8</pre>",
    "tip": "100%的数据,N<=10000",
    "timeLimited": "20000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "9286",
    "category": "4.5算法之动态规划",
    "title": "9286:盒子与小球之四",
    "description": "<p><span style=\"font-size: medium\">给定N个各不相同的小球，和M个不同的BOX，有多少种不同的放球方法，使得每个BOX里的小球个数不小于Ｋ。N,M,K均小于15<br></span></p>",
    "img": "",
    "inputTip": "每行给出Ｎ,M,K 以0 0 0结束",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "如题",
    "inputExample": "<pre>3 3 1\n2 4 1\n3 2 0\n0 0 0</pre>",
    "outputExample": "<pre>6\n0\n8</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "131072kB"
  },
  {
    "id": "97",
    "category": "4.5算法之动态规划",
    "title": "97:Trees Made to Order",
    "description": "We can number binary trees using the following scheme: <br>The empty tree is numbered 0.<br>The single-node tree is numbered 1.<br>All binary trees having m nodes have numbers less than all those having m+1 nodes.<br>Any binary tree having m nodes with left and right subtrees L and R is numbered n such that all trees having m nodes numbered > n have either Left subtrees numbered higher than L, or A left subtree = L and a right subtree numbered higher than R.<br><br>The first 10 binary trees and tree number 20 in this sequence are shown below:<br><center><img src=\"http://media.openjudge.cn/images/1095_1.gif\"></center><br>Your job for this problem is to output a binary tree when given its order number.<br>",
    "img": "",
    "inputTip": "Input consists of multiple problem instances. Each instance consists of a single integer n, where 1 <= n <= 500,000,000. A value of n = 0 terminates input. (Note that this means you will never have to output the empty tree.)",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each problem instance, you should output one line containing the tree corresponding to the order number for that instance. To print out the tree, use the following scheme:A tree with no children should be output as X.A tree with left and right subtrees L and R should be output as (L')X(R'), where L' and R' are the representations of L and R.  If L is empty, just output X(R').  If R is empty, just output (L')X.",
    "inputExample": "<pre>1\n20\n31117532\n0</pre>",
    "outputExample": "<pre>X\n((X)X(X))X\n(X(X(((X(X))X(X))X(X))))X(((X((X)X((X)X)))X)X)</pre>",
    "tip": "East Central North America 2001",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  }
]