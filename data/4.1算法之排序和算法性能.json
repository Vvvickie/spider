[
  {
    "id": "1625",
    "category": "4.1算法之排序和算法性能",
    "title": "1625:Sequence Median",
    "description": "Given a sequence of N nonnegative integers. Let's define the median of such sequence. If N is odd the median is the element with stands in the middle of the sequence after it is sorted. One may notice that in this case the median has position (N+1)/2 in sorted sequence if sequence elements are numbered starting with 1. If N is even then the median is the semi-sum of the two \"middle\" elements of sorted sequence. I.e. semi-sum of the elements in positions N/2 and (N/2)+1 of sorted sequence. But original sequence might be unsorted.<br><br>Your task is to write program to find the median of given sequence. ",
    "img": "",
    "inputTip": "The first line of input contains the only integer number N - the length of the sequence. Sequence itself follows in subsequent lines, one number in a line. The length of the sequence lies in the range from 1 to 250000. Each element of the sequence is a positive integer not greater than 2^32 - 1 inclusive. ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "You should print the value of the median with exactly one digit after decimal point. ",
    "inputExample": "<pre>4\n3\n6\n4\n5\n</pre>",
    "outputExample": "<pre>4.5</pre>",
    "tip": "Huge input,scanf is recommended.",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1754",
    "category": "4.1算法之排序和算法性能",
    "title": "1754:字符串数组排序问题",
    "description": "<p>给定一组字符串，按指定的排序方式输出这些字符串。排序可是自然顺序（inc）、自然逆序（dec）、忽略大小写顺序（ncinc）、忽略大小写逆序（ncdec）等。</p>",
    "img": "",
    "inputTip": "输入有多行，第一行为一个表明排序方式的字符串见题面，第二行为字符串的数目。其余各行每行一个字符串，字符串中间可能空格，前后也可能有空格，但前后的空格要忽略。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出也有多行，按指定的顺序输出输入的字符串。",
    "inputExample": "<pre>ncdec\n3\nHello World!\nYou're right!\nhaha! you're wrong!</pre>",
    "outputExample": "<pre>You're right!\nHello World!\nhaha! you're wrong!\n</pre>",
    "tip": "JP06",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1999",
    "category": "4.1算法之排序和算法性能",
    "title": "1999:日志排序",
    "description": "有一个网络日志，记录了网络中计算任务的执行情况，每个计算任务对应一条如下形式的日志记录：“hs_10000_p”是计算任务的名称，“2007-01-17 19:22:53,315”是计算任务开始执行的时间“年-月-日 时：分：秒，毫秒”， “253.035(s)”是计算任务消耗的时间(以秒计)<br>hs_10000_p   2007-01-17 19:22:53,315     253.035(s)<br>请你写一个程序，对日志中记录计算任务进行排序。时间消耗少的计算任务排在前面，时间消耗多的计算任务排在后面。如果两个计算任务消耗的时间相同，则将开始执行时间早的计算任务排在前面。<br>",
    "img": "",
    "inputTip": "日志中每个记录是一个字符串，每个字符串占一行。最后一行为空行，表示日志结束。日志中最多可能有10000条记录。计算任务名称的长度不超过10，开始执行时间的格式是YYYY-MM-DD HH:MM:SS,MMM，消耗时间小数点后有三位数字。计算任务名称与任务开始时间、消耗时间之间以一个或多个空格隔开，行首和行尾可能有多余的空格。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "排序好的日志记录。每个记录的字符串各占一行。输入的格式与输入保持一致，输入包括几个空格，你的输出中也应该包含同样多的空格。",
    "inputExample": "<pre>hs_10000_p   2007-01-17 19:22:53,315     253.035(s)\nhs_10001_p   2007-01-17 19:22:53,315     253.846(s)\nhs_10002_m   2007-01-17 19:22:53,315     129.574(s)\nhs_10002_p   2007-01-17 19:22:53,315     262.531(s)\nhs_10003_m   2007-01-17 19:22:53,318     126.622(s)\nhs_10003_p   2007-01-17 19:22:53,318     136.962(s)\nhs_10005_m   2007-01-17 19:22:53,318     130.487(s)\nhs_10005_p   2007-01-17 19:22:53,318     253.035(s)\nhs_10006_m   2007-01-17 19:22:53,318     248.548(s)\nhs_10006_p   2007-01-17 19:25:23,367    3146.827(s)\n</pre>",
    "outputExample": "<pre>hs_10003_m   2007-01-17 19:22:53,318     126.622(s)\nhs_10002_m   2007-01-17 19:22:53,315     129.574(s)\nhs_10005_m   2007-01-17 19:22:53,318     130.487(s)\nhs_10003_p   2007-01-17 19:22:53,318     136.962(s)\nhs_10006_m   2007-01-17 19:22:53,318     248.548(s)\nhs_10000_p   2007-01-17 19:22:53,315     253.035(s)\nhs_10005_p   2007-01-17 19:22:53,318     253.035(s)\nhs_10001_p   2007-01-17 19:22:53,315     253.846(s)\nhs_10002_p   2007-01-17 19:22:53,315     262.531(s)\nhs_10006_p   2007-01-17 19:25:23,367    3146.827(s)\n</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "4363",
    "category": "4.1算法之排序和算法性能",
    "title": "4363:瑞士轮",
    "description": "<p>【背景】 <br>在双人对决的竞技性比赛，如乒乓球、羽毛球、国际象棋中，最常见的赛制是淘汰赛和循环赛。前者的特点是比赛场数少，每场都紧张刺激，但偶然性较高。后者的特点是较为公<br>平，偶然性较低，但比赛过程往往十分冗长。 <br>本题中介绍的瑞士轮赛制，因最早使用于 1895 年在瑞士举办的国际象棋比赛而得名。它可以看作是淘汰赛与循环赛的折衷，既保证了比赛的稳定性，又能使赛程不至于过长。 <br> <br>【问题描述】 <br>2*N名编号为 1~2N的选手共进行 R轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。 选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。 每轮比赛的对阵安排与该轮比赛开始前的排名有关：第 1 名和第 2 名、第 3 名和第 4 名、……、第 2K – 1 名和第 2K名、……  、第 2N – 1 名和第2N名，各进行一场比赛。每场比赛胜者得 1 分，负者得 0 分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。 <br>现给定每个选手的初始分数及其实力值，试计算在 R 轮比赛过后，排名第 Q 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。</p><p><img style=\"WIDTH: 638px; HEIGHT: 152px\" src=\"http://media.openjudge.cn/images/upload/1324295443.png\" height=\"193\" width=\"717\"></p>",
    "img": "",
    "inputTip": "输入的第一行是三个正整数 N、R、Q，每两个数之间用一个空格隔开，表示有 2*N 名选手、R 轮比赛，以及我们关心的名次 Q。 第二行是 2*N个非负整数 s1, s2, …, s2N，每两个数之间用一个空格隔开，其中 si 表示编号为 i 的选手的初始分数。 第三行是 2*N个正整数 w1, w2, …, w2N，每两个数之间用一个空格隔开，其中 wi 表示编号为 i 的选手的实力值。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出只有一行，包含一个整数，即 R 轮比赛结束后，排名第 Q 的选手的编号。",
    "inputExample": "<pre>2 4 2 \n7 6 6 7 \n10 5 20 15 </pre>",
    "outputExample": "<pre>1</pre>",
    "tip": "对于 30%的数据，1 ≤ N ≤ 100； 对于 50%的数据，1 ≤ N ≤ 10,000； 对于 100%的数据， 1 ≤ N ≤ 100,000， 1 ≤ R ≤ 50， 1 ≤ Q ≤ 2N， 0 ≤ s1, s2, …, s2N ≤ 108， 1 ≤ w1, w2, …, w2N ≤ 108。",
    "timeLimited": "2000ms",
    "spaceLimited": "1000ms"
  }
]