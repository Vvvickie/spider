[
  {
    "id": "1481",
    "category": "2.6基本算法之动态规划",
    "title": "1481:Maximum sum",
    "description": "Given a set of n integers: A={a1, a2,..., an}, we define a function d(A) as below:<br><pre>                     t1     t2 <br>         d(A) = max{ ∑ai + ∑aj | 1 <= s1 <= t1 < s2 <= t2 <= n }<br>                    i=s1   j=s2</pre><br>Your task is to calculate d(A).",
    "img": "",
    "inputTip": "The input consists of T(<=30) test cases. The number of test cases (T) is given in the first line of the input. Each test case contains two lines. The first line is an integer n(2<=n<=50000). The second line contains n integers: a1, a2, ..., an. (|ai| <= 10000).There is an empty line after each case.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "Print exactly one line for each test case. The line should contain the integer d(A).",
    "inputExample": "<pre>1\n\n10\n1 -1 2 2 3 -3 4 -4 5 -5</pre>",
    "outputExample": "<pre>13</pre>",
    "tip": "In the sample, we choose {2,2,3,-3,4} and {5}, then we can get the answer.Huge input,scanf is recommended.",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "162",
    "category": "2.6基本算法之动态规划",
    "title": "162:Post Office",
    "description": "There is a straight highway with villages alongside the highway. The highway is represented as an integer axis, and the position of each village is identified with a single integer coordinate. There are no two villages in the same position. The distance between two positions is the absolute value of the difference of their integer coordinates.<br><br>Post offices will be built in some, but not necessarily all of the villages. A village and the post office in it have the same position. For building the post offices, their positions should be chosen so that the total sum of all distances between each village and its nearest post office is minimum.<br><br>You are to write a program which, given the positions of the villages and the number of post offices, computes the least possible sum of all distances between each village and its nearest post office. <br>",
    "img": "",
    "inputTip": "Your program is to read from standard input. The first line contains two integers: the first is the number of villages V, 1 <= V <= 300, and the second is the number of post offices P, 1 <= P <= 30, P <= V. The second line contains V integers in increasing order. These V integers are the positions of the villages. For each position X it holds that 1 <= X <= 10000.",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "The first line contains one integer S, which is the sum of all distances between each village and its nearest post office. ",
    "inputExample": "<pre>10 5\n1 2 3 6 7 9 11 22 44 50</pre>",
    "outputExample": "<pre>9</pre>",
    "tip": "IOI 2000",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1759",
    "category": "2.6基本算法之动态规划",
    "title": "1759:最长上升子序列",
    "description": "一个数的序列<i>b<sub>i</sub></i>，当<i>b<sub>1</sub></i> < <i>b<sub>2</sub></i> < ... < <i>b<sub>S</sub></i>的时候，我们称这个序列是上升的。对于给定的一个序列(<i>a<sub>1</sub></i>, <i>a<sub>2</sub></i>, ..., <i>a<sub>N</sub></i>)，我们可以得到一些上升的子序列(<i>a<sub>i<sub>1</sub></sub></i>, <i>a<sub>i<sub>2</sub></sub></i>, ..., <i>a<sub>i<sub>K</sub></sub></i>)，这里1 <= <i>i<sub>1</sub></i> < <i>i<sub>2</sub></i> < ... < <i>i<sub>K</sub></i> <= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中最长的长度是4，比如子序列(1, 3, 5, 8).<br><br>你的任务，就是对于给定的序列，求出最长上升子序列的长度。",
    "img": "",
    "inputTip": "输入的第一行是序列的长度N (1 <= N <= 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "最长上升子序列的长度。",
    "inputExample": "<pre>7\n1 7 3 5 9 4 8</pre>",
    "outputExample": "<pre>4\n</pre>",
    "tip": "翻译自 Northeastern Europe 2002, Far-Eastern Subregion 的比赛试题",
    "timeLimited": "2000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1768",
    "category": "2.6基本算法之动态规划",
    "title": "1768:最大子矩阵",
    "description": "已知矩阵的大小定义为矩阵中所有元素的和。给定一个矩阵，你的任务是找到最大的非空(大小至少是1 * 1)子矩阵。<br><br>比如，如下4 * 4的矩阵<br><br> 0 -2 -7  0<br> 9  2 -6  2<br>-4  1 -4  1<br>-1  8  0 -2<br><br>的最大子矩阵是<br><br> 9  2<br>-4  1<br>-1  8<br><br>这个子矩阵的大小是15。",
    "img": "",
    "inputTip": "输入是一个N * N的矩阵。输入的第一行给出N (0 < N <= 100)。再后面的若干行中，依次（首先从左到右给出第一行的N个整数，再从左到右给出第二行的N个整数……）给出矩阵中的N2个整数，整数之间由空白字符分隔（空格或者空行）。已知矩阵中整数的范围都在[-127, 127]。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出最大子矩阵的大小。",
    "inputExample": "<pre>4\n0 -2 -7 0 9 2 -6 2\n-4 1 -4  1 -1\n\n8  0 -2</pre>",
    "outputExample": "<pre>15</pre>",
    "tip": "翻译自 Greater New York 2001 的试题",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1775",
    "category": "2.6基本算法之动态规划",
    "title": "1775:采药",
    "description": "辰辰是个很有潜能、天资聪颖的孩子，他的梦想是称为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”<br> <br>如果你是辰辰，你能完成这个任务吗？<br>",
    "img": "",
    "inputTip": "输入的第一行有两个整数T（1 <= T <= 1000）和M（1 <= M <= 100），T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到100之间（包括1和100）的的整数，分别表示采摘某株草药的时间和这株草药的价值。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出只包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。",
    "inputExample": "<pre>70 3\n71 100\n69 1\n1 2\n</pre>",
    "outputExample": "<pre>3</pre>",
    "tip": "NOIP 2005",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1808",
    "category": "2.6基本算法之动态规划",
    "title": "1808:公共子序列",
    "description": "我们称序列Z = < z<sub>1</sub>, z<sub>2</sub>, ..., z<sub>k</sub> >是序列X = < x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>m</sub> >的子序列当且仅当存在 <b>严格上升</b> 的序列< i<sub>1</sub>, i<sub>2</sub>, ..., i<sub>k</sub> >，使得对j = 1, 2, ... ,k, 有x<sub>i<sub>j</sub></sub> = z<sub>j</sub>。比如Z = < a, b, f, c > 是X = < a, b, c, f, b, c >的子序列。<br><br>现在给出两个序列X和Y，你的任务是找到X和Y的最大公共子序列，也就是说要找到一个最长的序列Z，使得Z既是X的子序列也是Y的子序列。<br>",
    "img": "",
    "inputTip": "输入包括多组测试数据。每组数据包括一行，给出两个长度不超过200的字符串，表示两个序列。两个字符串之间由若干个空格隔开。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对每组输入数据，输出一行，给出两个序列的最大公共子序列的长度。",
    "inputExample": "<pre>abcfbc         abfcab\nprogramming    contest \nabcd           mnp\n</pre>",
    "outputExample": "<pre>4\n2\n0\n</pre>",
    "tip": "翻译自Southeastern Europe 2003的试题",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1944",
    "category": "2.6基本算法之动态规划",
    "title": "1944:吃糖果",
    "description": "名名的妈妈从外地出差回来，带了一盒好吃又精美的巧克力给名名（盒内共有 N 块巧克力，20 > N >0）。妈妈告诉名名每天可以吃一块或者两块巧克力。假设名名每天都吃巧克力，问名名共有多少种不同的吃完巧克力的方案。例如：如果N=1，则名名第1天就吃掉它，共有1种方案；如果N=2，则名名可以第1天吃1块，第2天吃1块，也可以第1天吃2块，共有2种方案；如果N=3，则名名第1天可以吃1块，剩2块，也可以第1天吃2块剩1块，所以名名共有2+1=3种方案；如果N=4，则名名可以第1天吃1块，剩3块，也可以第1天吃2块，剩2块，共有3+2=5种方案。现在给定N，请你写程序求出名名吃巧克力的方案数目。",
    "img": "",
    "inputTip": "输入只有1行，即整数N。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出只有1行，即名名吃巧克力的方案数。",
    "inputExample": "<pre>4</pre>",
    "outputExample": "<pre>5\n</pre>",
    "tip": "医学部计算概论2006期末考试题",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "1996",
    "category": "2.6基本算法之动态规划",
    "title": "1996:登山",
    "description": "<p>五一到了，PKU-ACM队组织大家去登山观光，队员们发现山上一个有N个景点，并且决定按照顺序来浏览这些景点，即每次所浏览景点的编号都要大于前一个浏览景点的编号。同时队员们还有另一个登山习惯，就是不连续浏览海拔相同的两个景点，并且一旦开始下山，就不再向上走了。队员们希望在满足上面条件的同时，尽可能多的浏览景点，你能帮他们找出最多可能浏览的景点数么？<br></p>",
    "img": "",
    "inputTip": "Line 1： N (2 <= N <= 1000) 景点数Line 2： N个整数，每个景点的海拔",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "最多能浏览的景点数",
    "inputExample": "<pre>8\n186 186 150 200 160 130 197 220</pre>",
    "outputExample": "<pre>4</pre>",
    "tip": "第六届北京大学程序设计大赛暨ACM/ICPC选拔赛",
    "timeLimited": "5000ms",
    "spaceLimited": "131072kB"
  },
  {
    "id": "2000",
    "category": "2.6基本算法之动态规划",
    "title": "2000:最长公共子上升序列",
    "description": "给定两个整数序列，写一个程序求它们的最长上升公共子序列。<br>当以下条件满足的时候，我们将长度为N的序列S<sub>1</sub> , S<sub>2</sub> , . . . , S<sub>N</sub> 称为长度为M的序列A<sub>1</sub> , A<sub>2</sub> , . . . , A<sub>M </sub>的上升子序列：<br><br>存在 1 <= i<sub>1</sub> < i<sub>2</sub> < . . . < i<sub>N</sub> <= M ，使得对所有 1 <= j <=N，均有S<sub>j</sub> = A<sub>i<sub>j，</sub></sub>且对于所有的1 <= j < N，均有S<sub>j</sub> < S<sub>j+1</sub>。<br><br>",
    "img": "",
    "inputTip": "每个序列用两行表示，第一行是长度M(1 <= M <= 500)，第二行是该序列的M个整数Ai (-231 <= Ai < 231 )",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "在第一行，输出两个序列的最长上升公共子序列的长度L。在第二行，输出该子序列。如果有不止一个符合条件的子序列，则输出任何一个即可。",
    "inputExample": "<pre>5\n1 4 2 5 -12\n4\n-12 1 2 4</pre>",
    "outputExample": "<pre>2\n1 4</pre>",
    "tip": "",
    "timeLimited": "10000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2421",
    "category": "2.6基本算法之动态规划",
    "title": "2421:Exchange Rates\n",
    "description": "Now that the Loonie is hovering about par with the Greenback, you have decided to use your $1000 entrance scholarship to engage in currency speculation. So you gaze into a crystal ball which predicts the closing exchange rate between Canadian and U.S. dollars for each of the next several days. On any given day, you can switch all of your money from Canadian to U.S. dollars, or vice versa, at the prevailing exchange rate, less a 3% commission, less any fraction of a cent. <br>Assuming your crystal ball is correct, what's the maximum amount of money you can have, in Canadian dollars, when you're done? <br>",
    "img": "",
    "inputTip": "The input contains a number of test cases, followed by a line containing 0. Each test case begins with 0 <d ≤ 365, the number of days that your crystal ball can predict. d lines follow, giving the price of a U.S. dollar in Canadian dollars, as a real number. ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each test case, output a line giving the maximum amount of money, in Canadian dollars and cents, that it is possible to have at the end of the last prediction, assuming you may exchange money on any subset of the predicted days, in order. ",
    "inputExample": "<pre>3\n1.0500\n0.9300\n0.9900\n2\n1.0500\n1.1000\n0</pre>",
    "outputExample": "<pre>1001.60\n1000.00</pre>",
    "tip": "Waterloo",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2718",
    "category": "2.6基本算法之动态规划",
    "title": "2718:移动路线",
    "description": "×桌子上有一个m行n列的方格矩阵，将每个方格用坐标表示，行坐标从下到上依次递增，列坐标从左至右依次递增，左下角方格的坐标为(1,1)，则右上角方格的坐标为(m,n)。<br>        小明是个调皮的孩子，一天他捉来一只蚂蚁，不小心把蚂蚁的右脚弄伤了，于是蚂蚁只能向上或向右移动。小明把这只蚂蚁放在左下角的方格中，蚂蚁从<br>左下角的方格中移动到右上角的方格中，每步移动一个方格。蚂蚁始终在方格矩阵内移动，请计算出不同的移动路线的数目。<br>        对于1行1列的方格矩阵，蚂蚁原地移动，移动路线数为1；对于1行2列（或2行1列）的方格矩阵，蚂蚁只需一次向右（或向上）移动，移动路线数也为1……对于一个2行3列的方格矩阵，如下图所示：<br><br>        -------------------<br>        |(2,1)|(2,2)|(2,3)|<br>        -------------------<br>        |(1,1)|(1,2)|(1,3)|<br>        -------------------<br><br>    蚂蚁共有3种移动路线：<br>    路线1：(1,1) → (1,2) → (1,3) → (2,3)<br>    路线2：(1,1) → (1,2) → (2,2) → (2,3)<br>    路线3：(1,1) → (2,1) → (2,2) → (2,3)<br>",
    "img": "",
    "inputTip": "输入只有一行，包括两个整数m和n（0<m+n<=20），代表方格矩阵的行数和列数，m、n之间用空格隔开",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出只有一行，为不同的移动路线的数目。",
    "inputExample": "<pre>2 3</pre>",
    "outputExample": "<pre>3</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2728",
    "category": "2.6基本算法之动态规划",
    "title": "2728:摘花生",
    "description": "Hello Kitty 想摘点花生送给她喜欢的米老鼠。她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。Hello Kitty只能向东或向南走，不能向西或向北走。问Hello Kitty 最多能够摘到多少颗花生。<br><center> <img src=\"http://media.openjudge.cn/images/3726.JPG\"><br></center>",
    "img": "",
    "inputTip": "第一行是一个整数T，代表一共有多少组数据。1<=T <= 100接下来是T组数据。每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C ( 1<= R,C <=100)每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有 C 个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目 M ( 0<= M <= 1000)。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对每组输入数据，输出一行，内容为Hello Kitty能摘到得最多的花生颗数。",
    "inputExample": "<pre>2\n2 2\n1 1\n3 4\n2 3\n2 3 4\n1 6 5\n</pre>",
    "outputExample": "<pre>8\n16\n</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2985",
    "category": "2.6基本算法之动态规划",
    "title": "2985:数字组合",
    "description": "有n个正整数，找出其中和为t(t也是正整数)的可能的组合方式。如：<br>n=5,5个数分别为1,2,3,4,5，t=5；<br>那么可能的组合有5=1+4和5=2+3和5=5三种组合方式。",
    "img": "",
    "inputTip": "输入的第一行是两个正整数n和t，用空格隔开，其中1<=n<=20,表示正整数的个数，t为要求的和(1<=t<=1000)接下来的一行是n个正整数，用空格隔开。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "和为t的不同的组合方式的数目。",
    "inputExample": "<pre>5 5\n1 2 3 4 5</pre>",
    "outputExample": "<pre>3</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2988",
    "category": "2.6基本算法之动态规划",
    "title": "2988:计算字符串距离",
    "description": "对于两个不同的字符串，我们有一套操作方法来把他们变得相同，具体方法为：<ol><li>修改一个字符（如把“a”替换为“b”）</li><li>删除一个字符（如把“traveling”变为“travelng”）</li></ol><br>比如对于“abcdefg”和“abcdef”两个字符串来说，我们认为可以通过增加/减少一个“g”的方式来达到目的。无论增加还是减少“g”，我们都仅仅需要一次操作。我们把这个操作所需要的次数定义为两个字符串的距离。 <br>给定任意两个字符串，写出一个算法来计算出他们的距离。",
    "img": "",
    "inputTip": "第一行有一个整数n。表示测试数据的组数，接下来共n行，每行两个字符串，用空格隔开。表示要计算距离的两个字符串字符串长度不超过1000。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "针对每一组测试数据输出一个整数，值为两个字符串的距离。",
    "inputExample": "<pre>3\nabcdefg  abcdef\nab ab\nmnklj jlknm</pre>",
    "outputExample": "<pre>1\n0\n4</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "2989",
    "category": "2.6基本算法之动态规划",
    "title": "2989:糖果",
    "description": "由于在维护世界和平的事务中做出巨大贡献，Dzx被赠予糖果公司2010年5月23日当天无限量糖果免费优惠券。在这一天，Dzx可以从糖果公司的N件产品中任意选择若干件带回家享用。糖果公司的N件产品每件都包含数量不同的糖果。Dzx希望他选择的产品包含的糖果总数是K的整数倍，这样他才能平均地将糖果分给帮助他维护世界和平的伙伴们。当然，在满足这一条件的基础上，糖果总数越多越好。Dzx最多能带走多少糖果呢？<br>注意：Dzx只能将糖果公司的产品整件带走。",
    "img": "",
    "inputTip": "第一行包含两个整数N(1<=N<=100)和K(1<=K<=100)以下N行每行1个整数，表示糖果公司该件产品中包含的糖果数目，不超过1000000",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "符合要求的最多能达到的糖果总数，如果不能达到K的倍数这一要求，输出0",
    "inputExample": "<pre>5 7\n1\n2\n3\n4\n5</pre>",
    "outputExample": "<pre>14</pre>",
    "tip": "Dzx的选择是2+3+4+5=14，这样糖果总数是7的倍数，并且是总数最多的选择。",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "3531",
    "category": "2.6基本算法之动态规划",
    "title": "3531:判断整除",
    "description": "<p>一个给定的正整数序列，在每个数之前都插入+号或-号后计算它们的和。比如序列：1、2、4共有8种可能的序列：<br>(+1) + (+2) + (+4) = 7<br>(+1) + (+2) + (-4) = -1<br>(+1) + (-2) + (+4) = 3<br>(+1) + (-2) + (-4) = -5<br>(-1) + (+2) + (+4) = 5<br>(-1) + (+2) + (-4) = -3<br>(-1) + (-2) + (+4) = 1<br>(-1) + (-2) + (-4) = -7<br>所有结果中至少有一个可被整数k整除，我们则称此正整数序列可被k整除。例如上述序列可以被3、5、7整除，而不能被2、4、6、8……整除。注意：0、-3、-6、-9……都可以认为是3的倍数。</p>",
    "img": "",
    "inputTip": "输入的第一行包含两个数：N（2 < N < 10000）和k(2 < k< 100)，其中N代表一共有N个数，k代表被除数。第二行给出序列中的N个整数，这些整数的取值范围都0到10000之间（可能重复）。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "如果此正整数序列可被k整除，则输出YES，否则输出NO。（注意：都是大写字母）",
    "inputExample": "<pre>3 2\n1 2 4\n</pre>",
    "outputExample": "<pre>NO</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "3532",
    "category": "2.6基本算法之动态规划",
    "title": "3532:最大上升子序列和",
    "description": "<p>一个数的序列bi，当b1 < b2 < ... < bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, ...,aN)，我们可以得到一些上升的子序列(ai1, ai2, ..., aiK)，这里1 <= i1 < i2 < ... < iK <= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中序列和最大为18，为子序列(1, 3, 5, 9)的和.<br><br>你的任务，就是对于给定的序列，求出最大上升子序列和。注意，最长的上升子序列的和不一定是最大的，比如序列(100, 1, 2, 3)的最大上升子序列和为100，而最长上升子序列为(1, 2, 3)</p>",
    "img": "",
    "inputTip": "输入的第一行是序列的长度N (1 <= N <= 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000（可能重复）。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "最大上升子序列和",
    "inputExample": "<pre>7\n1 7 3 5 9 4 8\n</pre>",
    "outputExample": "<pre>18</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "4977",
    "category": "2.6基本算法之动态规划",
    "title": "4977:怪盗基德的滑翔翼",
    "description": "<p style=\"margin-bottom: 0in;\"></p><p style=\"margin-bottom: 0in\"><span style=\"font-family:DejaVu Sans\">怪盗基德是一个充满传奇色彩的怪盗，专门以珠宝为目标的超级盗窃犯。而他最为突出的地方，就是他每次都能逃脱中村警部的重重围堵，而这也很大程度上是多亏了他随身携带的便于操作的滑翔翼。</span></p><p style=\"margin-bottom: 0in;\"><span style=\"font-family: DejaVu Sans\">有一天，怪盗基德像往常一样偷走了一颗珍贵的钻石，不料却被柯南小朋友识破了伪装，而他的滑翔翼的动力装置也被柯南踢出的足球破坏了。不得已，怪盗基德只能操作受损的滑翔翼逃脱。</span></p><p style=\"margin-bottom: 0in\"><img style=\"width: 611px; height: 458px;\" src=\"http://media.openjudge.cn/images/upload/1340073200.jpg\"><br></p><p style=\"margin-bottom: 0in\"><span style=\"font-family:DejaVu Sans\">假设城市中一共有</span>N<span style=\"font-family:DejaVu Sans\">幢建筑排成一条线，每幢建筑的高度各不相同。初始时，怪盗基德可以在任何一幢建筑的顶端。他可以选择一个方向逃跑，但是不能中途改变方向（因为中森警部会在后面追击）。因为滑翔翼动力装置受损，他只能往下滑行（即：只能从较高的建筑滑翔到较低的建筑）。他希望尽可能多地经过不同建筑的顶部，这样可以减缓下降时的冲击力，减少受伤的可能性。请问，他最多可以经过多少幢不同建筑的顶部（包含初始时的建筑）？</span></p><p style=\"margin-bottom: 0in;\"><br></p>",
    "img": "",
    "inputTip": "输入数据第一行是一个整数K（K < 100），代表有K组测试数据。每组测试数据包含两行：第一行是一个整数N(N < 100)，代表有N幢建筑。第二行包含N个不同的整数，每一个对应一幢建筑的高度h（0 < h < 10000），按照建筑的排列顺序给出。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对于每一组测试数据，输出一行，包含一个整数，代表怪盗基德最多可以经过的建筑数量。",
    "inputExample": "<pre>3\n8\n300 207 155 299 298 170 158 65\n8\n65 158 170 298 299 155 207 300\n10\n2 1 3 4 5 6 7 8 9 10</pre>",
    "outputExample": "<pre>6\n6\n9</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "4978",
    "category": "2.6基本算法之动态规划",
    "title": "4978:宠物小精灵之收服",
    "description": "<p style=\"margin-bottom: 0in;\"><span style=\"font-family: DejaVu Sans\">宠物小精灵是一部讲述小智和他的搭档皮卡丘一起冒险的故事。</span></p><p style=\"margin-bottom: 0in\"><img style=\"width: 614px; height: 347px;\" src=\"http://media.openjudge.cn/images/upload/1340073461.jpg\"><br></p><p style=\"margin-bottom: 0in\"><span style=\"font-family:DejaVu Sans\">一天，小智和皮卡丘来到了小精灵狩猎场，里面有很多珍贵的野生宠物小精灵。小智也想收服其中的一些小精灵。然而，野生的小精灵并不那么容易被收服。对于每一个野生小精灵而言，小智可能需要使用很多个精灵球才能收服它，而在收服过程中，野生小精灵也会对皮卡丘造成一定的伤害（从而减少皮卡丘的体力）。当皮卡丘的体力小于等于</span>0<span style=\"font-family:DejaVu Sans\">时，小智就必须结束狩猎（因为他需要给皮卡丘疗伤），而使得皮卡丘体力小于等于</span>0<span style=\"font-family:DejaVu Sans\">的野生小精灵也不会被小智收服。当小智的精灵球用完时，狩猎也宣告结束。</span></p><p style=\"margin-bottom: 0in\"><span style=\"font-family:DejaVu Sans\">我们假设小智遇到野生小精灵时有两个选择：收服它，或者离开它。如果小智选择了收服，那么一定会扔出能够收服该小精灵的精灵球，而皮卡丘也一定会受到相应的伤害；如果选择离开它，那么小智不会损失精灵球，皮卡丘也不会损失体力。</span></p><p style=\"margin-bottom: 0in\"><span style=\"font-family:DejaVu Sans\">小智的目标有两个：主要目标是收服尽可能多的野生小精灵；如果可以收服的小精灵数量一样，小智希望皮卡丘受到的伤害越小（剩余体力越大），因为他们还要继续冒险。</span></p><p style=\"margin-bottom: 0in\"><span style=\"font-family:DejaVu Sans\">现在已知小智的精灵球数量和皮卡丘的初始体力，已知每一个小精灵需要的用于收服的精灵球数目和它在被收服过程中会对皮卡丘造成的伤害数目。请问，小智该如何选择收服哪些小精灵以达到他的目标呢？</span></p>",
    "img": "",
    "inputTip": "输入数据的第一行包含三个整数：N(0 < N < 1000)，M(0 < M < 500)，K(0 < K < 100)，分别代表小智的精灵球数量、皮卡丘初始的体力值、野生小精灵的数量。之后的K行，每一行代表一个野生小精灵，包括两个整数：收服该小精灵需要的精灵球的数量，以及收服过程中对皮卡丘造成的伤害。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出为一行，包含两个整数：C，R，分别表示最多收服C个小精灵，以及收服C个小精灵时皮卡丘的剩余体力值最多为R。",
    "inputExample": "<pre>样例输入1：\n10 100 5\n7 10\n2 40\n2 50\n1 20\n4 20\n\n样例输入2：\n10 100 5\n8 110\n12 10\n20 10\n5 200\n1 110\n</pre>",
    "outputExample": "<pre>样例输出1：\n3 30\n\n样例输出2：\n0 100</pre>",
    "tip": "对于样例输入1：小智选择：(7,10) (2,40) (1,20) 这样小智一共收服了3个小精灵，皮卡丘受到了70点伤害，剩余100-70=30点体力。所以输出3  30对于样例输入2：小智一个小精灵都没法收服，皮卡丘也不会收到任何伤害，所以输出0  100",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "4982",
    "category": "2.6基本算法之动态规划",
    "title": "4982:踩方格",
    "description": "<p>有一个方格矩阵，矩阵边界在无穷远处。我们做如下假设：<br>a.    每走一步时，只能从当前方格移动一格，走到某个相邻的方格上；<br>b.    走过的格子立即塌陷无法再走第二次；<br>c.    只能向北、东、西三个方向走；<br>请问：如果允许在方格矩阵上走n步，共有多少种不同的方案。2种走法只要有一步不一样，即被认为是不同的方案。<br></p>",
    "img": "",
    "inputTip": "允许在方格上行走的步数n(n <= 20)",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "计算出的方案数量",
    "inputExample": "<pre>2</pre>",
    "outputExample": "<pre>7</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "6045",
    "category": "2.6基本算法之动态规划",
    "title": "6045:开餐馆",
    "description": "<p class=\"MsoNormal\" style=\"margin-bottom:0cm;margin-bottom:.0001pt;line-height:normal;;text-autospace:none\"><span style=\"font-size:10.5pt;font-family:楷体\">北大信息学院的同学小明毕业之后打算创业开餐馆</span><span style=\"font-size:12.0pt;font-family:楷体\">.</span><span style=\"font-size:10.5pt;font-family:楷体\">现在共有</span><span style=\"font-size:12.0pt;font-family:楷体\">n </span><span style=\"font-size:10.5pt;font-family:楷体\">个地点可供选择。小明打算从中选择合适的位置开设一些餐馆。这 </span><span style=\"font-size:12.0pt;font-family:楷体\">n </span><span style=\"font-size:10.5pt;font-family:楷体\">个地点排列在同一条直线上。我们用一个整数序列</span><span style=\"font-size:12.0pt;font-family:'Times New Roman','serif'\">m<sub>1</sub>, m<sub>2</sub>, ... m<sub>n</sub> </span><span style=\"font-size:10.5pt;font-family:楷体\">来表示他们的相对位置。由于地段关系</span><span style=\"font-size:12.0pt;font-family:楷体\">,</span><span style=\"font-size:10.5pt;font-family:楷体\">开餐馆的利润会有所不同。我们用</span><span style=\"font-size:12.0pt;font-family:'Times New Roman','serif'\">p<sub>i</sub></span><span style=\"font-size:12.0pt;font-family:楷体\"> </span><span style=\"font-size:10.5pt;font-family:楷体\">表示在</span><span style=\"font-size:12.0pt;font-family:'Times New Roman','serif'\">m<sub>i</sub></span><span style=\"font-size:12.0pt;font-family:楷体\"> </span><span style=\"font-size:10.5pt;font-family:楷体\">处开餐馆的利润。为了避免自己的餐馆的内部竞争</span><span style=\"font-size:12.0pt;font-family:楷体\">,</span><span style=\"font-size:10.5pt;font-family:楷体\">餐馆之间的距离必须大于</span><span style=\"font-size:12.0pt;font-family:楷体\">k</span><span style=\"font-size:10.5pt;font-family:楷体\">。请你帮助小明选择一个总利润最大的方案。</span></p><p><br></p>",
    "img": "",
    "inputTip": "标准的输入包含若干组测试数据。输入第一行是整数T (1 <= T <= 1000) ，表明有T组测试数据。紧接着有T组连续的测试。每组测试数据有3行,第1行:地点总数 n (n < 100), 距离限制 k (k > 0 && k < 1000).第2行:n 个地点的位置m1 , m2, ... mn ( 1000000  > mi > 0 且为整数,升序排列)第3行:n 个地点的餐馆利润p1 , p2, ... pn ( 1000 > pi > 0 且为整数)",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对于每组测试数据可能的最大利润",
    "inputExample": "<pre>2\n3 11\n1 2 15\n10 2 30\n3 16\n1 2 15\n10 2 30</pre>",
    "outputExample": "<pre>40\n30</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "6046",
    "category": "2.6基本算法之动态规划",
    "title": "6046:数据包的调度机制",
    "description": "<p class=\"MsoNormal\" style=\"margin-bottom:0cm;margin-bottom:.0001pt;line-height:normal;;text-autospace:none\"><span style=\"font-size:10.5pt;font-family:楷体\">随着 </span><span style=\"font-size:12.0pt;font-family:楷体\">Internet</span><span style=\"font-size:10.5pt;font-family:楷体\">的迅猛发展</span><span style=\"font-size:12.0pt;font-family:楷体\">,</span><span style=\"font-size:10.5pt;font-family:楷体\">多媒体技术和电子商务应用日益广泛</span><span style=\"font-size:12.0pt;font-family:楷体\">,Internet</span><span style=\"font-size:10.5pt;font-family:楷体\">上的服务质量</span></p><p class=\"MsoNormal\" style=\"margin-bottom:0cm;margin-bottom:.0001pt;line-height:normal;;text-autospace:none\"><span style=\"font-size:12.0pt;font-family:楷体\">(QoS,Qualityof Service)</span><span style=\"font-size:10.5pt;font-family:楷体\">问题已越来越受到重视。网络中采用的数据包调度机制与网络的服务质量 </span><span style=\"font-size:12.0pt;font-family:楷体\">QoS </span><span style=\"font-size:10.5pt;font-family:楷体\">有着密切的关系。研究表明传统的基于队列的调度机制已不能满足网络服务质量</span><span style=\"font-size:12.0pt;font-family:楷体\">QoS </span><span style=\"font-size:10.5pt;font-family:楷体\">的需求。服务质量 </span><span style=\"font-size:12.0pt;font-family:楷体\">QoS </span><span style=\"font-size:10.5pt;font-family:楷体\">取决于数据包的延迟。每一个数据包都有一个延迟惩罚值。由于数据包承载的数据不同</span><span style=\"font-size:12.0pt;font-family:楷体\">,</span><span style=\"font-size:10.5pt;font-family:楷体\">不同数据包的延迟惩罚值也可能不同。此外</span><span style=\"font-size:12.0pt;font-family:楷体\">,</span><span style=\"font-size:10.5pt;font-family:楷体\">数据包的延迟也和它的发送顺序有关。如果一个数据包被第</span><span style=\"font-size:12.0pt;font-family:楷体\">K</span><span style=\"font-size:10.5pt;font-family:楷体\">个发送</span><span style=\"font-size:12.0pt;font-family:楷体\">,</span><span style=\"font-size:10.5pt;font-family:楷体\">假设它的延迟惩罚值是</span><span style=\"font-size:12.0pt;font-family:楷体\">D,</span><span style=\"font-size:10.5pt;font-family:楷体\">则这个数据包的最终延迟是 </span><span style=\"font-size:12.0pt;font-family:楷体\">(K - 1) * D</span><span style=\"font-size:10.5pt;font-family:楷体\">。北京大学</span><span style=\"font-size:12.0pt;font-family:楷体\">2012 </span><span style=\"font-size:10.5pt;font-family:楷体\">级信息学院的同学在程序设计课堂上</span><span style=\"font-size:12.0pt;font-family:楷体\">,</span><span style=\"font-size:10.5pt;font-family:楷体\">设计了一种新的基于栈的数据包的调度算法。同学们通过栈的先进后出<span>(Last in First out)</span>的原理</span><span style=\"font-size:12.0pt;font-family:楷体\">,</span><span style=\"font-size:10.5pt;font-family:楷体\">改变数据包的发送顺序</span><span style=\"font-size:12.0pt;font-family:楷体\">,</span><span style=\"font-size:10.5pt;font-family:楷体\">以减小数据包的延迟总值。给定</span><span style=\"font-size:12.0pt;font-family:楷体\">N </span><span style=\"font-size:10.5pt;font-family:楷体\">个等待调度的数据包</span><span style=\"font-size:12.0pt;font-family:楷体\">,</span><span style=\"font-size:10.5pt;font-family:楷体\">起始这</span><span style=\"font-size:12.0pt;font-family:楷体\">N </span><span style=\"font-size:10.5pt;font-family:楷体\">个数据包排成一个队列等待发送。接着<span>,</span>这些数据包按序进栈</span><span style=\"font-size:12.0pt;font-family:楷体\">,</span><span style=\"font-size:10.5pt;font-family:楷体\">调度算法可以控制数据包的出栈顺序。因此通过栈</span><span style=\"font-size:12.0pt;font-family:楷体\">,</span><span style=\"font-size:10.5pt;font-family:楷体\">可以将后面的数据包先于前面的数据包发送出去。请你实现一个调度算法使</span><span style=\"font-size:12.0pt;font-family:楷体\">N </span><span style=\"font-size:10.5pt;font-family:楷体\">个数据包的延迟总值最小。</span></p>",
    "img": "",
    "inputTip": "标准的输入包含若干组测试数据。输入第一行是整数T(1 <= T <= 1000)，表明有T组测试数据。紧接着有T组连续的测试。每一组测试数据的第1行是 N（N <= 100）,表述数据包的个数。接着的 N 行,每一行是一个整数,第i 行表示数据包i的延迟惩罚值( <=50 )。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对于每组测试数据，输出最小的延迟总值。",
    "inputExample": "<pre>1\n5\n5\n4\n3\n2\n2</pre>",
    "outputExample": "<pre>24</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "6049",
    "category": "2.6基本算法之动态规划",
    "title": "6049:买书",
    "description": "<p class=\"MsoNormal\"><span style=\"font-size:12.0pt;font-family:宋体\">小明手里有</span><span style=\"font-size:12.0pt\">n</span><span style=\"font-size:12.0pt;font-family:宋体\">元钱全部用来买书，书的价格为</span><span style=\"font-size:12.0pt\">10</span><span style=\"font-size:12.0pt;font-family:宋体\">元，</span><span style=\"font-size:12.0pt\">20</span><span style=\"font-size:12.0pt;font-family:宋体\">元，</span><span style=\"font-size:12.0pt\">50</span><span style=\"font-size:12.0pt;font-family:宋体\"><wbr>元，</span><span style=\"font-size:12.0pt\">100</span><span style=\"font-size:12.0pt;font-family:宋体\">元。</span></p><p><span style=\"font-size:12.0pt;font-family:宋体\">问小明有多少种买书方案？（每种书可购买多本）</span></p>",
    "img": "",
    "inputTip": "一个整数 n，代表总共钱数。（0 <= n <= 1000）",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个整数，代表选择方案种数",
    "inputExample": "<pre>样例输入1：\n20\n\n样例输入2：\n15\n\n样例输入3：\n0</pre>",
    "outputExample": "<pre>样例输出1：\n2\n\n样例输出2：\n0\n\n样例输出3：\n0 </pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "6252",
    "category": "2.6基本算法之动态规划",
    "title": "6252:带通配符的字符串匹配",
    "description": "<p>通配符是一类键盘字符，当我们不知道真正字符或者不想键入完整名字时，常常使用通配符代替一个或多个真正字符。通配符有问号(?)和星号(*)等，其中，“?”可以代替一个字符，而“*”可以代替零个或多个字符。\n<br><br>你的任务是，给出一个带有通配符的字符串和一个不带通配符的字符串，判断他们是否能够匹配。\n<br><br>例如，1?456 可以匹配 12456、13456、1a456，但是却不能够匹配23456、1aa456；\n<br>2*77?8可以匹配 24457798、237708、27798。<br></p>",
    "img": "",
    "inputTip": "输入有两行，每行为一个不超过20个字符的字符串，第一行带通配符，第二行不带通配符",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "如果两者可以匹配，就输出“matched”，否则输出“not matched”",
    "inputExample": "<pre>1*456?\n11111114567</pre>",
    "outputExample": "<pre>matched</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "666",
    "category": "2.6基本算法之动态规划",
    "title": "666:放苹果",
    "description": "把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。",
    "img": "",
    "inputTip": "第一行是测试数据的数目t（0 <= t <= 20）。以下每行均包含二个整数M和N，以空格分开。1<=M，N<=10。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对输入的每组数据M和N，用一行输出相应的K。",
    "inputExample": "<pre>1\n7 3\n</pre>",
    "outputExample": "<pre>8</pre>",
    "tip": "lwx@POJ",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "687",
    "category": "2.6基本算法之动态规划",
    "title": "687:Color Tunnels",
    "description": "A company producing toys has a complex system to paint its products. To obtain the desired color, the product must be painted by several colors in a specified order. A product is painted by moving through color tunnels. For each color there is at least one tunnel that paints with that color, but there may be more. The tunnels are distributed in the painting area and the product must be delivered from one tunnel to another in order to be painted with the given colors. The product is at a certain point in the production plant when painting process starts and must finally be delivered to the product warehouse.<br><br>More formally, a finished uncolored product is at a certain given point (source point) and must be delivered to another given point (destination point) after being painted with different colors in a given order. There are several tunnels, each is assumed to be a line segment in the plain with a specific color. The colors of the tunnels are not necessarily distinct.   Let < c1, c2, ..., cn > be the sequence of n colors that the product is to be painted with. The product is required to pass through tunnels  < t1, t2, ... tn > such that the color of ti is ci. Note that it is possible to pass through a tunnel without being painted, so the mentioned < t1, t2, ... tn > may be in fact a subsequence of the tunnels which the product passes through. The direction in which the product passes a tunnel is not important. The goal is to find the shortest path from source to destination subject to the color constraints. The path may cross itself, or even cross a tunnel. Passing twice (or more) through a tunnel is also allowed. Note that two tunnels can cross or overlap but are different.<br>",
    "img": "",
    "inputTip": "The input file contains several test cases. The first line of the input consists of a single integer t (between 1 and 20), the number of test cases. Following the first line is the data for t test cases. The first line of each test case contains four real numbers xs, ys, xt, yt which are x and y coordinates of the source and destination respectively. The second line of the test case contains the color sequence: the first number is the length of the sequence (between 1 and 30), and the rest of the line is the sequence itself. Each color in the sequence is an integer in the range 1...100. The third line contains a single integer n in the range 1...60 which is the number of tunnels followed by n lines each containing five numbers. The first two numbers are the x and y coordinates of one end of the tunnel. The third and fourth numbers are the x and y coordinates of the other end. Coordinates are real numbers. The fifth number is an integer in the range 1...100 ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "The output file must have t lines, each containing the minimum length of a path from source to destination subject to the constraints of the problem. The length will be compared to optimal length within a precision of three digits after decimal point.",
    "inputExample": "<pre>1\n0 1.5 100 67\n4 1 4 3 1\n9\n10 10 20 20 1\n10 15 20.5 35.333 3\n30 15 14.55 12.5 1\n40 30 44 33 1\n29 84 33 58 4\n9 39 41 115 2\n75 47 37 69 4\n46 26 58 25 3\n73 48 27 59 3\n</pre>",
    "outputExample": "<pre>240.60967918717043</pre>",
    "tip": "Tehran 2000",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7113",
    "category": "2.6基本算法之动态规划",
    "title": "7113:Charm Bracelet",
    "description": "<div class=\"ptx\" lang=\"en-US\"><div><p>Bessie has gone to the mall's \njewelry store and spies a charm bracelet. Of course, she'd like to fill \nit with the best charms possible from the <em>N</em>(1 ≤ <em>N</em>≤ 3,402) available charms. Each charm <em>i</em>in the supplied list has a weight <em>W<sub>i</sub></em>(1 ≤ <em>W<sub>i</sub></em>≤ 400), a 'desirability' factor <em>D<sub>i</sub></em>(1 ≤ <em>D<sub>i</sub></em>≤ 100), and can be used at most once. Bessie can only support a charm bracelet whose weight is no more than <em>M</em>(1 ≤ <em>M</em>≤ 12,880).</p><p>Given\n that weight limit as a constraint and a list of the charms with their \nweights and desirability rating, deduce the maximum possible sum of \nratings.</p></div></div><p><br></p>",
    "img": "",
    "inputTip": "Line 1: Two space-separated integers: N and MLines 2..N+1: Line i+1 describes charm i with two space-separated integers: Wi and Di",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "Line 1: A single integer that is the greatest sum of charm desirabilities that can be achieved given the weight constraints",
    "inputExample": "<pre>4 6\n1 4\n2 6\n3 12\n2 7</pre>",
    "outputExample": "<pre>23</pre>",
    "tip": "USACO 2007 December Silver",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "747",
    "category": "2.6基本算法之动态规划",
    "title": "747:Divisibility",
    "description": "Consider an arbitrary sequence of integers. One can place + or - operators between integers in the sequence, thus deriving different arithmetical expressions that evaluate to different values. Let us, for example, take the sequence: 17, 5, -21, 15. There are eight possible expressions: 17 + 5 + -21 + 15 = 16  <br>17 + 5 + -21 - 15 = -14  <br>17 + 5 - -21 + 15 = 58  <br>17 + 5 - -21 - 15 = 28  <br>17 - 5 + -21 + 15 = 6  <br>17 - 5 + -21 - 15 = -24  <br>17 - 5 - -21 + 15 = 48  <br>17 - 5 - -21 - 15 = 18  <br>We call the sequence of integers divisible by K if + or - operators can be placed between integers in the sequence in such way that resulting value is divisible by K. In the above example, the sequence is divisible by 7 (17+5+-21-15=-14) but is not divisible by 5. <br><br>You are to write a program that will determine divisibility of sequence of integers. <br>",
    "img": "",
    "inputTip": "The first line of the input file contains two integers, N and K (1 <= N <= 10000, 2 <= K <= 100) separated by a space. The second line contains a sequence of N integers separated by spaces. Each integer is not greater than 10000 by it's absolute value. ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "Write to the output file the word \"Divisible\" if given sequence of integers is divisible by K or \"Not divisible\" if it's not. ",
    "inputExample": "<pre>4 7\n17 5 -21 15</pre>",
    "outputExample": "<pre>Divisible\n</pre>",
    "tip": "Northeastern Europe 1999",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7614",
    "category": "2.6基本算法之动态规划",
    "title": "7614:最低通行费",
    "description": "<p>一个商人穿过一个 N*N 的正方形的网格，去参加一个非常重要的商务活动。他要<span style=\"white-space: normal;\">从网格的左上角进，右下角出</span>。每穿越中间1个小方格，都要花费1个单位时间。商人必须在(2N-1)个单位时间穿越出去。而在经过中间的每个小方格时，都需要缴纳一定的费用。</p><p>这个商人期望在规定时间内用最少费用穿越出去。请问至少需要多少费用？</p><p>注意：不能对角穿越各个小方格（即，只能向上下左右四个方向移动且不能离开网格）。<br></p>",
    "img": "",
    "inputTip": "第一行是一个整数，表示正方形的宽度N (1 <= N < 100)；后面 N 行，每行 N 个不大于 100 的整数，为网格上每个小方格的费用。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "至少需要的费用。",
    "inputExample": "<pre>5\n1 4 6 8 10 \n2 5 7 15 17 \n6 8 9 18 20 \n10 11 12 19 21 \n20 23 25 29 33 </pre>",
    "outputExample": "<pre>109</pre>",
    "tip": "样例中，最小值为109=1+2+5+7+9+12+19+21+33。",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7624",
    "category": "2.6基本算法之动态规划",
    "title": "7624:山区建小学",
    "description": "<p>政府在某山区修建了一条道路，恰好穿越总共m个村庄的每个村庄一次，没有回路或交叉，任意两个村庄只能通过这条路来往。已知任意两个相邻的村庄之间的距离为di（为正整数），其中，0 < i < m。为了提高山区的文化素质，政府又决定从m个村中选择n个村建小学（设 0 < n \n< = m < 500 \n）。请根据给定的m、n以及所有相邻村庄的距离，选择在哪些村庄建小学，才使得所有村到最近小学的距离总和最小，计算最小值。<br></p>",
    "img": "",
    "inputTip": "第1行为m和n，其间用空格间隔第2行为(m-1) 个整数，依次表示从一端到另一端的相邻村庄的距离，整数之间以空格间隔。例如10 32 4 6 5 2 4 3 1 3表示在10个村庄建3所学校。第1个村庄与第2个村庄距离为2，第2个村庄与第3个村庄距离为4，第3个村庄与第4个村庄距离为6，...，第9个村庄到第10个村庄的距离为3。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "各村庄到最近学校的距离之和的最小值。",
    "inputExample": "<pre>10 2\n3 1 3 1 1 1 1 1 3</pre>",
    "outputExample": "<pre>18</pre>",
    "tip": "元培-From Whf",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7625",
    "category": "2.6基本算法之动态规划",
    "title": "7625:三角形最佳路径问题",
    "description": "<p>如下所示的由正整数数字构成的三角形:\n<br>7\n<br>3 8\n<br>8 1 0\n<br>2 7 4 4\n<br>4 5 2 6 5\n<br><br>从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，和最大的路径称为最佳路径。你的任务就是求出最佳路径上的数字之和。\n<br>注意：路径上的每一步只能从一个数走到下一层上和它最近的下边（正下方）的数或者右边（右下方）的数。<br></p>",
    "img": "",
    "inputTip": "第一行为三角形高度100>=h>=1，同时也是最底层边的数字的数目。从第二行开始，每行为三角形相应行的数字，中间用空格分隔。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "最佳路径的长度数值。",
    "inputExample": "<pre>5\n7\n3 8\n8 1 0\n2 7 4 4\n4 5 2 6 5\n或\n1\n8</pre>",
    "outputExample": "<pre>30\n或\n8</pre>",
    "tip": "如何采用动态规划的思想，对问题进行分解。",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7627",
    "category": "2.6基本算法之动态规划",
    "title": "7627:鸡蛋的硬度",
    "description": "<p>最近XX公司举办了一个奇怪的比赛：鸡蛋硬度之王争霸赛。参赛者是来自世\n界各地的母鸡，比赛的内容是看谁下的蛋最硬，更奇怪的是XX公司并不使用什么精密仪器来测量蛋的硬度，他们采用了一种最老土的办法--从高度扔鸡蛋--来\n测试鸡蛋的硬度，如果一次母鸡下的蛋从高楼的第a层摔下来没摔破，但是从a+1层摔下来时摔破了，那么就说这只母鸡的鸡蛋的硬度是a。你当然可以找出各种\n理由说明这种方法不科学，比如同一只母鸡下的蛋硬度可能不一样等等，但是这不影响XX公司的争霸赛，因为他们只是为了吸引大家的眼球，一个个鸡蛋从100\n层的高楼上掉下来的时候，这情景还是能吸引很多人驻足观看的，当然，XX公司也绝不会忘记在高楼上挂一条幅，写上“XX公司”的字样--这比赛不过是XX\n公司的一个另类广告而已。\n<br>勤于思考的小A总是能从一件事情中发现一个数学问题，这件事也不例外。“假如有很多同样硬度的鸡蛋，那么我可以用二分的办法用最少的次数测出鸡蛋\n的硬度”，小A对自己的这个结论感到很满意，不过很快麻烦来了，“但是，假如我的鸡蛋不够用呢，比如我只有1个鸡蛋，那么我就不得不从第1层楼开始一层一\n层的扔，最坏情况下我要扔100次。如果有2个鸡蛋，那么就从2层楼开始的地方扔……等等，不对，好像应该从1/3的地方开始扔才对，嗯，好像也不一定\n啊……3个鸡蛋怎么办，4个，5个，更多呢……”，和往常一样，小A又陷入了一个思维僵局，与其说他是勤于思考，不如说他是喜欢自找麻烦。\n<br>好吧，既然麻烦来了，就得有人去解决，小A的麻烦就靠你来解决了：）<br></p>",
    "img": "",
    "inputTip": "输入包括多组数据，每组数据一行，包含两个正整数n和m(1<=n<=100,1<=m<=10)，其中n表示楼的高度，m表示你现在拥有的鸡蛋个数，这些鸡蛋硬度相同（即它们从同样高的地方掉下来要么都摔碎要么都不碎），并且小于等于n。你可以假定硬度为x的鸡蛋从高度小于等于x的地方摔无论如何都不会碎（没摔碎的鸡蛋可以继续使用），而只要从比x高的地方扔必然会碎。对每组输入数据，你可以假定鸡蛋的硬度在0至n之间，即在n+1层扔鸡蛋一定会碎。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对于每一组输入，输出一个整数，表示使用最优策略在最坏情况下所需要的扔鸡蛋次数。",
    "inputExample": "<pre>100 1\n100 2</pre>",
    "outputExample": "<pre>100\n14</pre>",
    "tip": "最优策略指在最坏情况下所需要的扔鸡蛋次数最少的策略。如果只有一个鸡蛋，你只能从第一层开始扔，在最坏的情况下，鸡蛋的硬度是100，所以需要扔100次。如果采用其他策略，你可能无法测出鸡蛋的硬度(比如你第一次在第二层的地方扔,结果碎了,这时你不能确定硬度是0还是1)，即在最坏情况下你需要扔无限次，所以第一组数据的答案是100。",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "8462",
    "category": "2.6基本算法之动态规划",
    "title": "8462:大盗阿福",
    "description": "<p>阿福是一名经验丰富的大盗。趁着月黑风高，阿福打算今晚洗劫一条街上的店铺。</p><p>这条街上一共有 N 家店铺，每家店中都有一些现金。阿福事先调查得知，只有当他同时洗劫了两家相邻的店铺时，街上的报警系统才会启动，然后警察就会蜂拥而至。</p><p>作为一向谨慎作案的大盗，阿福不愿意冒着被警察追捕的风险行窃。他想知道，在不惊动警察的情况下，他今晚最多可以得到多少现金？<br></p>",
    "img": "",
    "inputTip": "输入的第一行是一个整数 T (T <= 50) ，表示一共有 T 组数据。接下来的每组数据，第一行是一个整数 N (1 <= N <= 100, 000) ，表示一共有 N 家店铺。第二行是 N 个被空格分开的正整数，表示每一家店铺中的现金数量。每家店铺中的现金数量均不超过 1000 。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对于每组数据，输出一行。该行包含一个整数，表示阿福在不惊动警察的情况下可以得到的现金数量。",
    "inputExample": "<pre>2\n3\n1 8 2\n4\n10 7 6 14</pre>",
    "outputExample": "<pre>8\n24</pre>",
    "tip": "对于第一组样例，阿福选择第 2 家店铺行窃，获得的现金数量为 8 。对于第二组样例，阿福选择第 1 和 4 家店铺行窃，获得的现金数量为 10 + 14 = 24 。",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "8464",
    "category": "2.6基本算法之动态规划",
    "title": "8464:股票买卖",
    "description": "<p>最近越来越多的人都投身股市，阿福也有点心动了。谨记着“股市有风险，入市需谨慎”，阿福决定先来研究一下简化版的股票买卖问题。</p><p>假设阿福已经准确预测出了某只股票在未来 N 天的价格，他希望买卖两次，使得获得的利润最高。为了计算简单起见，利润的计算方式为卖出的价格减去买入的价格。</p><p>同一天可以进行多次买卖。但是在第一次买入之后，必须要先卖出，然后才可以第二次买入。</p><p>现在，阿福想知道他最多可以获得多少利润。<br></p>",
    "img": "",
    "inputTip": "输入的第一行是一个整数 T (T <= 50) ，表示一共有 T 组数据。接下来的每组数据，第一行是一个整数 N (1 <= N <= 100, 000) ，表示一共有 N 天。第二行是 N 个被空格分开的整数，表示每天该股票的价格。该股票每天的价格的绝对值均不会超过 1,000,000 。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对于每组数据，输出一行。该行包含一个整数，表示阿福能够获得的最大的利润。",
    "inputExample": "<pre>3\n7\n5 14 -2 4 9 3 17\n6\n6 8 7 4 1 -2\n4\n18 9 5 2</pre>",
    "outputExample": "<pre>28\n2\n0</pre>",
    "tip": "对于第一组样例，阿福可以第 1 次在第 1 天买入（价格为 5 ），然后在第 2 天卖出（价格为 14 ）。第 2 次在第 3 天买入（价格为 -2 ），然后在第 7 天卖出（价格为 17 ）。一共获得的利润是 (14 - 5) + (17 - (-2)) = 28对于第二组样例，阿福可以第 1 次在第 1 天买入（价格为 6 ），然后在第 2 天卖出（价格为 8 ）。第 2 次仍然在第 2 天买入，然后在第 2 天卖出。一共获得的利润是 8 - 6 = 2对于第三组样例，由于价格一直在下跌，阿福可以随便选择一天买入之后迅速卖出。获得的最大利润为 0",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "8467",
    "category": "2.6基本算法之动态规划",
    "title": "8467:鸣人的影分身",
    "description": "<p>在火影忍者的世界里，令敌人捉摸不透是非常关键的。我们的主角漩涡鸣人所拥有的一个招数——多重影分身之术——就是一个很好的例子。<br></p><p><img src=\"http://media.openjudge.cn/images/upload/1435656731.jpg\" width=\"300\" height=\"207\"><br></p><p>影分身是由鸣人身体的查克拉能量制造的，使用的查克拉越多，制造出的影分身越强。</p><p>针对不同的作战情况，鸣人可以选择制造出各种强度的影分身，有的用来佯攻，有的用来发起致命一击。</p><p>那么问题来了，假设鸣人的查克拉能量为M，他影分身的个数为N，那么制造影分身时有多少种（用K表示）不同的分配方法？（影分身可以被分配到0点查克拉能量）<br></p>",
    "img": "",
    "inputTip": "第一行是测试数据的数目t（0 <= t <= 20）。以下每行均包含二个整数M和N，以空格分开。1<=M，N<=10。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对输入的每组数据M和N，用一行输出相应的K。",
    "inputExample": "<pre>1\n7 3</pre>",
    "outputExample": "<pre>8</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "8471",
    "category": "2.6基本算法之动态规划",
    "title": "8471:切割回文",
    "description": "<p>阿福最近对回文串产生了非常浓厚的兴趣。</p><p>如果一个字符串从左往右看和从右往左看完全相同的话，那么就认为这个串是一个回文串。例如，“abcaacba”是一个回文串，“abcaaba”则不是一个回文串。</p><p>阿福现在强迫症发作，看到什么字符串都想要把它变成回文的。阿福可以通过切割字符串，使得切割完之后得到的子串都是回文的。</p><p>现在阿福想知道他最少切割多少次就可以达到目的。例如，对于字符串“abaacca”，最少切割一次，就可以得到“aba”和“acca”这两个回文子串。<br></p>",
    "img": "",
    "inputTip": "输入的第一行是一个整数 T (T <= 20) ，表示一共有 T 组数据。接下来的 T 行，每一行都包含了一个长度不超过的 1000 的字符串，且字符串只包含了小写字母。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对于每组数据，输出一行。该行包含一个整数，表示阿福最少切割的次数，使得切割完得到的子串都是回文的。",
    "inputExample": "<pre>3\nabaacca\nabcd\nabcba</pre>",
    "outputExample": "<pre>1\n3\n0</pre>",
    "tip": "对于第一组样例，阿福最少切割 1 次，将原串切割为“aba”和“acca”两个回文子串。对于第二组样例，阿福最少切割 3 次，将原串切割为“a”、“b”、“c”、“d”这四个回文子串。对于第三组样例，阿福不需要切割，原串本身就是一个回文串。",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "8780",
    "category": "2.6基本算法之动态规划",
    "title": "8780:拦截导弹",
    "description": "<p>某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。</p><p>输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数），计算这套系统最多能拦截多少导弹。</p>",
    "img": "",
    "inputTip": "第一行是一个整数N（不超过15），表示导弹数。第二行包含N个整数，为导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数）。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个整数，表示最多能拦截的导弹数。",
    "inputExample": "<pre>8\n389 207 155 300 299 170 158 65</pre>",
    "outputExample": "<pre>6\n</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "8782",
    "category": "2.6基本算法之动态规划",
    "title": "8782:乘积最大",
    "description": "<p>今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰90周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友XZ也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：</p><p>设有一个长度为N的数字串，要求选手使用K个乘号将它分成K+1个部分，找出一种分法，使得这K+1个部分的乘积能够为最大。</p><p>同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：</p><p>有一个数字串：312，当N=3，K=1时会有以下两种分法：</p><p>1)  3*12=36</p><p>2)  31*2=62</p><p>这时，符合题目要求的结果是：31*2=62</p><p>现在，请你帮助你的好朋友XZ设计一个程序，求得正确的答案。\n</p>",
    "img": "",
    "inputTip": "程序的输入共有两行：第一行共有2个自然数N，K（6≤N≤40，1≤K≤6）第二行是一个长度为N的数字串。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出所求得的最大乘积（一个自然数）。（保证最终答案不超过int范围）",
    "inputExample": "<pre>4 2\n1231\n</pre>",
    "outputExample": "<pre>62</pre>",
    "tip": "NOIP2000复赛 普及组 第三题",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "8785",
    "category": "2.6基本算法之动态规划",
    "title": "8785:装箱问题",
    "description": "<p>有一个箱子容量为V（正整数，0<=v<span style=\"white-space: normal;\"><=20000），同时有n个物品（0< n<n<span style=\"white-space: normal;\"><=30），每个物品有一个体积（正整数）。<!--=<--></n<span><!--=<--><!--=v<span--></span></p><p>要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。</p>",
    "img": "",
    "inputTip": "第一行是一个整数V，表示箱子容量。第二行是一个整数n，表示物品数。接下来n行，每行一个正整数（不超过10000），分别表示这n个物品的各自体积。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个整数，表示箱子剩余空间。",
    "inputExample": "<pre>24\n6\n8\n3\n12\n7\n9\n7</pre>",
    "outputExample": "<pre>0</pre>",
    "tip": "NOIP2001复赛 普及组 第四题",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "8786",
    "category": "2.6基本算法之动态规划",
    "title": "8786:方格取数",
    "description": "<p>设有N*N的方格图(N<=10),我们将其中的某些方格中填入正整数,而其他的方格中则放入数字0。如下图所示（见样例）：< p=\"\"></p><p style=\"text-align: center;\"><img src=\"http://media.openjudge.cn/images/upload/1444824807.png\" width=\"604\" height=\"355\"><br></p><p>某人从图的左上角的A 点出发，可以向下行走，也可以向右走，直到到达右下角的B点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。\n此人从A点到B 点共走两次，试找出2条这样的路径，使得取得的数之和为最大。\n</p><!--=10),我们将其中的某些方格中填入正整数,而其他的方格中则放入数字0。如下图所示（见样例）：<--><p></p>",
    "img": "",
    "inputTip": "输入的第一行为一个整数N（表示N*N的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的0表示输入结束。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "只需输出一个整数，表示2条路径上取得的最大的和。",
    "inputExample": "<pre>8\n2 3 13\n2 6 6\n3 5 7\n4 4 14\n5 2 21 \n5 6 4\n6 3 15\n7 2 14\n0 0 0</pre>",
    "outputExample": "<pre>67</pre>",
    "tip": "NOIP2000复赛 提高组 第四题",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "8787",
    "category": "2.6基本算法之动态规划",
    "title": "8787:数的划分",
    "description": "<p>将整数n分成k份，且每份不能为空，任意两份不能相同(不考虑顺序)。</p><p>例如：n=7，k=3，下面三种分法被认为是相同的。</p><p>1，1，5； 1，5，1； 5，1，1；</p><p>问有多少种不同的分法。 输出：一个整数，即不同的分法。</p>",
    "img": "",
    "inputTip": "两个整数n，k (6 < n <= 200，2 <= k <= 6)，中间用单个空格隔开。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个整数，即不同的分法。",
    "inputExample": "<pre>7 3</pre>",
    "outputExample": "<pre>4</pre>",
    "tip": "四种分法为：1，1，5；1，2，4；1，3，3；2，2，3。",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "90",
    "category": "2.6基本算法之动态规划",
    "title": "90:滑雪",
    "description": "Michael喜欢滑雪百这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道载一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子<br><pre> 1  2  3  4 5<br>16 17 18 19 6<br>15 24 25 20 7<br>14 23 22 21 8<br>13 12 11 10 9</pre><br>一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-...-3-2-1更长。事实上，这是最长的一条。",
    "img": "",
    "inputTip": "输入的第一行表示区域的行数R和列数C(1 <= R,C <= 100)。下面是R行，每行有C个整数，代表高度h，0<=h<=10000。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出最长区域的长度。",
    "inputExample": "<pre>5 5\n1 2 3 4 5\n16 17 18 19 6\n15 24 25 20 7\n14 23 22 21 8\n13 12 11 10 9\n</pre>",
    "outputExample": "<pre>25</pre>",
    "tip": "Don't know",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "9265",
    "category": "2.6基本算法之动态规划",
    "title": "9265:取数游戏",
    "description": "<p><span style=\"font-size: medium;\">我们来玩一个游戏：自然数1到N，按顺序列成一排，你可以从中取走任意个数，但是相邻的两个不可以同时被取走。如果你能算出一共有多少种取法，那么你会被天神Lijiganjun奖励。<br>\n</span></p>",
    "img": "",
    "inputTip": "仅包含一个数n（1< n < 50）。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "仅包含一个数———你的答案。",
    "inputExample": "<pre>5</pre>",
    "outputExample": "<pre>13</pre>",
    "tip": "递推五十题",
    "timeLimited": "10000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "9267",
    "category": "2.6基本算法之动态规划",
    "title": "9267:核电站",
    "description": "<p><span style=\"font-size: medium\">一个核电站有N个放核物质的坑，坑排列在一条直线上。如果连续M个坑中放入核物质，则会发生爆炸，于是，在某些坑中可能不放核物质。</span></p><p><span style=\"font-size: medium\">任务：对于给定的N和M，求不发生爆炸的放置核物质的方案总数 <br></span></p>",
    "img": "",
    "inputTip": "只一行，两个正整数N，M( 1 < N < 50，2 ≤ M ≤ 5 )",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个正整数S，表示方案总数。",
    "inputExample": "<pre>4 3</pre>",
    "outputExample": "<pre>13</pre>",
    "tip": "",
    "timeLimited": "5000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "9268",
    "category": "2.6基本算法之动态规划",
    "title": "9268:酒鬼",
    "description": "<p><span style=\"font-size: medium\">Santo刚刚与房东打赌赢得了一间在New Clondike 的大客厅。今天，他来到这个大客厅欣赏他的奖品。房东摆出了一行瓶子在酒吧上。瓶子里都装有不同体积的酒。令Santo高兴的是，瓶子中的酒都有不同的味道。房东说道：“你可以喝尽可能多的酒，但是一旦打开酒盖你就必须把它喝完，喝完一瓶后把它放回原处。还有一件最重要的事，你必须从左至右依次喝，并且不能连续超过三瓶，不然会给你带来坏运气。”现在可怜的Santo站在酒吧前努力的想着，他到底应该喝哪几瓶才能使喝的酒最多呢？请帮助他找出他应该喝的酒瓶号，因为思考让他感到不安。 <br></span></p>",
    "img": "",
    "inputTip": "第一行一个整数N,有N个酒瓶。N<=700接下有N行，第I+1行的数字代表酒瓶I中酒的体积。 ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一个数字，喝的酒的最大总体积。遵守以上规则，使得三个连续瓶子中至少一个瓶子是满的。 ",
    "inputExample": "<pre>6\n6\n10\n13\n9\n8\n1</pre>",
    "outputExample": "<pre>33</pre>",
    "tip": "",
    "timeLimited": "2000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "9270",
    "category": "2.6基本算法之动态规划",
    "title": "9270:Pku2440 DNA",
    "description": "<p><span style=\"font-size: medium;\">A kind of virus has attacked the X planet, and many lives are infected. After weeks of study, The CHO (Creature Healthy Organization) of X planet finally finds out that this kind of virus has two kind of very simple DNA, and can be represented by 101 and 111. Unfortunately, the lives on the planet also have DNA formed by 0s and 1s. If a creature's DNA contains the virus' DNA, it will be affected; otherwise it will not. Given an integer L, it is clear that there will be 2 ^ L different lives, of which the length of DNA is L. Your job is to find out in the 2 ^ L lives how many won't be affected? <br>\n</span></p>",
    "img": "",
    "inputTip": "The input contains several test cases.  For each test case it contains a positive integer L (1 <= L <= 10 ^  6). The end of input is indicated by end-of-file. ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each test case, output K mod 2005, here K is the number of lives that will not be affected. ",
    "inputExample": "<pre>4</pre>",
    "outputExample": "<pre>9</pre>",
    "tip": "",
    "timeLimited": "4000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "9271",
    "category": "2.6基本算法之动态规划",
    "title": "9271:奶牛散步",
    "description": "<p><span style=\"font-size: medium;\">从一个无限大的矩阵的中心点出发，一步只能向右走、向上走或向左走。恰好走N步且不经过已走的点 <br>\n共有多少种走法？ <br>\n</span></p>",
    "img": "",
    "inputTip": "一个数字，代表N,N<=1000",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出有多少方案",
    "inputExample": "<pre>2</pre>",
    "outputExample": "<pre>7</pre>",
    "tip": "",
    "timeLimited": "10000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "9272",
    "category": "2.6基本算法之动态规划",
    "title": "9272:偶数个数字3",
    "description": "<p><span style=\"font-size: medium;\"><span style=\"font-size: medium;\">在所有的N位数中，有多少个数中有偶数个数字3？<br>\n</span></span></p>",
    "img": "",
    "inputTip": "一行给出数字N，N<=1000",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "如题",
    "inputExample": "<pre>2</pre>",
    "outputExample": "<pre>73</pre>",
    "tip": "",
    "timeLimited": "10000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "9275",
    "category": "2.6基本算法之动态规划",
    "title": "9275:[Usaco2009 Feb]Bullcow",
    "description": "<p><span style=\"font-size: medium;\">一年一度的展会要来临了，农民约翰想要把N(1 <= N <= 100,000)只奶牛和公牛安排在单独的一行中。 约翰发现最近公牛们非常好斗；假如两只公牛在这一行中靠的太近，他们就会吵架，以至于斗殴，破坏这和谐的环境。约翰非常的足智多谋，他计算出任何两只公牛之间至少要有K (0 <= K < N)只奶牛，这样才能避免斗殴。 约翰希望你帮助他计算一下有多少种安排方法，可避免任何斗殴的的发生。约翰认为每头公牛都是一样的，每头奶牛都是一样的。因而，只要在一些相同的位置上有不同种类的牛，那这就算两种不同的方法。 <br>\n</span></p>",
    "img": "",
    "inputTip": "第一行:两个用空格隔开的数：N和K ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "第一行：一个单独的数，即约翰可以安排的方法数。考虑到这个数可能很大，你只要输出mod 5,000,011之后的结果就可以了。 ",
    "inputExample": "<pre>4 2\n输入注释\n约翰想要一排4头牛，但是任何两只公牛之间至少有两头奶牛</pre>",
    "outputExample": "<pre>6</pre>",
    "tip": "下面的就是约翰思考出可行的6种方案(C代表奶牛,B代表公牛)CCCCBCCCCBCCCCBCCCCBBCCB",
    "timeLimited": "12000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "9277",
    "category": "2.6基本算法之动态规划",
    "title": "9277:Logs Stacking堆木头",
    "description": "<p><span style=\"font-size: medium;\"><span style=\"font-size: medium;\">Daxinganling produces a lot of timber. Before loading onto trains, the timberjacks will place the logs to some place in the open air first. Looking from the sideway, the figure of a logs stack is as follows: <br>\nWe have known that the number of logs in each layer is fewer than the lower layer for at least one log, and that in each layer the logs are connected in a line. In the figure above, there are 12 logs in the bottom layer of the stack. Now, given the number of logs in the bottom layer, the timberjacks want to know how many possible figures there may be. <br>\n给出在最底层的木头的个数，问有多少种堆放木头的方式，当然你的堆放方式不能让木头掉下来. <br>\n在堆放的时候木头必须互相挨着在一起. <br>\n</span></span></p>",
    "img": "",
    "inputTip": "The  first line of input contains the number of test cases T (1 <= T  <= 1000000). Then T lines follow. Every line only contains a number n  (1 <= n <= 200000) representing the number of logs in the bottom  layer. ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each test case in the input, you  should output the corresponding number of possible figures. Because the  number may be very large, just output the number mod 10^5. ",
    "inputExample": "<pre>4\n1\n2\n3\n5</pre>",
    "outputExample": "<pre>1\n2\n5\n34</pre>",
    "tip": "当输入3时，有5种方式第一种：上面一个也不放第二种：上面放一根，放在最左边第三种：上面放一根，放在最右边第四种：上面放二根第五种：上面先放二根，然后在二根的上面放一根",
    "timeLimited": "1000ms",
    "spaceLimited": "131072kB"
  },
  {
    "id": "9280",
    "category": "2.6基本算法之动态规划",
    "title": "9280:[Spoj]严格n元树",
    "description": "<p><span style=\"font-size: medium\">如果一棵树的所有非叶节点都恰好有n个儿子，那么我们称它为严格n元树。如果该树中最底层的节点深度为d(根的深度为0），那么我们称它为一棵深度为d的严格n元树。例如：深度为2的严格2元树有三个</span></p><p><span style=\"font-size: medium\">给出n,d,编程序数出深度为d的n元树数目。 <br></span></p>",
    "img": "",
    "inputTip": "仅包含两个整数n,d(0 < n < = 32,0 <= d <= 16)。输入数据保证你不需要考虑某一层多于1024个节点的树（nd<=1024)。提示：答案保证不超过200位十进制数。 ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "仅包含一个数，既深度为d的n元树的数目。 ",
    "inputExample": "<pre>【样例输入1】\n    2  2\n【样例输入2】\n   2 4</pre>",
    "outputExample": "<pre>【样例输出1】\n   3\n【样例输出2】\n  651</pre>",
    "tip": "",
    "timeLimited": "10000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "9281",
    "category": "2.6基本算法之动态规划",
    "title": "9281:技能树",
    "description": "<p><span style=\"font-size: medium\">设二叉树中每个节点的子节点数为0或2，求有N个节点高度为M的不同的二叉树有多少个 <br>(输出 mod 9901 后的结果)。 <br></span></p>",
    "img": "",
    "inputTip": "两个空格分开的整数, N和K。 ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "第 1 行: 一个整数，表示可能的技能树的个数除以9901的余数。 ",
    "inputExample": "<pre>5 3</pre>",
    "outputExample": "<pre>2</pre>",
    "tip": "有5个节点，高为3的两个不同的技能树约定:n在[3,300]间,m在(1,100)间 ",
    "timeLimited": "10000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "9282",
    "category": "2.6基本算法之动态规划",
    "title": "9282:B君的多边形",
    "description": "<p><span style=\"font-size: medium;\">有一个正n多边形，我们要连接一些对角线，把这个多边形分成若干 <br>\n个区域。要求连接的对角线不能相交，每个点可以连出也可以不连出对角 <br>\n线。（即最终不要求所有区域均为三角形） <br>\n问总方案数mod (10^9+7)的结果。 <br>\n</span></p>",
    "img": "",
    "inputTip": "一行一个整数n ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一行一个整数表示答案。 ",
    "inputExample": "<pre>5</pre>",
    "outputExample": "<pre>11</pre>",
    "tip": "对于所有的的数据，满足n≤10^6",
    "timeLimited": "20000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "9283",
    "category": "2.6基本算法之动态规划",
    "title": "9283:Push Botton Lock",
    "description": "<p><span style=\"font-size: medium;\">The Frobozz Magic Lock Company is in the business of manufacturing push button style combination door locks. A push button door lock consists of a number of push buttons B, (1 ≤ B ≤ 11), labeled “1” through “B”. The lock is opened by pressing the correct sequence of button combinations and then turning the doorknob. If the sequence of presses is correct, the door magically opens. <br>\n<br>\nA combination consists of 1 or more buttons being pressed simultaneously. A sequence consists of a series of combinations. A sequence must have at least one combination. Once a button has been used in a combination, it may not be used again in the same sequence. In addition, it is not necessary to use all the buttons in a sequence. For example, for B = 8: <br>\n<br>\n(1-2-3)(4)(7-8) <br>\n<br>\nis a valid sequence with 3 combinations (1-2-3), (4), and (7-8). Note that buttons 5 and 6 are not used in this sequence. <br>\n<br>\n(1-2-3)(2-4)(5-6) <br>\n<br>\nis not a valid sequence, since button 2 appears in 2 combinations (1-2-3) and (2-4). <br>\nThe CEO of Frobozz, J. Pierpont Flathead, wants you to write a program that determines the number of valid sequences possible for given values of B. The program must be able to process a list of lock orders (datasets) from customers and generate a report showing the order number, the value of B, and the number of valid sequences possible. This list will always contain at least one dataset, but no more than 100 datasets. <br>\n<br>\nN个不同的数字，放到一些不同的BOX里面，数字你不必用完，Box的个数也是可变的.比如三个球，你可以只放一个BOX，也可以放二个或者三个，但是四个BOX那就不可能了.每个数字只能放到一个BOX里，问有多少种放法.<br>\n</span></p>",
    "img": "",
    "inputTip": "The first line of input contains a  single integer N, (1 ≤ N ≤ 100), representing the number of datasets  that follow. Each dataset consists of a single line of data containing a  single integer B, which is the number of buttons for the lock. ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": " For each dataset, display the dataset number, a blank, the value B, a blank, and the number of valid sequences. 先输出是第几组数据，再输出这个数据的输入，再给出你的答案",
    "inputExample": "<pre>3\n3\n4\n3</pre>",
    "outputExample": "<pre>1 3 25\n2 4 149\n3 3 25</pre>",
    "tip": "当有三个数字时，总有以下25种放法.1:当使用一个数字时，那么最多只能用一个BOX，因而有[1],[2],[3]这三种放法.2：当使用二个数字时，那么可以使用数字1,2，当只有一个BOX时有[1,2]这种放法，当使用二个时有[1],[2]或者[2],[1]这种放法；当然你也可以使用数字1,3或者2,3因而共有9种放法.3:当使用三个数字时，我就不推了，共有13种放法.综上，共有3+9+13=25种！",
    "timeLimited": "5000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "9284",
    "category": "2.6基本算法之动态规划",
    "title": "9284:盒子与小球之二",
    "description": "<p><span style=\"font-size: medium;\">N个有差别的盒子（1<=N<=20）。你有A个红球和B个蓝球。0 <= A <= 15, 0 <= B <= 15。球除了颜色没有任何区别。你可以将球放进盒子。一个盒子可以同时放进两种球，也可以只放一种，也可以空着。球不必全部放入盒子中。编程计算有多少种放置球的方法。 <br>\n</span></p>",
    "img": "",
    "inputTip": "就一行，N，A，B，用空格分开   ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "就一行，输出放置方案总数   ",
    "inputExample": "<pre>2 1 1</pre>",
    "outputExample": "<pre>9</pre>",
    "tip": "",
    "timeLimited": "10000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "9285",
    "category": "2.6基本算法之动态规划",
    "title": "9285:盒子与小球之三",
    "description": "<p><span style=\"font-size: medium;\">有N个相同的球，M个不同的盒子，每个盒子最多放K个球 <br>\n请计算将这N个球全部放入盒子中的方案数模1000007后的结果 <br>\n</span></p>",
    "img": "",
    "inputTip": "三个正整数，依次为N，M，K ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出方案数模1000007后的结果 ",
    "inputExample": "<pre>4 2 3</pre>",
    "outputExample": "<pre>3</pre>",
    "tip": "总共有3种方案，依次为{ 3 ， 1 }{ 2 ， 2 }{ 1 ， 3 }对于100%的数据， N，M <= 5000 ",
    "timeLimited": "10000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "9288",
    "category": "2.6基本算法之动态规划",
    "title": "9288:Zju2061 Buy the Ticket",
    "description": "<p><span style=\"font-size: medium\"><span style=\"font-size: medium\">The \"Harry Potter and the Goblet of Fire\" will be on show in the next few days. As a crazy fan of Harry Potter, you will go to the cinema and have the first sight, won't you? <br><br>Suppose the cinema only has one ticket-office and the price for per-ticket is 50 dollars. The queue for buying the tickets is consisted of m + n persons (m persons each only has the 50-dollar bill and n persons each only has the 100-dollar bill). <br><br>Now the problem for you is to calculate the number of different ways of the queue that the buying process won't be stopped from the first person till the last person. <br>Note: initially the ticket-office has no money. <br><br>The buying process will be stopped on the occasion that the ticket-office has no 50-dollar bill but the first person of the queue only has the 100-dollar bill. <br></span></span></p>",
    "img": "",
    "inputTip": "The  input file contains several test cases. Each test case is made up of  two integer numbers: m and n. It is terminated by m = n = 0. Otherwise,  m, n <=100. ",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each test case, first  print the test number (counting from 1) in one line, then output the  number of different ways in another line. ",
    "inputExample": "<pre>3 0\n3 1\n3 3\n0 0</pre>",
    "outputExample": "<pre>6\n18\n180\n</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "131072kB"
  },
  {
    "id": "9289",
    "category": "2.6基本算法之动态规划",
    "title": "9289:[Usaco2005 Nov]Ant Counting",
    "description": "<p><span style=\"font-size: medium\">Bessie was poking around the ant hill one day watching the ants march to and fro while gathering food. She realized that many of the ants were siblings, indistinguishable from one another. She also realized the sometimes only one ant would go for food, sometimes a few, and sometimes all of them. This made for a large number of different sets of ants!<br><br>Being a bit mathematical, Bessie started wondering. Bessie noted that the hive has T (1 <= T <= 1,000) families of ants which she labeled 1..T (A ants altogether). Each family had some number Ni (1 <= Ni <= 100) of ants.<br><br>How many groups of sizes S, S+1, ..., B (1 <= S <= B <= A) can be formed?<br><br>While observing one group, the set of three ant families was seen as {1, 1, 2, 2, 3}, though rarely in that order. The possible sets of marching ants were:<br><br>3 sets with 1 ant: {1} {2} {3}<br>5 sets with 2 ants: {1,1} {1,2} {1,3} {2,2} {2,3}<br>5 sets with 3 ants: {1,1,2} {1,1,3} {1,2,2} {1,2,3} {2,2,3}<br>3 sets with 4 ants: {1,2,2,3} {1,1,2,2} {1,1,2,3}<br>1 set with 5 ants: {1,1,2,2,3}<br><br>Your job is to count the number of possible sets of ants given the data above.<br></span></p>",
    "img": "",
    "inputTip": "* Line 1: 4 space-separated integers: T, A, S, and B* Lines 2..A+1: Each line contains a single integer that is an ant type present in the hive",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "*  Line 1: The number of sets of size S..B (inclusive) that can be  created. A set like {1,2} is the same as the set {2,1} and should not be  double-counted. Print only the LAST SIX DIGITS of this number, with no  leading zeroes or spaces.",
    "inputExample": "<pre>3 5 2 3\n1\n2\n2\n1\n3</pre>",
    "outputExample": "<pre>10</pre>",
    "tip": "INPUT DETAILS:Three types of ants (1..3); 5 ants altogether. How many sets of size 2 or size 3 can be made?OUTPUT DETAILS:5 sets of ants with two members; 5 more sets of ants with three members ",
    "timeLimited": "1000ms",
    "spaceLimited": "131072kB"
  },
  {
    "id": "9290",
    "category": "2.6基本算法之动态规划",
    "title": "9290:Pku2680 Computer Transformation",
    "description": "<p><span style=\"font-size: medium\">A sequence consisting of one digit, the number 1 is initially written into a computer. At each successive time step, the computer simultaneously tranforms each digit 0 into the sequence 1 0 and each digit 1 into the sequence 0 1. So, after the first time step, the sequence 0 1 is obtained; after the second, the sequence 1 0 0 1, after the third, the sequence 0 1 1 0 1 0 0 1 and so on.<br><br>How many pairs of consequitive zeroes will appear in the sequence after n steps?<br></span></p>",
    "img": "",
    "inputTip": "Every input line contains one natural number n (0 < n <= 1000).",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "For each input n print the number of consequitive zeroes pairs that will appear in the sequence after n steps.",
    "inputExample": "<pre>2\n3</pre>",
    "outputExample": "<pre>1\n1</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "131072kB"
  }
]