[
  {
    "id": "2991",
    "category": "2.4基本算法之分治",
    "title": "2991:2011",
    "description": "已知长度最大为200位的正整数n，请求出2011^n的后四位。",
    "img": "",
    "inputTip": "第一行为一个正整数k，代表有k组数据，k<=200接下来的k行，每行都有一个正整数n，n的位数<=200",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "每一个n的结果为一个整数占一行，若不足4位，去除高位多余的0",
    "inputExample": "<pre>3\n5\n28\n792</pre>",
    "outputExample": "<pre>1051\n81\n5521</pre>",
    "tip": "",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7617",
    "category": "2.4基本算法之分治",
    "title": "7617:输出前k大的数",
    "description": "<p>给定一个数组，统计前k大的数并且把这k个数从大到小输出。<br></p>",
    "img": "",
    "inputTip": "第一行包含一个整数n，表示数组的大小。n < 100000。第二行包含n个整数，表示数组的元素，整数之间以一个空格分开。每个整数的绝对值不超过100000000。第三行包含一个整数k。k < n。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "从大到小输出前k大的数，每个数一行。",
    "inputExample": "<pre>10\n4 5 6 9 8 7 1 2 3 0\n5</pre>",
    "outputExample": "<pre>9\n8\n7\n6\n5</pre>",
    "tip": "",
    "timeLimited": "10000ms",
    "spaceLimited": "1000ms"
  },
  {
    "id": "7620",
    "category": "2.4基本算法之分治",
    "title": "7620:区间合并",
    "description": "<p>给定 n 个闭区间 [ai; bi]，其中i=1,2,...,n。任意两个相邻或相交的闭区间可以合并为一个闭区间。例如，[1;2] 和 [2;3] 可以合并为 [1;3]，<span style=\"white-space: normal;\">[1;3</span><span style=\"white-space: normal;\">] 和 [2;4</span><span style=\"white-space: normal;\">] 可以合并为 [1;4]，但是<span style=\"white-space: normal;\">[1;</span><span style=\"white-space: normal;\">2] 和 [3;4</span><span style=\"white-space: normal;\">] 不可以合并。</span></span></p><p>我们的任务是判断这些区间是否可以最终合并为一个闭区间，如果可以，将这个闭区间输出，否则输出no。<br></p>",
    "img": "",
    "inputTip": "第一行为一个整数n，3 ≤ n ≤ 50000。表示输入区间的数量。之后n行，在第i行上（1 ≤ i ≤ n），为两个整数 ai 和 bi ，整数之间用一个空格分隔，表示区间 [ai; bi]（其中 1 ≤ ai ≤ bi ≤ 10000）。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出一行，如果这些区间最终可以合并为一个闭区间，输出这个闭区间的左右边界，用单个空格隔开；否则输出 no。",
    "inputExample": "<pre>5\n5 6\n1 5\n10 10\n6 9\n8 10</pre>",
    "outputExample": "<pre>1 10</pre>",
    "tip": "习题(14-8)",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7622",
    "category": "2.4基本算法之分治",
    "title": "7622:求排列的逆序数",
    "description": "<p>在Internet上的搜索引擎经常需要对信息进行比较，比如可以通过某个人对一些事物的排名来估计他（或她）对各种不同信息的兴趣，从而实现个性化的服务。</p><p>对于不同的排名结果可以用逆序来评价它们之间的差异。考虑1,2,…,n的排列i<sub>1</sub>，i<sub>2</sub>，…，i<sub>n</sub>，如果其中存在j,k，满足 j < k 且 <span style=\"white-space: normal;\">i</span><sub style=\"white-space: normal;\">j</sub><span style=\"white-space: normal;\"> > i</span><sub style=\"white-space: normal;\">k</sub>，\n那么就称(i<sub>j</sub>,i<sub>k</sub>)是这个排列的一个逆序。</p><p>一个排列含有逆序的个数称为这个排列的逆序数。例如排列 263451 含有8个逆序(2,1),(6,3),(6,4),(6,5),(6,1),(3,1),(4,1),(5,1)，因此该排列的逆序数就是8。显然，由1,2,…,n \n构成的所有n!个排列中，最小的逆序数是0，对应的排列就是1,2,…,n；最大的逆序数是n(n-1)/2，对应的排列就是n,(n-1),…,2,1。逆序数越大的排列与原始排列的差异度就越大。</p><p>现给定<span style=\"white-space: normal;\">1,2,…,n</span><span style=\"white-space: normal;\">的一个排列，求它的逆序数。</span><br><br><br></p>",
    "img": "",
    "inputTip": "第一行是一个整数n，表示该排列有n个数（n <= 100000)。第二行是n个不同的正整数，之间以空格隔开，表示该排列。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "输出该排列的逆序数。",
    "inputExample": "<pre>6\n2 6 3 4 5 1</pre>",
    "outputExample": "<pre>8</pre>",
    "tip": "1. 利用二分归并排序算法（分治）；2. 注意结果可能超过int的范围，需要用long long存储。",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7891",
    "category": "2.4基本算法之分治",
    "title": "7891:一元三次方程求解",
    "description": "<p>有形如：ax<sup>3</sup>+bx<sup>2</sup>+cx+d=0  这样的一个一元三次方程。</p><p>给出该方程中各项的系数(a，b，c，d  均为实数)，并约定该方程存在三个不同实根(根的范围在-100至100之间)，且根与根之差的绝对值>=1。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后2位。</p>",
    "img": "",
    "inputTip": "一行，包含四个实数a，b，c，d，相邻两个数之间用单个空格隔开。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "一行，包含三个实数，为该方程的三个实根，按从小到大顺序排列，相邻两个数之间用单个空格隔开，精确到小数点后2位。",
    "inputExample": "<pre>1.0 -5.0 -4.0 20.0</pre>",
    "outputExample": "<pre>-2.00 2.00 5.00</pre>",
    "tip": "记方程f(x)=0，若存在2个数x1和x2，且x1 < x2，f(x1)*f(x2) < 0，则在(x1，x2)之间一定有一个根。",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "7909",
    "category": "2.4基本算法之分治",
    "title": "7909:统计数字",
    "description": "<p>某次科研调查时得到了n个自然数，每个数均不超过1500000000（1.5*10<sup>9</sup>）。已知不相同的数不超过10000个，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。\n</p>",
    "img": "",
    "inputTip": "包含n+1行:第一行是整数n，表示自然数的个数；第2~n+1每行一个自然数。40%的数据满足：1<=n<=1000；80%的数据满足：1<=n<=50000；100%的数据满足：1<=n<=200000，每个数均不超过1500 000 000（1.5*10^9）。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "包含m行（m为n个自然数中不相同数的个数），按照自然数从小到大的顺序输出。每行输出两个整数，分别是自然数和该数出现的次数，其间用一个空格隔开。",
    "inputExample": "<pre>8\n2\n4\n2\n4\n5\n100\n2\n100\n</pre>",
    "outputExample": "<pre>2 3\n4 2\n5 1\n100 2\n</pre>",
    "tip": "NOIP2007复赛 提高组 第一题",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  },
  {
    "id": "8463",
    "category": "2.4基本算法之分治",
    "title": "8463:Stupid cat & Doge",
    "description": "<p>动物园的规划和城市规划一样是个令人头疼的大问题。不幸的是，动物园规划师R.V.L.先生高估了小动物们的智商，他设计了一个极其复杂的动物园道路规划方案，如下图所示：<br></p><p><img src=\"http://media.openjudge.cn/images/upload/1435653084.jpg\" width=\"673\" height=\"256\"><br></p><p>动物园按照下述方法进行扩建：当动物园规模扩大之后，R.V.L.先生设计的解决方案是把与原来动物园结构一样的区域复制或旋转90度之后按照图中的方式建设在原来的动物园周围（即将原来的动物园复制一遍放在原动物园上方，将顺时针旋转90度后的动物园放在原动物园的左上方，将逆时针旋转90度后的动物园放在原动物园的左方），再用道路将四部分的首尾连接起来，即可提升动物园的等级。<br></p><p>容易看出，等级提升后的动物园仍然是由一条道路连接，等级为N的动物园共能容纳2^2N只小动物，每只小动物将被分配到唯一的一间房屋。对于任意等级的动物园，我们从左上角开始沿着唯一的道路走，按照道路为房屋标号，就能够得到每间房屋的编号了。<br></p><p>说了这么多，智商余额不足的Stupid cat和Doge早已晕头转向。他们想知道，如果城市发展到了一定等级，他俩各自所处的房屋之间的直线距离是多少。房屋之间的距离是指两座房屋中心点之间的距离，你可以认为每间房屋都是边长为10米的正方形。<br></p>",
    "img": "",
    "inputTip": "输入包含多组测试数据，第一行有一个整数 T 表示测试数据的数目。每组测试数据包含一行用空格隔开的三个整数 N, S, D，表示动物园等级，Stupid cat分配到的房屋编号和Doge分配到的房间编号。",
    "inputStyle": "输入",
    "outputTip": "输出",
    "outputStyle": "对于每组测试数据，在单独的一行内输出答案，四舍五入到整数。",
    "inputExample": "<pre>3\n1 1 2\n2 16 1\n3 4 33</pre>",
    "outputExample": "<pre>10\n30\n50</pre>",
    "tip": "【数据范围】N≤31，1≤S,D≤2^2N，1≤T≤10000.",
    "timeLimited": "1000ms",
    "spaceLimited": "65536kB"
  }
]